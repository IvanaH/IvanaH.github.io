<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Java&amp;#8482;: A Beginner&amp;#8217;s Guide Sixth Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="filepos1060750" class="calibre29"><span><img alt="image" src="images/00003.jpg" class="calibre30"/></span></div><div class="calibre11"> </div>
<div class="calibre31"><span class="calibre2"><span><big class="calibre3"><big class="calibre4"><big class="calibre5"><big class="calibre6"><big class="calibre32"><big class="calibre4">Chapter 13</big></big></big></big></big></big></span></span></div>
<div class="calibre9"><span class="calibre2"><span>Generics</span></span></div><div class="calibre33"> </div>
<div class="calibre1"><span class="calibre10"><span><span class="bold1">Key Skills &amp; Concepts</span></span></span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Understand the benefits of generics</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Create a generic class</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Apply bounded type parameters</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Use wildcard arguments</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Apply bounded wildcards</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Create a generic method</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Create a generic constructor</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Create a generic interface</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Utilize raw types</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Apply type inference with the diamond operator</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Understand erasure</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Avoid ambiguity errors</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Know generics restrictions</span></div>
<div class="calibre1"><span><img alt="image" src="images/00004.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre12"><span><span><span class="calibre2">S</span></span>ince its original 1.0 version, many new features have been added to Java. All have enhanced and expanded the scope of the language, but one that has had an especially profound and far-reaching impact is <span class="italic">generics</span> because its effects were felt throughout the entire Java language. For example, generics added a completely new syntax element and caused changes to many of the classes and methods in the core API. It is not an overstatement to say that the inclusion of generics fundamentally reshaped the character of Java.</span></div>
<div class="calibre23"><span>The topic of generics is quite large, and some of it is sufficiently advanced to be beyond the scope of this book. However, a basic understanding of generics is necessary for all Java programmers. At first glance, the generics syntax may look a bit intimidating, but don’t worry. Generics are surprisingly simple to use. By the time you finish this chapter, you will have a grasp of the key concepts that underlie generics and sufficient knowledge to use generics effectively in your own programs.</span></div>
<div id="filepos1065117" class="calibre1"><span class="calibre10"><span><span class="bold1">Generics Fundamentals</span></span></span></div>
<div class="calibre12"><span>At its core, the term <span class="italic">generics</span> means <span class="italic">parameterized types</span>. Parameterized types are important because they enable you to create classes, interfaces, and methods in which the type of data upon which they operate is specified as a parameter. A class, interface, or method that operates on a type parameter is called <span class="italic">generic</span>, as in <span class="italic">generic class</span> or <span class="italic">generic method</span>.</span></div>
<div class="calibre35"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   I have heard that Java’s generics are similar to templates in C++. Is this the case?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   Java generics are similar to templates in C++. What Java calls a parameterized type, C++ calls a template. However, Java generics and C++ templates are not the same, and there are some fundamental differences between the two approaches to generic types. For the most part, Java’s approach is simpler to use.</span></div>
<div class="calibre624"><span>A word of warning: If you have a background in C++, it is important not to jump to conclusions about how generics work in Java. The two approaches to generic code differ in subtle but fundamental ways.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre23"><span>A principal advantage of generic code is that it will automatically work with the type of data passed to its type parameter. Many algorithms are logically the same no matter what type of data they are being applied to. For example, a Quicksort is the same whether it is sorting items of type <span class="bold1">Integer</span>, <span class="bold1">String</span>, <span class="bold1">Object</span>, or <span class="bold1">Thread</span>. With generics, you can define an algorithm once, independently of any specific type of data, and then apply that algorithm to a wide variety of data types without any additional effort.</span></div>
<div class="calibre23"><span>It is important to understand that Java has always given you the ability to create generalized classes, interfaces, and methods by operating through references of type <span class="bold1">Object</span>. Because <span class="bold1">Object</span> is the superclass of all other classes, an <span class="bold1">Object</span> reference can refer to any type of object. Thus, in pre-generics code, generalized classes, interfaces, and methods used <span class="bold1">Object</span> references to operate on various types of data. The problem was that they could not do so with <span class="italic">type safety</span> because casts were needed to explicitly convert from <span class="bold1">Object</span> to the actual type of data being operated upon. Thus, it was possible to accidentally create type mismatches. Generics add the type safety that was lacking because they make these casts automatic and implicit. In short, generics expand your ability to reuse code and let you do so safely and reliably.</span></div>
<div id="filepos1068640" class="calibre1"><span class="calibre10"><span><span class="bold1">A Simple Generics Example</span></span></span></div>
<div class="calibre12"><span>Before discussing any more theory, it’s best to look at a simple generics example. The following program defines two classes. The first is the generic class <span class="bold1">Gen</span>, and the second is <span class="bold1">GenDemo</span>, which uses <span class="bold1">Gen</span>.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00783.jpg" class="calibre769"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00784.jpg" class="calibre770"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00785.jpg" class="calibre771"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The output produced by the program is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00786.jpg" class="calibre772"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Let’s examine this program carefully. First, notice how <span class="bold1">Gen</span> is declared by the following line:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00787.jpg" class="calibre773"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, <span class="bold1">T</span> is the name of a <span class="italic">type parameter</span>. This name is used as a placeholder for the actual type that will be passed to <span class="bold1">Gen</span> when an object is created. Thus, <span class="bold1">T</span> is used within <span class="bold1">Gen</span> whenever the type parameter is needed. Notice that <span class="bold1">T</span> is contained within <span class="bold1">&lt; &gt;</span>. This syntax can be generalized. Whenever a type parameter is being declared, it is specified within angle brackets. Because <span class="bold1">Gen</span> uses a type parameter, <span class="bold1">Gen</span> is a generic class.</span></div>
<div class="calibre23"><span>In the declaration of <span class="bold1">Gen</span>, there is no special significance to the name <span class="bold1">T</span>. Any valid identifier could have been used, but <span class="bold1">T</span> is traditional. Furthermore, it is recommended that type parameter names be single-character, capital letters. Other commonly used type parameter names are <span class="bold1">V</span> and <span class="bold1">E</span>.</span></div>
<div class="calibre23"><span>Next, <span class="bold1">T</span> is used to declare an object called <span class="bold1">ob</span>, as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00788.jpg" class="calibre774"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>As explained, <span class="bold1">T</span> is a placeholder for the actual type that will be specified when a <span class="bold1">Gen</span> object is created. Thus, <span class="bold1">ob</span> will be an object of the type passed to <span class="bold1">T</span>. For example, if type <span class="bold1">String</span> is passed to <span class="bold1">T</span>, then in that instance, <span class="bold1">ob</span> will be of type <span class="bold1">String</span>.</span></div>
<div class="calibre23"><span>Now consider <span class="bold1">Gen</span>’s constructor:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00789.jpg" class="calibre775"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Notice that its parameter, <span class="bold1">o</span>, is of type <span class="bold1">T</span>. This means that the actual type of <span class="bold1">o</span> is determined by the type passed to <span class="bold1">T</span> when a <span class="bold1">Gen</span> object is created. Also, because both the parameter <span class="bold1">o</span> and the member variable <span class="bold1">ob</span> are of type <span class="bold1">T</span>, they will both be of the same actual type when a <span class="bold1">Gen</span> object is created.</span></div>
<div class="calibre23"><span>The type parameter <span class="bold1">T</span> can also be used to specify the return type of method, as is the case with the <span class="bold1">getob( )</span> method, shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00790.jpg" class="calibre776"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Because <span class="bold1">ob</span> is also of type <span class="bold1">T</span>, its type is compatible with the return type specified by <span class="bold1">getob( )</span>.</span></div>
<div class="calibre23"><span>The <span class="bold1">showType( )</span> method displays the type of <span class="bold1">T</span>. It does this by calling <span class="bold1">getName( )</span> on the <span class="bold1">Class</span> object returned by the call to <span class="bold1">getClass( )</span> on <span class="bold1">ob</span>. We haven’t used this feature before, so let’s examine it closely. As you should recall from <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_014.html#filepos626773">Chapter 7</a>, the <span class="bold1">Object</span> class defines the method <span class="bold1">getClass( )</span>. Thus, <span class="bold1">getClass( )</span> is a member of all class types. It returns a <span class="bold1">Class</span> object that corresponds to the class type of the object on which it is called. <span class="bold1">Class</span> is a class defined within <span class="bold1">java.lang</span> that encapsulates information about a class. <span class="bold1">Class</span> defines several methods that can be used to obtain information about a class at run time. Among these is the <span class="bold1">getName( )</span> method, which returns a string representation of the class name.</span></div>
<div class="calibre23"><span>The <span class="bold1">GenDemo</span> class demonstrates the generic <span class="bold1">Gen</span> class. It first creates a version of <span class="bold1">Gen</span> for integers, as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00791.jpg" class="calibre455"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Look carefully at this declaration. First, notice that the type <span class="bold1">Integer</span> is specified within the angle brackets after <span class="bold1">Gen</span>. In this case, <span class="bold1">Integer</span> is a <span class="italic">type argument</span> that is passed to <span class="bold1">Gen</span>’s type parameter, <span class="bold1">T</span>. This effectively creates a version of <span class="bold1">Gen</span> in which all references to <span class="bold1">T</span> are translated into references to <span class="bold1">Integer</span>. Thus, for this declaration, <span class="bold1">ob</span> is of type <span class="bold1">Integer</span>, and the return type of <span class="bold1">getob( )</span> is of type <span class="bold1">Integer</span>.</span></div>
<div class="calibre23"><span>Before moving on, it’s necessary to state that the Java compiler does not actually create different versions of <span class="bold1">Gen</span>, or of any other generic class. Although it’s helpful to think in these terms, it is not what actually happens. Instead, the compiler removes all generic type information, substituting the necessary casts, to make your code <span class="italic">behave as if</span> a specific version of <span class="bold1">Gen</span> was created. Thus, there is really only one version of <span class="bold1">Gen</span> that actually exists in your program. The process of removing generic type information is called <span class="italic">erasure</span>, which is discussed later in this chapter.</span></div>
<div class="calibre23"><span>The next line assigns to <span class="bold1">iOb</span> a reference to an instance of an <span class="bold1">Integer</span> version of the <span class="bold1">Gen</span> class.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00792.jpg" class="calibre311"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Notice that when the <span class="bold1">Gen</span> constructor is called, the type argument <span class="bold1">Integer</span> is also specified. This is because the type of the object (in this case <span class="bold1">iOb</span>) to which the reference is being assigned is of type <span class="bold1">Gen&lt;Integer&gt;</span>. Thus, the reference returned by <span class="bold1">new</span> must also be of type <span class="bold1">Gen&lt;Integer&gt;</span>. If it isn’t, a compile-time error will result. For example, the following assignment will cause a compile-time error:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00793.jpg" class="calibre777"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Because <span class="bold1">iOb</span> is of type <span class="bold1">Gen&lt;Integer&gt;</span>, it can’t be used to refer to an object of <span class="bold1">Gen&lt;Double&gt;</span>. This type of checking is one of the main benefits of generics because it ensures type safety.</span></div>
<div class="calibre23"><span>As the comments in the program state, the assignment</span></div>
<div class="calibre1"><span><img alt="image" src="images/00794.jpg" class="calibre311"/></span></div><div class="calibre11"> </div>
<div class="calibre27"><span>makes use of autoboxing to encapsulate the value 88, which is an <span class="bold1">int</span>, into an <span class="bold1">Integer</span>. This works because <span class="bold1">Gen&lt;Integer&gt;</span> creates a constructor that takes an <span class="bold1">Integer</span> argument. Because an <span class="bold1">Integer</span> is expected, Java will automatically box 88 inside one. Of course, the assignment could also have been written explicitly, like this:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00795.jpg" class="calibre111"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>However, there would be no benefit to using this version.</span></div>
<div class="calibre23"><span>The program then displays the type of <span class="bold1">ob</span> within <span class="bold1">iOb</span>, which is <span class="bold1">Integer</span>. Next, the program obtains the value of <span class="bold1">ob</span> by use of the following line:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00796.jpg" class="calibre778"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Because the return type of <span class="bold1">getob( )</span> is <span class="bold1">T</span>, which was replaced by <span class="bold1">Integer</span> when <span class="bold1">iOb</span> was declared, the return type of <span class="bold1">getob( )</span> is also <span class="bold1">Integer</span>, which auto-unboxes into <span class="bold1">int</span> when assigned to <span class="bold1">v</span> (which is an <span class="bold1">int</span>). Thus, there is no need to cast the return type of <span class="bold1">getob( )</span> to <span class="bold1">Integer</span>.</span></div>
<div class="calibre23"><span>Next, <span class="bold1">GenDemo</span> declares an object of type <span class="bold1">Gen&lt;String&gt;</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00797.jpg" class="calibre779"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Because the type argument is <span class="bold1">String</span>, <span class="bold1">String</span> is substituted for <span class="bold1">T</span> inside <span class="bold1">Gen</span>. This creates (conceptually) a <span class="bold1">String</span> version of <span class="bold1">Gen</span>, as the remaining lines in the program demonstrate.</span></div>
<div id="filepos1079040" class="calibre1"><span class="calibre10"><span><span class="bold1">Generics Work Only with Reference Types</span></span></span></div>
<div class="calibre12"><span>When declaring an instance of a generic type, the type argument passed to the type parameter must be a reference type. You cannot use a primitive type, such as <span class="bold1">int</span> or <span class="bold1">char</span>. For example, with <span class="bold1">Gen</span>, it is possible to pass any class type to <span class="bold1">T</span>, but you cannot pass a primitive type to <span class="bold1">T</span>. Therefore, the following declaration is illegal:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00798.jpg" class="calibre780"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Of course, not being able to specify a primitive type is not a serious restriction because you can use the type wrappers (as the preceding example did) to encapsulate a primitive type. Further, Java’s autoboxing and auto-unboxing mechanism makes the use of the type wrapper transparent.</span></div>
<div id="filepos1080101" class="calibre1"><span class="calibre10"><span><span class="bold1">Generic Types Differ Based on Their Type Arguments</span></span></span></div>
<div class="calibre12"><span>A key point to understand about generic types is that a reference of one specific version of a generic type is not type-compatible with another version of the same generic type. For example, assuming the program just shown, the following line of code is in error and will not compile:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00799.jpg" class="calibre781"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Even though both <span class="bold1">iOb</span> and <span class="bold1">strOb</span> are of type <span class="bold1">Gen&lt;T&gt;</span>, they are references to different types because their type arguments differ. This is part of the way that generics add type safety and prevent errors.</span></div>
<div id="filepos1081033" class="calibre1"><span class="calibre10"><span><span class="bold1">A Generic Class with Two Type Parameters</span></span></span></div>
<div class="calibre12"><span>You can declare more than one type parameter in a generic type. To specify two or more type parameters, simply use a comma-separated list. For example, the following <span class="bold1">TwoGen</span> class is a variation of the <span class="bold1">Gen</span> class that has two type parameters:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00800.jpg" class="calibre516"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The output from this program is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00801.jpg" class="calibre782"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Notice how <span class="bold1">TwoGen</span> is declared:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00802.jpg" class="calibre783"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>It specifies two type parameters, <span class="bold1">T</span> and <span class="bold1">V</span>, separated by a comma. Because it has two type parameters, two type arguments must be passed to <span class="bold1">TwoGen</span> when an object is created, as shown next:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00803.jpg" class="calibre784"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>In this case, <span class="bold1">Integer</span> is substituted for <span class="bold1">T</span>, and <span class="bold1">String</span> is substituted for <span class="bold1">V</span>. Although the two type arguments differ in this example, it is possible for both types to be the same. For example, the following line of code is valid:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00804.jpg" class="calibre780"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>In this case, both <span class="bold1">T</span> and <span class="bold1">V</span> would be of type <span class="bold1">String</span>. Of course, if the type arguments were always the same, then two type parameters would be unnecessary.</span></div>
<div id="filepos1083204" class="calibre1"><span class="calibre10"><span><span class="bold1">The General Form of a Generic Class</span></span></span></div>
<div class="calibre12"><span>The generics syntax shown in the preceding examples can be generalized. Here is the syntax for declaring a generic class:</span></div>
<div class="calibre27"><span>class <span class="italic">class-name</span>&lt;<span class="italic">type-param-list</span>&gt; { // …</span></div>
<div class="calibre27"><span>Here is the full syntax for declaring a reference to a generic class and creating a generic instance:</span></div>
<div class="calibre27"><span><span class="italic">class-name</span>&lt;<span class="italic">type-arg-list</span>&gt; <span class="italic">var-name</span> =</span></div>
<div class="calibre12"><blockquote class="calibre66"><span>new <span class="italic">class-name</span>&lt;<span class="italic">type-arg-list</span>&gt;(<span class="italic">cons-arg-list</span>);</span></blockquote></div>
<div id="filepos1084127" class="calibre1"><span class="calibre10"><span><span class="bold1">Bounded Types</span></span></span></div>
<div class="calibre12"><span>In the preceding examples, the type parameters could be replaced by any class type. This is fine for many purposes, but sometimes it is useful to limit the types that can be passed to a type parameter. For example, assume that you want to create a generic class that stores a numeric value and is capable of performing various mathematical functions, such as computing the reciprocal or obtaining the fractional component. Furthermore, you want to use the class to compute these quantities for any type of number, including integers, <span class="bold1">float</span>s, and <span class="bold1">double</span>s. Thus, you want to specify the type of the numbers generically, using a type parameter. To create such a class, you might try something like this:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00805.jpg" class="calibre612"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Unfortunately, <span class="bold1">NumericFns</span> will not compile as written because both methods will generate compile-time errors. First, examine the <span class="bold1">reciprocal( )</span> method, which attempts to return the reciprocal of <span class="bold1">num</span>. To do this, it must divide 1 by the value of <span class="bold1">num</span>. The value of <span class="bold1">num</span> is obtained by calling <span class="bold1">doubleValue( )</span>, which obtains the <span class="bold1">double</span> version of the numeric object stored in <span class="bold1">num</span>. Because all numeric classes, such as <span class="bold1">Integer</span> and <span class="bold1">Double</span>, are subclasses of <span class="bold1">Number</span>, and <span class="bold1">Number</span> defines the <span class="bold1">doubleValue( )</span> method, this method is available to all numeric wrapper classes. The trouble is that the compiler has no way to know that you are intending to create <span class="bold1">NumericFns</span> objects using only numeric types. Thus, when you try to compile <span class="bold1">NumericFns</span>, an error is reported that indicates that the <span class="bold1">doubleValue( )</span> method is unknown. The same type of error occurs twice in <span class="bold1">fraction( )</span>, which needs to call both <span class="bold1">doubleValue( )</span> and <span class="bold1">intValue( )</span>. Both calls result in error messages stating that these methods are unknown. To solve this problem, you need some way to tell the compiler that you intend to pass only numeric types to <span class="bold1">T</span>. Furthermore, you need some way to <span class="italic">ensure</span> that <span class="italic">only</span> numeric types are actually passed.</span></div>
<div class="calibre23"><span>To handle such situations, Java provides <span class="italic">bounded types</span>. When specifying a type parameter, you can create an upper bound that declares the superclass from which all type arguments must be derived. This is accomplished through the use of an <span class="bold1">extends</span> clause when specifying the type parameter, as shown here:</span></div>
<div class="calibre27"><span>&lt;<span class="italic">T</span> extends <span class="italic">superclass</span>&gt;</span></div>
<div class="calibre27"><span>This specifies that <span class="italic">T</span> can be replaced only by <span class="italic">superclass</span>, or subclasses of <span class="italic">superclass</span>. Thus, <span class="italic">superclass</span> defines an inclusive, upper limit.</span></div>
<div class="calibre23"><span>You can use an upper bound to fix the <span class="bold1">NumericFns</span> class shown earlier by specifying <span class="bold1">Number</span> as an upper bound, as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00806.jpg" class="calibre785"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00807.jpg" class="calibre786"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The output is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00808.jpg" class="calibre787"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Notice how <span class="bold1">NumericFns</span> is now declared by this line:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00809.jpg" class="calibre788"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Because the type <span class="bold1">T</span> is now bounded by <span class="bold1">Number</span>, the Java compiler knows that all objects of type <span class="bold1">T</span> can call <span class="bold1">doubleValue( )</span> because it is a method declared by <span class="bold1">Number</span>. This is, by itself, a major advantage. However, as an added bonus, the bounding of <span class="bold1">T</span> also prevents nonnumeric <span class="bold1">NumericFns</span> objects from being created. For example, if you remove the comments from the lines at the end of the program, and then try re-compiling, you will receive compile-time errors because <span class="bold1">String</span> is not a subclass of <span class="bold1">Number</span>.</span></div>
<div class="calibre23"><span>Bounded types are especially useful when you need to ensure that one type parameter is compatible with another. For example, consider the following class called <span class="bold1">Pair</span>, which stores two objects that must be compatible with each other:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00810.jpg" class="calibre789"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Notice that <span class="bold1">Pair</span> uses two type parameters, <span class="bold1">T</span> and <span class="bold1">V</span>, and that <span class="bold1">V</span> extends <span class="bold1">T</span>. This means that <span class="bold1">V</span> will either be the same as <span class="bold1">T</span> or a subclass of <span class="bold1">T</span>. This ensures that the two arguments to <span class="bold1">Pair</span>’s constructor will be objects of the same type or of related types. For example, the following constructions are valid:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00811.jpg" class="calibre790"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>However, the following is invalid:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00812.jpg" class="calibre791"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>In this case, <span class="bold1">String</span> is not a subclass of <span class="bold1">Number</span>, which violates the bound specified by <span class="bold1">Pair</span>.</span></div>
<div id="filepos1090339" class="calibre1"><span class="calibre10"><span><span class="bold1">Using Wildcard Arguments</span></span></span></div>
<div class="calibre12"><span>As useful as type safety is, sometimes it can get in the way of perfectly acceptable constructs. For example, given the <span class="bold1">NumericFns</span> class shown at the end of the preceding section, assume that you want to add a method called <span class="bold1">absEqual( )</span> that returns true if two <span class="bold1">NumericFns</span> objects contain numbers whose absolute values are the same. Furthermore, you want this method to be able to work properly no matter what type of number each object holds. For example, if one object contains the <span class="bold1">Double</span> value 1.25 and the other object contains the <span class="bold1">Float</span> value –1.25, then <span class="bold1">absEqual( )</span> would return true. One way to implement <span class="bold1">absEqual( )</span> is to pass it a <span class="bold1">NumericFns</span> argument, and then compare the absolute value of that argument against the absolute value of the invoking object, returning true only if the values are the same. For example, you want to be able to call <span class="bold1">absEqual( )</span>, as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00813.jpg" class="calibre792"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>At first, creating <span class="bold1">absEqual( )</span> seems like an easy task. Unfortunately, trouble starts as soon as you try to declare a parameter of type <span class="bold1">NumericFns</span>. What type do you specify for <span class="bold1">NumericFns</span>’ type parameter? At first, you might think of a solution like this, in which <span class="bold1">T</span> is used as the type parameter:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00814.jpg" class="calibre793"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, the standard method <span class="bold1">Math.abs( )</span> is used to obtain the absolute value of each number, and then the values are compared. The trouble with this attempt is that it will work only with other <span class="bold1">NumericFns</span> objects whose type is the same as the invoking object. For example, if the invoking object is of type <span class="bold1">NumericFns&lt;Integer&gt;</span>, then the parameter <span class="bold1">ob</span> must also be of type <span class="bold1">NumericFns&lt;Integer&gt;</span>. It can’t be used to compare an object of type <span class="bold1">NumericFns&lt;Double&gt;</span>, for example. Therefore, this approach does not yield a general (i.e., generic) solution.</span></div>
<div class="calibre23"><span>To create a generic <span class="bold1">absEqual( )</span> method, you must use another feature of Java generics: the <span class="italic">wildcard argument</span>. The wildcard argument is specified by the <span class="bold1">?</span>, and it represents an unknown type. Using a wildcard, here is one way to write the <span class="bold1">absEqual( )</span> method:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00815.jpg" class="calibre794"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, <span class="bold1">NumericFns&lt;?&gt;</span> matches any type of <span class="bold1">NumericFns</span> object, allowing any two <span class="bold1">NumericFns</span> objects to have their absolute values compared. The following program demonstrates this:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00816.jpg" class="calibre795"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00817.jpg" class="calibre489"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The output is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00818.jpg" class="calibre796"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>In the program, notice these two calls to <span class="bold1">absEqual( )</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00819.jpg" class="calibre797"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>In the first call, <span class="bold1">iOb</span> is an object of type <span class="bold1">NumericFns&lt;Integer&gt;</span> and <span class="bold1">dOb</span> is an object of type <span class="bold1">NumericFns&lt;Double&gt;</span>. However, through the use of a wildcard, it is possible for <span class="bold1">iOb</span> to pass <span class="bold1">dOb</span> in the call to <span class="bold1">absEqual( )</span>. The same applies to the second call, in which an object of type <span class="bold1">NumericFns&lt;Long&gt;</span> is passed.</span></div>
<div class="calibre23"><span>One last point: It is important to understand that the wildcard does not affect what type of <span class="bold1">NumericFns</span> objects can be created. This is governed by the <span class="bold1">extends</span> clause in the <span class="bold1">NumericFns</span> declaration. The wildcard simply matches any <span class="italic">valid</span>
<span class="bold1">NumericFns</span> object.</span></div>
<div id="filepos1095207" class="calibre1"><span class="calibre10"><span><span class="bold1">Bounded Wildcards</span></span></span></div>
<div class="calibre12"><span>Wildcard arguments can be bounded in much the same way that a type parameter can be bounded. A bounded wildcard is especially important when you are creating a method that is designed to operate only on objects that are subclasses of a specific superclass. To understand why, let’s work through a simple example. Consider the following set of classes:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00820.jpg" class="calibre798"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, class <span class="bold1">A</span> is extended by classes <span class="bold1">B</span> and <span class="bold1">C</span>, but not by <span class="bold1">D</span>.</span></div>
<div class="calibre23"><span>Next, consider the following very simple generic class:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00821.jpg" class="calibre799"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span><span class="bold1">Gen</span> takes one type parameter, which specifies the type of object stored in <span class="bold1">ob</span>. Because <span class="bold1">T</span> is unbounded, the type of <span class="bold1">T</span> is unrestricted. That is, <span class="bold1">T</span> can be of any class type.</span></div>
<div class="calibre23"><span>Now, suppose that you want to create a method that takes as an argument any type of <span class="bold1">Gen</span> object so long as its type parameter is <span class="bold1">A</span> or a subclass of <span class="bold1">A</span>. In other words, you want to create a method that operates only on objects of <span class="bold1">Gen&lt;</span><span class="italic">type</span><span class="bold1">&gt;</span>, where <span class="italic">type</span> is either <span class="bold1">A</span> or a subclass of <span class="bold1">A</span>. To accomplish this, you must use a bounded wildcard. For example, here is a method called <span class="bold1">test( )</span> that accepts as an argument only <span class="bold1">Gen</span> objects whose type parameter is <span class="bold1">A</span> or a subclass of <span class="bold1">A</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00822.jpg" class="calibre800"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>The following class demonstrates the types of <span class="bold1">Gen</span> objects that can be passed to <span class="bold1">test( )</span>.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00823.jpg" class="calibre801"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>In <span class="bold1">main( )</span>, objects of type <span class="bold1">A</span>, <span class="bold1">B</span>, <span class="bold1">C</span>, and <span class="bold1">D</span> are created. These are then used to create four <span class="bold1">Gen</span> objects, one for each type. Finally, four calls to <span class="bold1">test( )</span> are made, with the last call commented out. The first three calls are valid because <span class="bold1">w</span>, <span class="bold1">w2</span>, and <span class="bold1">w3</span> are <span class="bold1">Gen</span> objects whose type is either <span class="bold1">A</span> or a subclass of <span class="bold1">A</span>. However, the last call to <span class="bold1">test( )</span> is illegal because <span class="bold1">w4</span> is an object of type <span class="bold1">D</span>, which is not derived from <span class="bold1">A</span>. Thus, the bounded wildcard in <span class="bold1">test( )</span> will not accept <span class="bold1">w4</span> as an argument.</span></div>
<div class="calibre23"><span>In general, to establish an upper bound for a wildcard, use the following type of wildcard expression:</span></div>
<div class="calibre27"><span>&lt;? extends <span class="italic">superclass</span>&gt;</span></div>
<div class="calibre35"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   Can I cast one instance of a generic class into another?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   Yes, you can cast one instance of a generic class into another, but only if the two are otherwise compatible and their type arguments are the same. For example, assume a generic class called <span class="bold1">Gen</span> that is declared like this:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00824.jpg" class="calibre802"/></span></div>
<div class="calibre1"><span>Next, assume that <span class="bold1">x</span> is declared as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00825.jpg" class="calibre803"/></span></div>
<div class="calibre1"><span>Then, this cast is legal</span></div>
<div class="calibre1"><span><img alt="image" src="images/00826.jpg" class="calibre804"/></span></div>
<div class="calibre1"><span>because <span class="bold1">x</span> is an instance of <span class="bold1">Gen&lt;Integer&gt;</span>. But, this cast</span></div>
<div class="calibre1"><span><img alt="image" src="images/00827.jpg" class="calibre805"/></span></div>
<div class="calibre1"><span>is not legal because <span class="bold1">x</span> is not an instance of <span class="bold1">Gen&lt;Long&gt;</span>.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre12"><span>where <span class="italic">superclass</span> is the name of the class that serves as the upper bound. Remember, this is an inclusive clause because the class forming the upper bound (specified by <span class="italic">superclass</span>) is also within bounds.</span></div>
<div class="calibre23"><span>You can also specify a lower bound for a wildcard by adding a <span class="bold1">super</span> clause to a wildcard declaration. Here is its general form:</span></div>
<div class="calibre27"><span>&lt;? super <span class="italic">subclass</span>&gt;</span></div>
<div class="calibre27"><span>In this case, only classes that are superclasses of <span class="italic">subclass</span> are acceptable arguments. This is an inclusive clause.</span></div>
<div id="filepos1101442" class="calibre1"><span class="calibre10"><span><span class="bold1">Generic Methods</span></span></span></div>
<div class="calibre12"><span>As the preceding examples have shown, methods inside a generic class can make use of a class’ type parameter and are, therefore, automatically generic relative to the type parameter. However, it is possible to declare a generic method that uses one or more type parameters of its own. Furthermore, it is possible to create a generic method that is enclosed within a nongeneric class.</span></div>
<div class="calibre23"><span>The following program declares a nongeneric class called <span class="bold1">GenericMethodDemo</span> and a static generic method within that class called <span class="bold1">arraysEqual( )</span>. This method determines if two arrays contain the same elements, in the same order. It can be used to compare any two arrays as long as the arrays are of the same or compatible types and the array elements are, themselves, comparable.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00828.jpg" class="calibre806"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The output from the program is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00829.jpg" class="calibre807"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Let’s examine <span class="bold1">arraysEqual( )</span> closely. First, notice how it is declared by this line:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00830.jpg" class="calibre480"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The type parameters are declared <span class="italic">before</span> the return type of the method. Also note that <span class="bold1">T</span> extends <span class="bold1">Comparable&lt;T&gt;</span>. <span class="bold1">Comparable</span> is an interface declared in <span class="bold1">java.lang</span>. A class that implements <span class="bold1">Comparable</span> defines objects that can be ordered. Thus, requiring an upper bound of <span class="bold1">Comparable</span> ensures that <span class="bold1">arraysEqual( )</span> can be used only with objects that are capable of being compared. <span class="bold1">Comparable</span> is generic, and its type parameter specifies the type of objects that it compares. (Shortly, you will see how to create a generic interface.) Next, notice that the type <span class="bold1">V</span> is upper-bounded by <span class="bold1">T</span>. Thus, <span class="bold1">V</span> must be either the same as type <span class="bold1">T</span> or a subclass of <span class="bold1">T</span>. This relationship enforces that <span class="bold1">arraysEqual( )</span> can be called only with arguments that are comparable with each other. Also notice that <span class="bold1">arraysEqual( )</span> is static, enabling it to be called independently of any object. Understand, though, that generic methods can be either static or nonstatic. There is no restriction in this regard.</span></div>
<div class="calibre23"><span>Now, notice how <span class="bold1">arraysEqual( )</span> is called within <span class="bold1">main( )</span> by use of the normal call syntax, without the need to specify type arguments. This is because the types of the arguments are automatically discerned, and the types of <span class="bold1">T</span> and <span class="bold1">V</span> are adjusted accordingly. For example, in the first call:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00831.jpg" class="calibre808"/></span></div><div class="calibre11"> </div>
<div class="calibre27"><span>the element type of the first argument is <span class="bold1">Integer</span>, which causes <span class="bold1">Integer</span> to be substituted for <span class="bold1">T</span>. The element type of the second argument is also <span class="bold1">Integer</span>, which makes <span class="bold1">Integer</span> a substitute for <span class="bold1">V</span>, too. Thus, the call to <span class="bold1">arraysEqual( )</span> is legal, and the two arrays can be compared.</span></div>
<div class="calibre23"><span>Now, notice the commented-out code, shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00832.jpg" class="calibre809"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>If you remove the comments and then try to compile the program, you will receive an error. The reason is that the type parameter <span class="bold1">V</span> is bounded by <span class="bold1">T</span> in the <span class="bold1">extends</span> clause in <span class="bold1">V</span>’s declaration. This means that <span class="bold1">V</span> must be either type <span class="bold1">T</span> or a subclass of <span class="bold1">T</span>. In this case, the first argument is of type <span class="bold1">Integer</span>, making <span class="bold1">T</span> into <span class="bold1">Integer</span>, but the second argument is of type <span class="bold1">Double</span>, which is not a subclass of <span class="bold1">Integer</span>. This makes the call to <span class="bold1">arraysEqual( )</span> illegal, and results in a compile-time type-mismatch error.</span></div>
<div class="calibre23"><span>The syntax used to create <span class="bold1">arraysEqual( )</span> can be generalized. Here is the syntax for a generic method:</span></div>
<div class="calibre27"><span>&lt;<span class="italic">type-param-list</span>&gt; <span class="italic">ret-type meth-name</span>(<span class="italic">param-list</span>) { // …</span></div>
<div class="calibre27"><span>In all cases, <span class="italic">type-param-list</span> is a comma-separated list of type parameters. Notice that for a generic method, the type parameter list precedes the return type.</span></div>
<div id="filepos1106711" class="calibre1"><span class="calibre10"><span><span class="bold1">Generic Constructors</span></span></span></div>
<div class="calibre12"><span>A constructor can be generic, even if its class is not. For example, in the following program, the class <span class="bold1">Summation</span> is not generic, but its constructor is.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00833.jpg" class="calibre810"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The <span class="bold1">Summation</span> class computes and encapsulates the summation of the numeric value passed to its constructor. Recall that the summation of <span class="italic">N</span> is the sum of all the whole numbers between 0 and <span class="italic">N</span>. Because <span class="bold1">Summation( )</span> specifies a type parameter that is bounded by <span class="bold1">Number</span>, a <span class="bold1">Summation</span> object can be constructed using any numeric type, including <span class="bold1">Integer</span>, <span class="bold1">Float</span>, or <span class="bold1">Double</span>. No matter what numeric type is used, its value is converted to <span class="bold1">Integer</span> by calling <span class="bold1">intValue( )</span>, and the summation is computed. Therefore, it is not necessary for the class <span class="bold1">Summation</span> to be generic; only a generic constructor is needed.</span></div>
<div id="filepos1107938" class="calibre1"><span class="calibre10"><span><span class="bold1">Generic Interfaces</span></span></span></div>
<div class="calibre12"><span>As you saw in the <span class="bold1">GenericMethodDemo</span> program presented earlier, an interface can be generic. In that example, the standard interface <span class="bold1">Comparable&lt;T&gt;</span> was used to ensure that elements of two arrays could be compared. Of course, you can also define your own generic interface. Generic interfaces are specified just like generic classes. Here is an example. It creates an interface called <span class="bold1">Containment</span>, which can be implemented by classes that store one or more values. It declares a method called <span class="bold1">contains( )</span> that determines if a specified value is contained by the invoking object.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00834.jpg" class="calibre811"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The output is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00835.jpg" class="calibre812"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Although most aspects of this program should be easy to understand, a couple of key points need to be made. First, notice that <span class="bold1">Containment</span> is declared like this:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00836.jpg" class="calibre813"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>In general, a generic interface is declared in the same way as a generic class. In this case, the type parameter <span class="bold1">T</span> specifies the type of objects that are contained.</span></div>
<div class="calibre23"><span>Next, <span class="bold1">Containment</span> is implemented by <span class="bold1">MyClass</span>. Notice the declaration of <span class="bold1">MyClass</span>, shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00837.jpg" class="calibre814"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>In general, if a class implements a generic interface, then that class must also be generic, at least to the extent that it takes a type parameter that is passed to the interface. For example, the following attempt to declare <span class="bold1">MyClass</span> is in error:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00838.jpg" class="calibre815"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>This declaration is wrong because <span class="bold1">MyClass</span> does not declare a type parameter, which means that there is no way to pass one to <span class="bold1">Containment</span>. In this case, the identifier <span class="bold1">T</span> is simply unknown and the compiler reports an error. Of course, if a class implements a <span class="italic">specific type</span> of generic interface, such as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00839.jpg" class="calibre816"/></span></div><div class="calibre11"> </div>
<div class="calibre27"><span>then the implementing class does not need to be generic.</span></div>
<div class="calibre23"><span>As you might expect, the type parameter(s) specified by a generic interface can be bounded. This lets you limit the type of data for which the interface can be implemented. For example, if you wanted to limit <span class="bold1">Containment</span> to numeric types, then you could declare it like this:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00840.jpg" class="calibre817"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Now, any implementing class must pass to <span class="bold1">Containment</span> a type argument also having the same bound. For example, now <span class="bold1">MyClass</span> must be declared as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00841.jpg" class="calibre818"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Pay special attention to the way the type parameter <span class="bold1">T</span> is declared by <span class="bold1">MyClass</span> and then passed to <span class="bold1">Containment</span>. Because <span class="bold1">Containment</span> now requires a type that extends <span class="bold1">Number</span>, the implementing class (<span class="bold1">MyClass</span> in this case) must specify the same bound. Furthermore, once this bound has been established, there is no need to specify it again in the <span class="bold1">implements</span> clause. In fact, it would be wrong to do so. For example, this declaration is incorrect and won’t compile:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00842.jpg" class="calibre819"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Once the type parameter has been established, it is simply passed to the interface without further modification.</span></div>
<div class="calibre23"><span>Here is the generalized syntax for a generic interface:</span></div>
<div class="calibre27"><span>interface <span class="italic">interface-name</span>&lt;<span class="italic">type-param-list</span>&gt; { // …</span></div>
<div class="calibre27"><span>Here, <span class="italic">type-param-list</span> is a comma-separated list of type parameters. When a generic interface is implemented, you must specify the type arguments, as shown here:</span></div>
<div class="calibre27"><span>class <span class="italic">class-name</span>&lt;<span class="italic">type-param-list</span>&gt;</span></div>
<div class="calibre12"><blockquote class="calibre66"><span>implements <span class="italic">interface-name</span>&lt;<span class="italic">type-param-list</span>&gt; {</span></blockquote></div>
<div class="calibre18"> </div><table cellspacing="0" cellpadding="0" class="calibre37">
<colgroup class="calibre38">
<col class="calibre72"/>
<col class="calibre73"/>
</colgroup>
<tr class="calibre41">
<td valign="top" id="filepos1113827" class="calibre74"><span class="calibre10"><span class="bold1">Try This 13-1</span> </span></td>
<td valign="top" class="calibre75"><span class="calibre10">Create a Generic Queue</span></td>
</tr></table><div class="calibre43"> </div>
<div class="calibre1"><span><img alt="image" src="images/00843.jpg" class="calibre820"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>One of the most powerful advantages that generics bring to programming is the ability to construct reliable, reusable code. As mentioned at the start of this chapter, many algorithms are the same no matter what type of data they are used on. For example, a queue works the same way whether that queue is for integers, strings, or <span class="bold1">File</span> objects. Instead of creating a separate queue class for each type of object, you can craft a single, generic solution that can be used with any type of object. Thus, the development cycle of design, code, test, and debug occurs only once when you create a generic solution—not repeatedly, each time a queue is needed for a new data type.</span></div>
<div class="calibre23"><span>In this project, you will adapt the queue example that has been evolving since <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_012.html#filepos481142">Try This 5-2</a>, making it generic. This project represents the final evolution of the queue. It includes a generic interface that defines the queue operations, two exception classes, and one queue implementation: a fixed-size queue. Of course, you can experiment with other types of generic queues, such as a generic dynamic queue or a generic circular queue. Just follow the lead of the example shown here.</span></div>
<div class="calibre23"><span>Like the previous version of the queue shown in <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_016.html#filepos814531">Try This 9-1</a>, this project organizes the queue code into a set of separate files: one for the interface, one for each queue exception, one for the fixed-queue implementation, and one for the program that demonstrates it. This organization reflects the way that this project would normally be organized in the real world.</span></div>
<div class="calibre19"><span>  <span class="bold1">1.</span>  The first step in creating a generic queue is to create a generic interface that describes the queue’s two operations: put and get. The generic version of the queue interface is called <span class="bold1">IGenQ</span> and it is shown here. Put this interface into a file called <span class="bold1">IGenQ.java</span>.</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00844.jpg" class="calibre821"/></span></div>
<div class="calibre47"><span>        Notice that the type of data stored by the queue is specified by the generic type parameter <span class="bold1">T</span>.</span></div>
<div class="calibre47"><span>  <span class="bold1">2.</span>  Next, create the files <span class="bold1">QueueFullException.java</span> and <span class="bold1">QueueEmptyException.java</span>. Put in each file its corresponding class, shown here:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00845.jpg" class="calibre822"/></span></div>
<div class="calibre47"><span>        These classes encapsulate the two queue errors: full or empty. They are not generic classes because they are the same no matter what type of data is stored in a queue. Thus, these two files will be the same as those you used with <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_016.html#filepos814531">Try This 9-1</a>.</span></div>
<div class="calibre47"><span>  <span class="bold1">3.</span>  Now, create a file called <span class="bold1">GenQueue.java</span>. Into that file, put the following code, which implements a fixed-size queue:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00846.jpg" class="calibre529"/></span></div>
<div class="calibre47"><span>        <span class="bold1">GenQueue</span> is a generic class with type parameter <span class="bold1">T</span>, which specifies the type of data stored in the queue. Notice that <span class="bold1">T</span> is also passed to the <span class="bold1">IGenQ</span> interface.</span></div>
<div class="calibre47"><span>        Notice that the <span class="bold1">GenQueue</span> constructor is passed a reference to an array that will be used to hold the queue. Thus, to construct a <span class="bold1">GenQueue</span>, you will first create an array whose type is compatible with the objects that you will be storing in the queue and whose size is long enough to store the number of objects that will be placed in the queue.</span></div>
<div class="calibre47"><span>        For example, the following sequence shows how to create a queue that holds strings:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00847.jpg" class="calibre823"/></span></div>
<div class="calibre47"><span>  <span class="bold1">4.</span>  Create a file called <span class="bold1">GenQDemo.java</span> and put the following code into it. This program demonstrates the generic queue.</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00848.jpg" class="calibre706"/></span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00849.jpg" class="calibre824"/></span></div>
<div class="calibre47"><span>  <span class="bold1">5.</span>  Compile the program and run it. You will see the output shown here:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00850.jpg" class="calibre825"/></span></div>
<div class="calibre47"><span>  <span class="bold1">6.</span>  On your own, try converting the <span class="bold1">CircularQueue</span> and <span class="bold1">DynQueue</span> classes from <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_015.html#filepos731136">Try This 8-1</a> into generic classes.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos1121040" class="calibre9"><span class="calibre10"><span><span class="bold1">Raw Types and Legacy Code</span></span></span></div>
<div class="calibre12"><span>Because support for generics did not exist prior to JDK 5, it was necessary for Java to provide some transition path from old, pre-generics code. Simply put, pre-generics legacy code had to remain both functional and compatible with generics. This meant that pre-generics code must be able to work with generics, and generic code must be able to work with pre-generics code.</span></div>
<div class="calibre23"><span>To handle the transition to generics, Java allows a generic class to be used without any type arguments. This creates a <span class="italic">raw type</span> for the class. This raw type is compatible with legacy code, which has no knowledge of generics. The main drawback to using the raw type is that the type safety of generics is lost.</span></div>
<div class="calibre23"><span>Here is an example that shows a raw type in action:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00851.jpg" class="calibre826"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>This program contains several interesting things. First, a raw type of the generic <span class="bold1">Gen</span> class is created by the following declaration:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00852.jpg" class="calibre827"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Notice that no type arguments are specified. In essence, this creates a <span class="bold1">Gen</span> object whose type <span class="bold1">T</span> is replaced by <span class="bold1">Object</span>.</span></div>
<div class="calibre23"><span>A raw type is not type safe. Thus, a variable of a raw type can be assigned a reference to any type of <span class="bold1">Gen</span> object. The reverse is also allowed, in which a variable of a specific <span class="bold1">Gen</span> type can be assigned a reference to a raw <span class="bold1">Gen</span> object. However, both operations are potentially unsafe because the type checking mechanism of generics is circumvented.</span></div>
<div class="calibre23"><span>This lack of type safety is illustrated by the commented-out lines at the end of the program. Let’s examine each case. First, consider the following situation:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00853.jpg" class="calibre828"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>In this statement, the value of <span class="bold1">ob</span> inside <span class="bold1">raw</span> is obtained, and this value is cast to <span class="bold1">Integer</span>. The trouble is that <span class="bold1">raw</span> contains a <span class="bold1">Double</span> value, not an integer value. However, this cannot be detected at compile time because the type of <span class="bold1">raw</span> is unknown. Thus, this statement fails at run time.</span></div>
<div class="calibre23"><span>The next sequence assigns to <span class="bold1">strOb</span> (a reference of type <span class="bold1">Gen&lt;String&gt;</span>) a reference to a raw <span class="bold1">Gen</span> object:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00854.jpg" class="calibre829"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The assignment itself is syntactically correct, but questionable. Because <span class="bold1">strOb</span> is of type <span class="bold1">Gen&lt;String&gt;</span>, it is assumed to contain a <span class="bold1">String</span>. However, after the assignment, the object referred to by <span class="bold1">strOb</span> contains a <span class="bold1">Double</span>. Thus, at run time, when an attempt is made to assign the contents of <span class="bold1">strOb</span> to <span class="bold1">str</span>, a run-time error results because <span class="bold1">strOb</span> now contains a <span class="bold1">Double</span>. Thus, the assignment of a raw reference to a generic reference bypasses the type-safety mechanism.</span></div>
<div class="calibre23"><span>The following sequence inverts the preceding case:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00855.jpg" class="calibre830"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, a generic reference is assigned to a raw reference variable. Although this is syntactically correct, it can lead to problems, as illustrated by the second line. In this case, <span class="bold1">raw</span> now refers to an object that contains an <span class="bold1">Integer</span> object, but the cast assumes that it contains a <span class="bold1">Double</span>. This error cannot be prevented at compile time. Rather, it causes a run-time error.</span></div>
<div class="calibre23"><span>Because of the potential for danger inherent in raw types, <span class="bold1">javac</span> displays <span class="italic">unchecked warnings</span> when a raw type is used in a way that might jeopardize type safety. In the preceding program, these lines generate unchecked warnings:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00856.jpg" class="calibre831"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>In the first line, it is the use of <span class="bold1">Gen</span> without a type argument that causes the warning. In the second line, it is the assignment of a raw reference to a generic variable that generates the warning.</span></div>
<div class="calibre23"><span>At first, you might think that this line should also generate an unchecked warning, but it does not:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00857.jpg" class="calibre832"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>No compiler warning is issued because the assignment does not cause any <span class="italic">further</span> loss of type safety than had already occurred when <span class="bold1">raw</span> was created.</span></div>
<div class="calibre23"><span>One final point: You should limit the use of raw types to those cases in which you must mix legacy code with newer, generic code. Raw types are simply a transitional feature and not something that should be used for new code.</span></div>
<div id="filepos1127222" class="calibre1"><span class="calibre10"><span><span class="bold1">Type Inference with the Diamond Operator</span></span></span></div>
<div class="calibre12"><span>Beginning with JDK 7, it is possible to shorten the syntax used to create an instance of a generic type. To begin, think back to the <span class="bold1">TwoGen</span> class shown earlier in this chapter. A portion is shown here for convenience. Notice that it uses two generic types.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00858.jpg" class="calibre833"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>For versions of Java prior to JDK 7, to create an instance of <span class="bold1">TwoGen</span>, you must use a statement similar to the following:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00859.jpg" class="calibre834"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, the type arguments (which are <span class="bold1">Integer</span> and <span class="bold1">String</span>) are specified twice: first, when <span class="bold1">tgOb</span> is declared, and second, when a <span class="bold1">TwoGen</span> instance is created via <span class="bold1">new</span>. Since generics were introduced by JDK 5, this is the form required by all versions of Java prior to JDK 7. While there is nothing wrong, per se, with this form, it is a bit more verbose than it needs to be. Since, in the <span class="bold1">new</span> clause, the type of the type arguments can be readily inferred, there is really no reason that they need to be specified a second time. To address this situation, JDK 7 added a syntactic element that lets you avoid the second specification.</span></div>
<div class="calibre23"><span>Beginning with JDK 7, the preceding declaration can be rewritten as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00860.jpg" class="calibre480"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Notice that the instance creation portion simply uses &lt; &gt;, which is an empty type argument list. This is referred to as the <span class="italic">diamond</span> operator. It tells the compiler to infer the type arguments needed by the constructor in the <span class="bold1">new</span> expression. The principal advantage of this type-inference syntax is that it shortens what are sometimes quite long declaration statements. This is especially helpful for generic types that specify bounds.</span></div>
<div class="calibre23"><span>The preceding example can be generalized. When type inference is used, the declaration syntax for a generic reference and instance creation has this general form:</span></div>
<div class="calibre27"><span><span class="italic">class-name</span>&lt;<span class="italic">type-arg-list</span>&gt; <span class="italic">var-name</span> = new <span class="italic">class-name</span>&lt; &gt;(<span class="italic">cons-arg-list</span>);</span></div>
<div class="calibre27"><span>Here, the type argument list of the <span class="bold1">new</span> clause is empty.</span></div>
<div class="calibre23"><span>Although mostly for use in declaration statements, type inference can also be applied to parameter passing. For example, if the following method is added to <span class="bold1">TwoGen</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00861.jpg" class="calibre835"/></span></div><div class="calibre11"> </div>
<div class="calibre27"><span>then the following call is legal:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00862.jpg" class="calibre252"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>In this case, the type arguments for the arguments passed to <span class="bold1">isSame( )</span> can be inferred from the parameters’ types. They don’t need to be specified again.</span></div>
<div class="calibre23"><span>Because the diamond operator was added by JDK 7 and won’t work with older compilers, the remaining examples of generics in this book will continue to use the full syntax when declaring instances of generic classes. This way, the examples will work with any Java compiler that supports generics. Using the full-length syntax also makes it very clear precisely what is being created, which is helpful when example code is shown. Of course, in your own code, the use of the type inference syntax will streamline your declarations.</span></div>
<div id="filepos1131699" class="calibre1"><span class="calibre10"><span><span class="bold1">Erasure</span></span></span></div>
<div class="calibre12"><span>Usually, it is not necessary for the programmer to know the details about how the Java compiler transforms your source code into object code. However, in the case of generics, some general understanding of the process is important because it explains why the generic features work as they do—and why their behavior is sometimes a bit surprising. For this reason, a brief discussion of how generics are implemented in Java is in order.</span></div>
<div class="calibre23"><span>An important constraint that governed the way generics were added to Java was the need for compatibility with previous versions of Java. Simply put: generic code had to be compatible with preexisting, nongeneric code. Thus, any changes to the syntax of the Java language, or to the JVM, had to avoid breaking older code. The way Java implements generics while satisfying this constraint is through the use of <span class="italic">erasure</span>.</span></div>
<div class="calibre23"><span>In general, here is how erasure works. When your Java code is compiled, all generic type information is removed (erased). This means replacing type parameters with their bound type, which is <span class="bold1">Object</span> if no explicit bound is specified, and then applying the appropriate casts (as determined by the type arguments) to maintain type compatibility with the types specified by the type arguments. The compiler also enforces this type compatibility. This approach to generics means that no type parameters exist at run time. They are simply a source-code mechanism.</span></div>
<div id="filepos1133449" class="calibre1"><span class="calibre10"><span><span class="bold1">Ambiguity Errors</span></span></span></div>
<div class="calibre12"><span>The inclusion of generics gives rise to a new type of error that you must guard against: <span class="italic">ambiguity</span>. Ambiguity errors occur when erasure causes two seemingly distinct generic declarations to resolve to the same erased type, causing a conflict. Here is an example that involves method overloading:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00863.jpg" class="calibre836"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Notice that <span class="bold1">MyGenClass</span> declares two generic types: <span class="bold1">T</span> and <span class="bold1">V</span>. Inside <span class="bold1">MyGenClass</span>, an attempt is made to overload <span class="bold1">set( )</span> based on parameters of type <span class="bold1">T</span> and <span class="bold1">V</span>. This looks reasonable because <span class="bold1">T</span> and <span class="bold1">V</span> appear to be different types. However, there are two ambiguity problems here.</span></div>
<div class="calibre23"><span>First, as <span class="bold1">MyGenClass</span> is written there is no requirement that <span class="bold1">T</span> and <span class="bold1">V</span> actually be different types. For example, it is perfectly correct (in principle) to construct a <span class="bold1">MyGenClass</span> object as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00864.jpg" class="calibre780"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>In this case, both <span class="bold1">T</span> and <span class="bold1">V</span> will be replaced by <span class="bold1">String</span>. This makes both versions of <span class="bold1">set( )</span> identical, which is, of course, an error.</span></div>
<div class="calibre23"><span>Second, and more fundamental, is that the type erasure of <span class="bold1">set( )</span> effectively reduces both versions to the following:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00865.jpg" class="calibre837"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Thus, the overloading of <span class="bold1">set( )</span> as attempted in <span class="bold1">MyGenClass</span> is inherently ambiguous. The solution in this case is to use two separate method names rather than trying to overload <span class="bold1">set( )</span>.</span></div>
<div id="filepos1135726" class="calibre1"><span class="calibre10"><span><span class="bold1">Some Generic Restrictions</span></span></span></div>
<div class="calibre12"><span>There are a few restrictions that you need to keep in mind when using generics. They involve creating objects of a type parameter, static members, exceptions, and arrays. Each is examined here.</span></div>
<div id="filepos1136110" class="calibre1"><span class="calibre10"><span><span class="bold1">Type Parameters Can’t Be Instantiated</span></span></span></div>
<div class="calibre12"><span>It is not possible to create an instance of a type parameter. For example, consider this class:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00866.jpg" class="calibre838"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, it is illegal to attempt to create an instance of <span class="bold1">T</span>. The reason should be easy to understand: the compiler has no way to know what type of object to create. <span class="bold1">T</span> is simply a placeholder.</span></div>
<div id="filepos1136816" class="calibre1"><span class="calibre10"><span><span class="bold1">Restrictions on Static Members</span></span></span></div>
<div class="calibre12"><span>No <span class="bold1">static</span> member can use a type parameter declared by the enclosing class. For example, both of the <span class="bold1">static</span> members of this class are illegal:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00867.jpg" class="calibre839"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Although you can’t declare <span class="bold1">static</span> members that use a type parameter declared by the enclosing class, you <span class="italic">can</span> declare <span class="bold1">static</span> generic methods, which define their own type parameters, as was done earlier in this chapter.</span></div>
<div id="filepos1137622" class="calibre1"><span class="calibre10"><span><span class="bold1">Generic Array Restrictions</span></span></span></div>
<div class="calibre12"><span>There are two important generics restrictions that apply to arrays. First, you cannot instantiate an array whose element type is a type parameter. Second, you cannot create an array of type-specific generic references. The following short program shows both situations:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00868.jpg" class="calibre612"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>As the program shows, it’s valid to declare a reference to an array of type <span class="bold1">T</span>, as this line does:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00869.jpg" class="calibre840"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>But, you cannot instantiate an array of <span class="bold1">T</span>, as this commented-out line attempts:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00870.jpg" class="calibre841"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The reason you can’t create an array of <span class="bold1">T</span> is that there is no way for the compiler to know what type of array to actually create. However, you can pass a reference to a type-compatible array to <span class="bold1">Gen( )</span> when an object is created and assign that reference to <span class="bold1">vals</span>, as the program does in this line:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00871.jpg" class="calibre128"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>This works because the array passed to <span class="bold1">Gen()</span> has a known type, which will be the same type as <span class="bold1">T</span> at the time of object creation. Inside <span class="bold1">main( )</span>, notice that you can’t declare an array of references to a specific generic type. That is, this line</span></div>
<div class="calibre1"><span><img alt="image" src="images/00872.jpg" class="calibre128"/></span></div><div class="calibre11"> </div>
<div class="calibre27"><span>won’t compile.</span></div>
<div id="filepos1139877" class="calibre1"><span class="calibre10"><span><span class="bold1">Generic Exception Restriction</span></span></span></div>
<div class="calibre12"><span>A generic class cannot extend <span class="bold1">Throwable</span>. This means that you cannot create generic exception classes.</span></div>
<div id="filepos1140181" class="calibre1"><span class="calibre10"><span><span class="bold1">Continuing Your Study of Generics</span></span></span></div>
<div class="calibre12"><span>As mentioned at the start, this chapter gives you sufficient knowledge to use generics effectively in your own programs. However, there are many side issues and special cases that are not covered here. Readers especially interested in generics will want to learn about how generics affect class hierarchies, run-time type comparisons, and overriding, for example. Discussions of these and other topics are found in my book <span class="italic">Java: The Complete Reference, Ninth Edition</span> (Oracle Press/McGraw-Hill Professional, 2014).</span></div>
<div id="filepos1140900" class="calibre44"><span class="calibre10"><span><img alt="image" src="images/00059.jpg" class="calibre104"/>   <span class="bold1"><span class="italic">Chapter 13 Self Test</span></span></span></span></div><div class="calibre11"> </div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1141181" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1567364">1</a>.</span>  Generics are important to Java because they enable the creation of code that is</span></div>
<div class="calibre9"><blockquote class="calibre66"><span><span class="bold1">A.</span> Type-safe</span></blockquote></div>
<div class="calibre9"><blockquote class="calibre66"><span><span class="bold1">B.</span> Reusable</span></blockquote></div>
<div class="calibre9"><blockquote class="calibre66"><span><span class="bold1">C.</span> Reliable</span></blockquote></div>
<div class="calibre9"><blockquote class="calibre66"><span><span class="bold1">D.</span> All of the above</span></blockquote></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1141910" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1568190">2</a>.</span>  Can a primitive type be used as a type argument?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1142127" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1568544">3</a>.</span>  Show how to declare a class called <span class="bold1">FlightSched</span> that takes two generic parameters.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1142384" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1569070">4</a>.</span>  Beginning with your answer to question 3, change <span class="bold1">FlightSched</span>’s second type parameter so that it must extend <span class="bold1">Thread</span>.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1142689" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1569644">5</a>.</span>  Now, change <span class="bold1">FlightSched</span> so that its second type parameter must be a subclass of its first type parameter.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1142970" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1570194">6</a>.</span>  As it relates to generics, what is the <span class="bold1">?</span> and what does it do?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1143207" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1570593">7</a>.</span>  Can the wildcard argument be bounded?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1143413" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1570952">8</a>.</span>  A generic method called <span class="bold1">MyGen( )</span> has one type parameter. Furthermore, <span class="bold1">MyGen( )</span> has one parameter whose type is that of the type parameter. It also returns an object of that type parameter. Show how to declare <span class="bold1">MyGen( )</span>.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1143821" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1571629">9</a>.</span>  Given this generic interface</span></div>
<div class="calibre31"><blockquote class="calibre66"><span><img alt="image" src="images/00873.jpg" class="calibre842"/></span></blockquote></div>
<div class="calibre21"><span>        show the declaration of a class called <span class="bold1">MyClass</span> that implements <span class="bold1">IGenIF</span>.</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1144395" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1572418">10</a>.</span>  Given a generic class called <span class="bold1">Counter&lt;T&gt;</span>, show how to create an object of its raw type.</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1144657" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1573061">11</a>.</span>  Do type parameters exist at run time?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1144849" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1573475">12</a>.</span>  Convert your solution to question 10 of the Self Test for <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_016.html#filepos764315">Chapter 9</a> so that it is generic. In the process, create a stack interface called <span class="bold1">IGenStack</span> that generically defines the operations <span class="bold1">push( )</span> and <span class="bold1">pop( )</span>.</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1145260" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1574517">13</a>.</span>  What is <span class="bold1">&lt; &gt;</span>?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1145448" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1574823">14</a>.</span>  How can the following be simplified?</span></div>
<div class="calibre31"><blockquote class="calibre66"><span><img alt="image" src="images/00874.jpg" class="calibre780"/></span></blockquote></div>  <div class="mbppagebreak" id="calibre_pb_20"></div>
</body></html>
