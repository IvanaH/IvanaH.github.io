<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Java&amp;#8482;: A Beginner&amp;#8217;s Guide Sixth Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="filepos823752" class="calibre29"><span><img alt="image" src="images/00003.jpg" class="calibre30"/></span></div><div class="calibre11"> </div>
<div class="calibre31"><span class="calibre2"><span><big class="calibre3"><big class="calibre4"><big class="calibre5"><big class="calibre6"><big class="calibre32"><big class="calibre4">Chapter 10</big></big></big></big></big></big></span></span></div>
<div class="calibre9"><span class="calibre2"><span>Using I/O</span></span></div><div class="calibre33"> </div>
<div class="calibre1"><span class="calibre10"><span><span class="bold1">Key Skills &amp; Concepts</span></span></span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Understand the stream</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Know the difference between byte and character streams</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Know Java’s byte stream classes</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Know Java’s character stream classes</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Know the predefined streams</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Use byte streams</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Use byte streams for file I/O</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Automatically close a file by using <span class="bold1">try</span>-with-resources</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Read and write binary data</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Use random-access files</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Use character streams</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Use character streams for file I/O</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Apply Java’s type wrappers to convert numeric strings</span></div>
<div class="calibre1"><span><img alt="image" src="images/00004.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre12"><span><span><span class="calibre2">S</span></span>ince the beginning of this book, you have been using parts of the Java I/O system, such as <span class="bold1">println( )</span>. However, you have been doing so without much formal explanation. Because the Java I/O system is based upon a hierarchy of classes, it was not possible to present its theory and details without first discussing classes, inheritance, and exceptions. Now it is time to examine Java’s approach to I/O in detail.</span></div>
<div class="calibre23"><span>Be forewarned, Java’s I/O system is quite large, containing many classes, interfaces, and methods. Part of the reason for its size is that Java defines two complete I/O systems: one for byte I/O and the other for character I/O. It won’t be possible to discuss every aspect of Java’s I/O here. (An entire book could easily be dedicated to Java’s I/O system!) This chapter will, however, introduce you to the most important and commonly used features. Fortunately, Java’s I/O system is cohesive and consistent; once you understand its fundamentals, the rest of the I/O system is easy to master.</span></div>
<div class="calibre23"><span>Before we begin, an important point needs to be made. The I/O classes described in this chapter support text-based console I/O and file I/O. They are not used to create graphical user interfaces (GUIs). Thus, you will not use them to create windowed applications, for example. However, Java <span class="italic">does</span> include substantial support for building graphical user interfaces. The basics of GUI programming are found in <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_022.html#filepos1225806">Chapter 15</a>, where applets are introduced; <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_023.html#filepos1300493">Chapter 16</a>, which offers an introduction to Swing; and <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_024.html#filepos1394297">Chapter 17</a>, which presents an overview of JavaFX. (Swing and JavaFX are two of Java’s GUI toolkits.)</span></div>
<div id="filepos829029" class="calibre1"><span class="calibre10"><span><span class="bold1">Java’s I/O Is Built upon Streams</span></span></span></div>
<div class="calibre12"><span>Java programs perform I/O through streams. An I/O stream is an abstraction that either produces or consumes information. A stream is linked to a physical device by the Java I/O system. All streams behave in the same manner, even if the actual physical devices they are linked to differ. Thus, the same I/O classes and methods can be applied to different types of devices. For example, the same methods that you use to write to the console can also be used to write to a disk file. Java implements I/O streams within class hierarchies defined in the <span class="bold1">java.io</span> package.</span></div>
<div id="filepos829806" class="calibre1"><span class="calibre10"><span><span class="bold1">Byte Streams and Character Streams</span></span></span></div>
<div class="calibre12"><span>Modern versions of Java define two types of I/O streams: byte and character. (The original version of Java defined only the byte stream, but character streams were quickly added.) Byte streams provide a convenient means for handling input and output of bytes. They are used, for example, when reading or writing binary data. They are especially helpful when working with files. Character streams are designed for handling the input and output of characters. They use Unicode and, therefore, can be internationalized. Also, in some cases, character streams are more efficient than byte streams.</span></div>
<div class="calibre23"><span>The fact that Java defines two different types of streams makes the I/O system quite large because two separate sets of class hierarchies (one for bytes, one for characters) are needed. The sheer number of I/O classes can make the I/O system appear more intimidating than it actually is. Just remember, for the most part, the functionality of byte streams is paralleled by that of the character streams.</span></div>
<div class="calibre23"><span>One other point: At the lowest level, all I/O is still byte-oriented. The character-based streams simply provide a convenient and efficient means for handling characters.</span></div>
<div id="filepos831320" class="calibre1"><span class="calibre10"><span><span class="bold1">The Byte Stream Classes</span></span></span></div>
<div class="calibre12"><span>Byte streams are defined by using two class hierarchies. At the top of these are two abstract classes: <span class="bold1">InputStream</span> and <span class="bold1">OutputStream</span>. <span class="bold1">InputStream</span> defines the characteristics common to byte input streams and <span class="bold1">OutputStream</span> describes the behavior of byte output streams.</span></div>
<div class="calibre23"><span>From <span class="bold1">InputStream</span> and <span class="bold1">OutputStream</span> are created several concrete subclasses that offer varying functionality and handle the details of reading and writing to various devices, such as disk files. The byte stream classes are shown in <a href="#filepos832293">Table 10-1</a>. Don’t be overwhelmed by the number of different classes. Once you can use one byte stream, the others are easy to master.</span></div>
<div class="calibre28">
<div id="filepos832293" class="calibre44"><span><img alt="image" src="images/00627.jpg" class="calibre637"/></span></div>
<div class="calibre9"><span><img alt="image" src="images/00057.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span><span class="bold1">Table 10-1</span>   The Byte Stream Classes</span></div><div class="calibre18"> </div>
</div>
<div id="filepos832697" class="calibre9"><span class="calibre10"><span><span class="bold1">The Character Stream Classes</span></span></span></div>
<div class="calibre12"><span>Character streams are defined by using two class hierarchies topped by these two abstract classes: <span class="bold1">Reader</span> and <span class="bold1">Writer</span>. <span class="bold1">Reader</span> is used for input, and <span class="bold1">Writer</span> is used for output. Concrete classes derived from <span class="bold1">Reader</span> and <span class="bold1">Writer</span> operate on Unicode character streams.</span></div>
<div class="calibre23"><span>From <span class="bold1">Reader</span> and <span class="bold1">Writer</span> are derived several concrete subclasses that handle various I/O situations. In general, the character-based classes parallel the byte-based classes. The character stream classes are shown in <a href="#filepos833539">Table 10-2</a>.</span></div>
<div class="calibre28">
<div id="filepos833539" class="calibre44"><span><img alt="image" src="images/00628.jpg" class="calibre379"/></span></div>
<div class="calibre9"><span><img alt="image" src="images/00057.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span><span class="bold1">Table 10-2</span>   The Character Stream I/O Classes</span></div><div class="calibre18"> </div>
</div>
<div id="filepos833952" class="calibre9"><span class="calibre10"><span><span class="bold1">The Predefined Streams</span></span></span></div>
<div class="calibre12"><span>As you know, all Java programs automatically import the <span class="bold1">java.lang</span> package. This package defines a class called <span class="bold1">System</span>, which encapsulates several aspects of the run-time environment. Among other things, it contains three predefined stream variables, called <span class="bold1">in</span>, <span class="bold1">out</span>, and <span class="bold1">err</span>. These fields are declared as <span class="bold1">public</span>, <span class="bold1">final</span>, and <span class="bold1">static</span> within <span class="bold1">System</span>. This means that they can be used by any other part of your program and without reference to a specific <span class="bold1">System</span> object.</span></div>
<div class="calibre23"><span><span class="bold1">System.out</span> refers to the standard output stream. By default, this is the console. <span class="bold1">System.in</span> refers to standard input, which is by default the keyboard. <span class="bold1">System.err</span> refers to the standard error stream, which is also the console by default. However, these streams can be redirected to any compatible I/O device.</span></div>
<div class="calibre23"><span><span class="bold1">System.in</span> is an object of type <span class="bold1">InputStream</span>; <span class="bold1">System.out</span> and <span class="bold1">System.err</span> are objects of type <span class="bold1">PrintStream</span>. These are byte streams, even though they are typically used to read and write characters from and to the console. The reason they are byte and not character streams is that the predefined streams were part of the original specification for Java, which did not include the character streams. As you will see, it is possible to wrap these within character-based streams if desired.</span></div>
<div id="filepos835666" class="calibre1"><span class="calibre10"><span><span class="bold1">Using the Byte Streams</span></span></span></div>
<div class="calibre12"><span>We will begin our examination of Java’s I/O with the byte streams. As explained, at the top of the byte stream hierarchy are the <span class="bold1">InputStream</span> and <span class="bold1">OutputStream</span> classes. <a href="#filepos836494">Table 10-3</a> shows the methods in <span class="bold1">InputStream</span>, and <a href="#filepos836922">Table 10-4</a> shows the methods in <span class="bold1">OutputStream</span>. In general, the methods in <span class="bold1">InputStream</span> and <span class="bold1">OutputStream</span> can throw an <span class="bold1">IOException</span> on error. The methods defined by these two abstract classes are available to all of their subclasses. Thus, they form a minimal set of I/O functions that all byte streams will have.</span></div>
<div class="calibre28">
<div id="filepos836494" class="calibre44"><span><img alt="image" src="images/00629.jpg" class="calibre600"/></span></div>
<div class="calibre9"><span><img alt="image" src="images/00057.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span><span class="bold1">Table 10-3</span>   The Methods Defined by <span class="bold1">InputStream</span></span></div><div class="calibre18"> </div>
</div>
<div class="calibre28">
<div id="filepos836922" class="calibre44"><span><img alt="image" src="images/00630.jpg" class="calibre203"/></span></div>
<div class="calibre9"><span><img alt="image" src="images/00057.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span><span class="bold1">Table 10-4</span>   The Methods Defined by <span class="bold1">OutputStream</span></span></div><div class="calibre18"> </div>
</div>
<div id="filepos837345" class="calibre9"><span class="calibre10"><span><span class="bold1">Reading Console Input</span></span></span></div>
<div class="calibre12"><span>Originally, the only way to perform console input was to use a byte stream, and much Java code still uses the byte streams exclusively. Today, you can use byte or character streams. For commercial code, the preferred method of reading console input is to use a character-oriented stream. Doing so makes your program easier to internationalize and easier to maintain.</span></div>
<div class="calibre12"><span>It is also more convenient to operate directly on characters rather than converting back and forth between characters and bytes. However, for sample programs, simple utility programs for your own use, and applications that deal with raw keyboard input, using the byte streams is acceptable. For this reason, console I/O using byte streams is examined here.</span></div>
<div class="calibre23"><span>Because <span class="bold1">System.in</span> is an instance of <span class="bold1">InputStream</span>, you automatically have access to the methods defined by <span class="bold1">InputStream</span>. Unfortunately, <span class="bold1">InputStream</span> defines only one input method, <span class="bold1">read( )</span>, which reads bytes. There are three versions of <span class="bold1">read( )</span>, which are shown here:</span></div>
<div class="calibre27"><span>int read( ) throws IOException</span></div>
<div class="calibre12"><span>int read(byte <span class="italic">data</span>[ ]) throws IOException</span></div>
<div class="calibre12"><span>int read(byte <span class="italic">data</span>[ ], int <span class="italic">start</span>, int <span class="italic">max</span>) throws IOException</span></div>
<div class="calibre592"><span>In <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_010.html#filepos313915">Chapter 3</a>, you saw how to use the first version of <span class="bold1">read( )</span> to read a single character from the keyboard (from <span class="bold1">System.in</span>). It returns –1 when the end of the stream is encountered. The second version reads bytes from the input stream and puts them into <span class="italic">data</span> until either the array is full, the end of stream is reached, or an error occurs. It returns the number of bytes read, or –1 when the end of the stream is encountered. The third version reads input into <span class="italic">data</span> beginning at the location specified by <span class="italic">start</span>. Up to <span class="italic">max</span> bytes are stored. It returns the number of bytes read, or –1 when the end of the stream is reached. All throw an <span class="bold1">IOException</span> when an error occurs. When reading from <span class="bold1">System.in</span>, pressing <small class="calibre16">ENTER</small> generates an end-of-stream condition.</span></div>
<div class="calibre23"><span>Here is a program that demonstrates reading an array of bytes from <span class="bold1">System.in</span>. Notice that any I/O exceptions that might be generated are simply thrown out of <span class="bold1">main( )</span>. Such an approach is common when reading from the console, but you can handle these types of errors yourself, if you choose.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00631.jpg" class="calibre638"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Here is a sample run:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00632.jpg" class="calibre639"/></span></div><div class="calibre11"> </div>
<div id="filepos840727" class="calibre1"><span class="calibre10"><span><span class="bold1">Writing Console Output</span></span></span></div>
<div class="calibre12"><span>As is the case with console input, Java originally provided only byte streams for console output. Java 1.1 added character streams. For the most portable code, character streams are recommended. Because <span class="bold1">System.out</span> is a byte stream, however, byte-based console output is still widely used. In fact, all of the programs in this book up to this point have used it! Thus, it is examined here.</span></div>
<div class="calibre23"><span>Console output is most easily accomplished with <span class="bold1">print( )</span> and <span class="bold1">println( )</span>, with which you are already familiar. These methods are defined by the class <span class="bold1">PrintStream</span> (which is the type of the object referenced by <span class="bold1">System.out</span>). Even though <span class="bold1">System.out</span> is a byte stream, it is still acceptable to use this stream for simple console output.</span></div>
<div class="calibre23"><span>Since <span class="bold1">PrintStream</span> is an output stream derived from <span class="bold1">OutputStream</span>, it also implements the low-level method <span class="bold1">write( )</span>. Thus, it is possible to write to the console by using <span class="bold1">write( )</span>. The simplest form of <span class="bold1">write( )</span> defined by <span class="bold1">PrintStream</span> is shown here:</span></div>
<div class="calibre27"><span>void write(int <span class="italic">byteval</span>)</span></div>
<div class="calibre27"><span>This method writes the byte specified by <span class="italic">byteval</span> to the file. Although <span class="italic">byteval</span> is declared as an integer, only the low-order 8 bits are written. Here is a short example that uses <span class="bold1">write( )</span> to output the character X followed by a new line:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00633.jpg" class="calibre640"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>You will not often use <span class="bold1">write( )</span> to perform console output (although it might be useful in some situations), since <span class="bold1">print( )</span> and <span class="bold1">println( )</span> are substantially easier to use.</span></div>
<div class="calibre23"><span><span class="bold1">PrintStream</span> supplies two additional output methods: <span class="bold1">printf( )</span> and <span class="bold1">format( )</span>. Both give you detailed control over the precise format of data that you output. For example, you can specify the number of decimal places displayed, a minimum field width, or the format of a negative value. Although we won’t be using these methods in the examples in this book, they are features that you will want to look into as you advance in your knowledge of Java.</span></div>
<div id="filepos843472" class="calibre1"><span class="calibre10"><span><span class="bold1">Reading and Writing Files Using Byte Streams</span></span></span></div>
<div class="calibre12"><span>Java provides a number of classes and methods that allow you to read and write files. Of course, the most common types of files are disk files. In Java, all files are byte-oriented, and Java provides methods to read and write bytes from and to a file. Thus, reading and writing files using byte streams is very common. However, Java allows you to wrap a byte-oriented file stream within a character-based object, which is shown later in this chapter.</span></div>
<div class="calibre23"><span>To create a byte stream linked to a file, use <span class="bold1">FileInputStream</span> or <span class="bold1">FileOutputStream</span>. To open a file, simply create an object of one of these classes, specifying the name of the file as an argument to the constructor. Once the file is open, you can read from or write to it.</span></div>
<div id="filepos844491" class="calibre1"><span class="calibre10"><span><span class="bold1">Inputting from a File</span></span></span></div>
<div class="calibre12"><span>A file is opened for input by creating a <span class="bold1">FileInputStream</span> object. Here is a commonly used constructor:</span></div>
<div class="calibre27"><span>FileInputStream(String <span class="italic">fileName</span>) throws FileNotFoundException</span></div>
<div class="calibre27"><span>Here, <span class="italic">fileName</span> specifies the name of the file you want to open. If the file does not exist, then <span class="bold1">FileNotFoundException</span> is thrown. <span class="bold1">FileNotFoundException</span> is a subclass of <span class="bold1">IOException</span>.</span></div>
<div class="calibre23"><span>To read from a file, you can use <span class="bold1">read( )</span>. The version that we will use is shown here:</span></div>
<div class="calibre27"><span>int read( ) throws IOException</span></div>
<div class="calibre27"><span>Each time it is called, <span class="bold1">read( )</span> reads a single byte from the file and returns it as an integer value. It returns –1 when the end of the file is encountered. It throws an <span class="bold1">IOException</span> when an error occurs. Thus, this version of <span class="bold1">read( )</span> is the same as the one used to read from the console.</span></div>
<div class="calibre23"><span>When you are done with a file, you must close it by calling <span class="bold1">close( )</span>. Its general form is shown here:</span></div>
<div class="calibre27"><span>void close( ) throws IOException</span></div>
<div class="calibre27"><span>Closing a file releases the system resources allocated to the file, allowing them to be used by another file. Failure to close a file can result in “memory leaks” because of unused resources remaining allocated.</span></div>
<div class="calibre23"><span>The following program uses <span class="bold1">read( )</span> to input and display the contents of a text file, the name of which is specified as a command-line argument. Notice how the <span class="bold1">try</span>/<span class="bold1">catch</span> blocks handle I/O errors that might occur.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00634.jpg" class="calibre641"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Notice that the preceding example closes the file stream after the <span class="bold1">try</span> block that reads the file has completed. Although this approach is occasionally useful, Java supports a variation that is often a better choice. The variation is to call <span class="bold1">close( )</span> within a <span class="bold1">finally</span> block. In this approach, all of the methods that access the file are contained within a <span class="bold1">try</span> block, and the <span class="bold1">finally</span> block is used to close the file. This way, no matter how the <span class="bold1">try</span> block terminates, the file is closed. Assuming the preceding example, here is how the <span class="bold1">try</span> block that reads the file can be recoded:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00635.jpg" class="calibre642"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>One advantage to this approach in general is that if the code that accesses a file terminates because of some non-I/O-related exception, the file is still closed by the <span class="bold1">finally</span> block. Although not an issue in this example (or most other example programs) because the program simply ends if an unexpected exception occurs, this can be a major source of trouble in larger programs. Using <span class="bold1">finally</span> avoids this trouble.</span></div>
<div class="calibre23"><span>Sometimes it’s easier to wrap the portions of a program that open the file and access the file within a single <span class="bold1">try</span> block (rather than separating the two), and then use a <span class="bold1">finally</span> block to close the file. For example, here is another way to write the <span class="bold1">ShowFile</span> program:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00636.jpg" class="calibre328"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>In this approach, notice that <span class="bold1">fin</span> is initialized to <span class="bold1">null</span>. Then, in the <span class="bold1">finally</span> block, the file is closed only if <span class="bold1">fin</span> is not <span class="bold1">null</span>. This works because <span class="bold1">fin</span> will be non-<span class="bold1">null</span> only if the file was successfully opened. Thus, <span class="bold1">close( )</span> will not be called if an exception occurs while opening the file.</span></div>
<div class="calibre23"><span>It is possible to make the <span class="bold1">try</span>/<span class="bold1">catch</span> sequence in the preceding example a bit more compact. Because <span class="bold1">FileNotFoundException</span> is a subclass of <span class="bold1">IOException</span>, it need not be caught separately. For example, this <span class="bold1">catch</span> clause could be used to catch both exceptions, eliminating the need to catch <span class="bold1">FileNotFoundException</span> separately. In this case, the standard exception message, which describes the error, is displayed.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00637.jpg" class="calibre643"/></span></div><div class="calibre11"> </div>
<div class="calibre29"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   I noticed that</span> read( ) <span class="bold1">returns –1 when the end of the file has been reached, but that it does not have a special return value for a file error. Why not?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   In Java, errors are handled by exceptions. Thus, if <span class="bold1">read( )</span>, or any other I/O method, returns a value, it means that no error has occurred. This is a much cleaner way than handling I/O errors by using special error codes.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre23"><span>In this approach, any error, including an error opening the file, will simply be handled by the single <span class="bold1">catch</span> statement. Because of its compactness, this approach is used by most of the I/O examples in this book. Be aware, however, that it will not be appropriate in cases in which you want to deal separately with a failure to open a file, such as might be caused if a user mistypes a file name. In such a situation, you might want to prompt for the correct name, for example, before entering a <span class="bold1">try</span> block that accesses the file.</span></div>
<div id="filepos851413" class="calibre1"><span class="calibre10"><span><span class="bold1">Writing to a File</span></span></span></div>
<div class="calibre12"><span>To open a file for output, create a <span class="bold1">FileOutputStream</span> object. Here are two commonly used constructors:</span></div>
<div class="calibre27"><span>FileOutputStream(String <span class="italic">fileName</span>) throws FileNotFoundException</span></div>
<div class="calibre12"><span>FileOutputStream(String <span class="italic">fileName</span>, boolean <span class="italic">append</span>)</span></div>
<div class="calibre12"><blockquote class="calibre66"><span>throws FileNotFoundException</span></blockquote></div>
<div class="calibre27"><span>If the file cannot be created, then <span class="bold1">FileNotFoundException</span> is thrown. In the first form, when an output file is opened, any preexisting file by the same name is destroyed. In the second form, if <span class="italic">append</span> is <span class="bold1">true</span>, then output is appended to the end of the file. Otherwise, the file is overwritten.</span></div>
<div class="calibre23"><span>To write to a file, you will use the <span class="bold1">write( )</span> method. Its simplest form is shown here:</span></div>
<div class="calibre27"><span>void write(int <span class="italic">byteval</span>) throws IOException</span></div>
<div class="calibre27"><span>This method writes the byte specified by <span class="italic">byteval</span> to the file. Although <span class="italic">byteval</span> is declared as an integer, only the low-order 8 bits are written to the file. If an error occurs during writing, an <span class="bold1">IOException</span> is thrown.</span></div>
<div class="calibre23"><span>Once you are done with an output file, you must close it using <span class="bold1">close( )</span>, shown here:</span></div>
<div class="calibre27"><span>void close( ) throws IOException</span></div>
<div class="calibre27"><span>Closing a file releases the system resources allocated to the file, allowing them to be used by another file. It also ensures that any output remaining in an output buffer is actually written to the physical device.</span></div>
<div class="calibre23"><span>The following example copies a text file. The names of the source and destination files are specified on the command line.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00638.jpg" class="calibre644"/></span></div><div class="calibre11"> </div>
<div id="filepos853897" class="calibre1"><span class="calibre10"><span><span class="bold1">Automatically Closing a File</span></span></span></div>
<div class="calibre12"><span>In the preceding section, the example programs have made explicit calls to <span class="bold1">close( )</span> to close a file once it is no longer needed. This is the way files have been closed since Java was first created. As a result, this approach is widespread in existing code. Furthermore, this approach is still valid and useful. However, beginning with JDK 7, Java has included a feature that offers another, more streamlined way to manage resources, such as file streams, by automating the closing process. It is based on another version of the <span class="bold1">try</span> statement called <span class="bold1"><span class="italic">try</span></span><span class="italic">-with-resources</span>, and is sometimes referred to as <span class="italic">automatic resource management</span>. The principal advantage of <span class="bold1">try</span>-with-resources is that it prevents situations in which a file (or other resource) is inadvertently not released after it is no longer needed. As explained, forgetting to close a file can result in memory leaks and could lead to other problems.</span></div>
<div class="calibre23"><span>The <span class="bold1">try</span>-with-resources statement has this general form:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00639.jpg" class="calibre645"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, <span class="italic">resource-specification</span> is a statement that declares and initializes a resource, such as a file. It consists of a variable declaration in which the variable is initialized with a reference to the object being managed. When the <span class="bold1">try</span> block ends, the resource is automatically released. In the case of a file, this means that the file is automatically closed. (Thus, there is no need to call <span class="bold1">close( )</span> explicitly.) A <span class="bold1">try</span>-with-resources statement can also include <span class="bold1">catch</span> and <span class="bold1">finally</span> clauses.</span></div>
<div class="calibre23"><span>The <span class="bold1">try</span>-with-resources statement can be used only with those resources that implement the <span class="bold1">AutoCloseable</span> interface defined by <span class="bold1">java.lang</span>. This interface defines the <span class="bold1">close( )</span> method. <span class="bold1">AutoCloseable</span> is inherited by the <span class="bold1">Closeable</span> interface defined in <span class="bold1">java.io</span>. Both interfaces are implemented by the stream classes, including <span class="bold1">FileInputStream</span> and <span class="bold1">FileOutputStream</span>. Thus, <span class="bold1">try</span>-with-resources can be used when working with streams, including file streams.</span></div>
<div class="calibre23"><span>As a first example of automatically closing a file, here is a reworked version of the <span class="bold1">ShowFile</span> program that uses it:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00640.jpg" class="calibre646"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>In the program, pay special attention to how the file is opened within the <span class="bold1">try</span>-with-resources statement:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00641.jpg" class="calibre647"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Notice how the resource-specification portion of the <span class="bold1">try</span> declares a <span class="bold1">FileInputStream</span> called <span class="bold1">fin</span>, which is then assigned a reference to the file opened by its constructor. Thus, in this version of the program the variable <span class="bold1">fin</span> is local to the <span class="bold1">try</span> block, being created when the <span class="bold1">try</span> is entered. When the <span class="bold1">try</span> is exited, the file associated with <span class="bold1">fin</span> is automatically closed by an implicit call to <span class="bold1">close( )</span>. You don’t need to call <span class="bold1">close( )</span> explicitly, which means that you can’t forget to close the file. This is a key advantage of automatic resource management.</span></div>
<div class="calibre23"><span>It is important to understand that the resource declared in the <span class="bold1">try</span> statement is implicitly <span class="bold1">final</span>. This means that you can’t assign to the resource after it has been created. Also, the scope of the resource is limited to the <span class="bold1">try</span>-with-resources statement.</span></div>
<div class="calibre23"><span>You can manage more than one resource within a single <span class="bold1">try</span> statement. To do so, simply separate each resource specification with a semicolon. The following program shows an example. It reworks the <span class="bold1">CopyFile</span> program shown earlier so that it uses a single <span class="bold1">try</span>-with-resources statement to manage both <span class="bold1">fin</span> and <span class="bold1">fout</span>.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00642.jpg" class="calibre648"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>In this program, notice how the input and output files are opened within the <span class="bold1">try</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00643.jpg" class="calibre649"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>After this <span class="bold1">try</span> block ends, both <span class="bold1">fin</span> and <span class="bold1">fout</span> will have been closed. If you compare this version of the program to the previous version, you will see that it is much shorter. The ability to streamline source code is a side-benefit of <span class="bold1">try</span>-with-resources.</span></div>
<div class="calibre23"><span>There is one other aspect to <span class="bold1">try</span>-with-resources that needs to be mentioned. In general, when a <span class="bold1">try</span> block executes, it is possible that an exception inside the <span class="bold1">try</span> block will lead to another exception that occurs when the resource is closed in a <span class="bold1">finally</span> clause. In the case of a “normal” <span class="bold1">try</span> statement, the original exception is lost, being preempted by the second exception. However, with a <span class="bold1">try</span>-with-resources statement, the second exception is <span class="italic">suppressed</span>. It is not, however, lost. Instead, it is added to the list of suppressed exceptions associated with the first exception. The list of suppressed exceptions can be obtained by use of the <span class="bold1">getSuppressed( )</span> method defined by <span class="bold1">Throwable</span>.</span></div>
<div class="calibre23"><span>Because of its advantages, <span class="bold1">try</span>-with-resources will be used by the remaining examples in this chapter. However, it is still very important that you are familiar with the traditional approach shown earlier in which <span class="bold1">close( )</span> is called explicitly. There are several reasons for this. First, there is legacy code that still relies on the traditional approach. It is important that all Java programmers be fully versed in and comfortable with the traditional approach when maintaining or updating this older code. Second, for a period of time, you might need to work in an environment that predates JDK 7. In such a situation, the <span class="bold1">try</span>-with-resources statement will not be available and the traditional approach must be employed. Finally, there may be cases in which explicitly closing a resource is more appropriate than the automated approach. The foregoing notwithstanding, if you are using JDK 7, JDK 8, or later, then you will usually want to use the new, automated approach to resource management. It offers a streamlined, robust alternative to the traditional approach.</span></div>
<div id="filepos861385" class="calibre1"><span class="calibre10"><span><span class="bold1">Reading and Writing Binary Data</span></span></span></div>
<div class="calibre12"><span>So far, we have just been reading and writing bytes containing ASCII characters, but it is possible—indeed, common—to read and write other types of data. For example, you might want to create a file that contains <span class="bold1">int</span>s, <span class="bold1">double</span>s, or <span class="bold1">short</span>s. To read and write binary values of the Java primitive types, you will use <span class="bold1">DataInputStream</span> and <span class="bold1">DataOutputStream</span>.</span></div>
<div class="calibre23"><span><span class="bold1">DataOutputStream</span> implements the <span class="bold1">DataOutput</span> interface. This interface defines methods that write all of Java’s primitive types to a file. It is important to understand that this data is written using its internal, binary format, not its human-readable text form. Several commonly used output methods for Java’s primitive types are shown in <a href="#filepos862512">Table 10-5</a>. Each throws an <span class="bold1">IOException</span> on failure.</span></div>
<div class="calibre28">
<div id="filepos862512" class="calibre44"><span><img alt="image" src="images/00644.jpg" class="calibre650"/></span></div>
<div class="calibre9"><span><img alt="image" src="images/00057.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span><span class="bold1">Table 10-5</span>   Commonly Used Output Methods Defined by <span class="bold1">DataOutputStream</span></span></div><div class="calibre18"> </div>
</div>
<div class="calibre23"><span>Here is the constructor for <span class="bold1">DataOutputStream</span>. Notice that it is built upon an instance of <span class="bold1">OutputStream</span>.</span></div>
<div class="calibre27"><span>DataOutputStream(OutputStream <span class="italic">outputStream</span>)</span></div>
<div class="calibre27"><span>Here, <span class="italic">outputStream</span> is the stream to which data is written. To write output to a file, you can use the object created by <span class="bold1">FileOutputStream</span> for this parameter.</span></div>
<div class="calibre23"><span><span class="bold1">DataInputStream</span> implements the <span class="bold1">DataInput</span> interface, which provides methods for reading all of Java’s primitive types. These methods are shown in <a href="#filepos864118">Table 10-6</a>, and each can throw an <span class="bold1">IOException</span>. <span class="bold1">DataInputStream</span> uses an <span class="bold1">InputStream</span> instance as its foundation, overlaying it with methods that read the various Java data types. Remember that <span class="bold1">DataInputStream</span> reads data in its binary format, not its human-readable form. The constructor for <span class="bold1">DataInputStream</span> is shown here:</span></div>
<div class="calibre28">
<div id="filepos864118" class="calibre44"><span><img alt="image" src="images/00645.jpg" class="calibre650"/></span></div>
<div class="calibre9"><span><img alt="image" src="images/00057.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span><span class="bold1">Table 10-6</span>   Commonly Used Input Methods Defined by <span class="bold1">DataInputStream</span></span></div><div class="calibre18"> </div>
</div>
<div class="calibre12"><span>DataInputStream(InputStream <span class="italic">inputStream</span>)</span></div>
<div class="calibre27"><span>Here, <span class="italic">inputStream</span> is the stream that is linked to the instance of <span class="bold1">DataInputStream</span> being created. To read input from a file, you can use the object created by <span class="bold1">FileInputStream</span> for this parameter.</span></div>
<div class="calibre23"><span>Here is a program that demonstrates <span class="bold1">DataOutputStream</span> and <span class="bold1">DataInputStream</span>. It writes and then reads back various types of data to and from a file.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00646.jpg" class="calibre651"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00647.jpg" class="calibre652"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The output from the program is shown here.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00648.jpg" class="calibre653"/></span></div><div class="calibre11"> </div>
<div class="calibre11"> </div><table cellspacing="0" cellpadding="0" class="calibre37">
<colgroup class="calibre38">
<col class="calibre72"/>
<col class="calibre73"/>
</colgroup>
<tr class="calibre41">
<td valign="top" id="filepos865854" class="calibre74"><span class="calibre10"><span class="bold1">Try This 10-1</span> </span></td>
<td valign="top" class="calibre75"><span class="calibre10">A File Comparison Utility</span></td>
</tr></table><div class="calibre43"> </div>
<div class="calibre1"><span><img alt="image" src="images/00649.jpg" class="calibre654"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>This project develops a simple, yet useful file comparison utility. It works by opening both files to be compared and then reading and comparing each corresponding set of bytes. If a mismatch is found, the files differ. If the end of each file is reached at the same time and if no mismatches have been found, then the files are the same. Notice that it uses a <span class="bold1">try</span>-with-resources statement to automatically close the files.</span></div>
<div class="calibre19"><span>  <span class="bold1">1.</span>  Create a file called <span class="bold1">CompFiles.java</span>.</span></div>
<div class="calibre47"><span>  <span class="bold1">2.</span>  Into <span class="bold1">CompFiles.java</span>, add the following program:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00650.jpg" class="calibre655"/></span></div>
<div class="calibre47"><span>  <span class="bold1">3.</span>  To try <span class="bold1">CompFiles</span>, first copy <span class="bold1">CompFiles.java</span> to a file called <span class="bold1">temp</span>. Then, try this command line:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00651.jpg" class="calibre656"/></span></div>
<div class="calibre47"><span>        The program will report that the files are the same. Next, compare <span class="bold1">CompFiles.java</span> to <span class="bold1">CopyFile.java</span> (shown earlier) using this command line:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00652.jpg" class="calibre657"/></span></div>
<div class="calibre47"><span>        These files differ and <span class="bold1">CompFiles</span> will report this fact.</span></div>
<div class="calibre47"><span>  <span class="bold1">4.</span>  On your own, try enhancing <span class="bold1">CompFiles</span> with various options. For example, add an option that ignores the case of letters. Another idea is to have <span class="bold1">CompFiles</span> display the position within the file where the files differ.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos868986" class="calibre9"><span class="calibre10"><span><span class="bold1">Random-Access Files</span></span></span></div>
<div class="calibre12"><span>Up to this point, we have been using <span class="italic">sequential files</span>, which are files that are accessed in a strictly linear fashion, one byte after another. However, Java also allows you to access the contents of a file in random order. To do this, you will use <span class="bold1">RandomAccessFile</span>, which encapsulates a random-access file. <span class="bold1">RandomAccessFile</span> is not derived from <span class="bold1">InputStream</span> or <span class="bold1">OutputStream</span>. Instead, it implements the interfaces <span class="bold1">DataInput</span> and <span class="bold1">DataOutput</span>, which define the basic I/O methods. It also supports positioning requests—that is, you can position the <span class="italic">file pointer</span> within the file. The constructor that we will be using is shown here:</span></div>
<div class="calibre27"><span>RandomAccessFile(String <span class="italic">fileName</span>, String <span class="italic">access</span>)</span></div>
<div class="calibre12"><blockquote class="calibre66"><span>throws FileNotFoundException</span></blockquote></div>
<div class="calibre27"><span>Here, the name of the file is passed in <span class="italic">fileName</span> and <span class="italic">access</span> determines what type of file access is permitted. If it is "r", the file can be read but not written. If it is "rw", the file is opened in read-write mode.</span></div>
<div class="calibre23"><span>The method <span class="bold1">seek( )</span>, shown here, is used to set the current position of the file pointer within the file:</span></div>
<div class="calibre27"><span>void seek(long <span class="italic">newPos</span>) throws IOException</span></div>
<div class="calibre27"><span>Here, <span class="italic">newPos</span> specifies the new position, in bytes, of the file pointer from the beginning of the file. After a call to <span class="bold1">seek( )</span>, the next read or write operation will occur at the new file position.</span></div>
<div class="calibre23"><span><span class="bold1">RandomAccessFile</span> implements the <span class="bold1">read( )</span> and <span class="bold1">write( )</span> methods. It also implements the <span class="bold1">DataInput</span> and <span class="bold1">DataOuput</span> interfaces, which means that methods to read and write the primitive types, such as <span class="bold1">readInt( )</span> and <span class="bold1">writeDouble( )</span>, are available.</span></div>
<div class="calibre23"><span>Here is an example that demonstrates random-access I/O. It writes six <span class="bold1">double</span>s to a file and then reads them back in nonsequential order.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00653.jpg" class="calibre658"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>The output from the program is shown here.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00654.jpg" class="calibre659"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Notice how each value is located. Since each <span class="bold1">double</span> value is 8 bytes long, each value starts on an 8-byte boundary. Thus, the first value is located at zero, the second begins at byte 8, the third starts at byte 16, and so on. Thus, to read the fourth value, the program seeks to location 24.</span></div>
<div class="calibre35"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   In looking through the documentation provided by the JDK, I noticed a class called</span> Console. <span class="bold1">Is this a class that I can use to perform console-based I/O?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   The short answer is Yes. The <span class="bold1">Console</span> class was added by JDK 6, and it is used to read from and write to the console. <span class="bold1">Console</span> is primarily a convenience class because most of its functionality is available through <span class="bold1">System.in</span> and <span class="bold1">System.out</span>. However, its use can simplify some types of console interactions, especially when reading strings from the console.</span></div>
<div class="calibre624"><span><span class="bold1">Console</span> supplies no constructors. Instead, a <span class="bold1">Console</span> object is obtained by calling <span class="bold1">System.console( )</span>. It is shown here.</span></div>
<div class="calibre1"><span>static Console console( )</span></div>
<div class="calibre1"><span>If a console is available, then a reference to it is returned. Otherwise, <span class="bold1">null</span> is returned. A console may not be available in all cases, such as when a program runs as a background task. Therefore, if <span class="bold1">null</span> is returned, no console I/O is possible.</span></div>
<div class="calibre624"><span><span class="bold1">Console</span> defines several methods that perform I/O, such as <span class="bold1">readLine( )</span> and <span class="bold1">printf( )</span>. It also defines a method called <span class="bold1">readPassword( )</span>, which can be used to obtain a password. It lets your application read a password without echoing what is typed. You can also obtain a reference to the <span class="bold1">Reader</span> and the <span class="bold1">Writer</span> that are attached to the console. In general, <span class="bold1">Console</span> is a class that you may find useful for some types of applications.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos874756" class="calibre9"><span class="calibre10"><span><span class="bold1">Using Java’s Character-Based Streams</span></span></span></div>
<div class="calibre12"><span>As the preceding sections have shown, Java’s byte streams are both powerful and flexible. However, they are not the ideal way to handle character-based I/O. For this purpose, Java defines the character stream classes. At the top of the character stream hierarchy are the abstract classes <span class="bold1">Reader</span> and <span class="bold1">Writer</span>. <a href="#filepos875689">Table 10-7</a> shows the methods in <span class="bold1">Reader</span>, and <a href="#filepos876112">Table 10-8</a> shows the methods in <span class="bold1">Writer</span>. Most of the methods can throw an <span class="bold1">IOException</span> on error. The methods defined by these two abstract classes are available to all of their subclasses. Thus, they form a minimal set of I/O functions that all character streams will have.</span></div>
<div class="calibre28">
<div id="filepos875689" class="calibre44"><span><img alt="image" src="images/00655.jpg" class="calibre141"/></span></div>
<div class="calibre9"><span><img alt="image" src="images/00057.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span><span class="bold1">Table 10-7</span>   The Methods Defined by <span class="bold1">Reader</span></span></div><div class="calibre18"> </div>
</div>
<div class="calibre28">
<div id="filepos876112" class="calibre44"><span><img alt="image" src="images/00656.jpg" class="calibre431"/></span></div>
<div class="calibre9"><span><img alt="image" src="images/00057.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span><span class="bold1">Table 10-8</span>   The Methods Defined by <span class="bold1">Writer</span></span></div><div class="calibre18"> </div>
</div>
<div id="filepos876529" class="calibre9"><span class="calibre10"><span><span class="bold1">Console Input Using Character Streams</span></span></span></div>
<div class="calibre12"><span>For code that will be internationalized, inputting from the console using Java’s character-based streams is a better, more convenient way to read characters from the keyboard than is using the byte streams. However, since <span class="bold1">System.in</span> is a byte stream, you will need to wrap <span class="bold1">System.in</span> inside some type of <span class="bold1">Reader</span>. The best class for reading console input is <span class="bold1">BufferedReader</span>, which supports a buffered input stream. However, you cannot construct a <span class="bold1">BufferedReader</span> directly from <span class="bold1">System.in</span>. Instead, you must first convert it into a character stream. To do this, you will use <span class="bold1">InputStreamReader</span>, which converts bytes to characters. To obtain an <span class="bold1">InputStreamReader</span> object that is linked to <span class="bold1">System.in</span>, use the constructor shown next:</span></div>
<div class="calibre27"><span>InputStreamReader(InputStream <span class="italic">inputStream</span>)</span></div>
<div class="calibre27"><span>Since <span class="bold1">System.in</span> refers to an object of type <span class="bold1">InputStream</span>, it can be used for <span class="italic">inputStream</span>.</span></div>
<div class="calibre23"><span>Next, using the object produced by <span class="bold1">InputStreamReader</span>, construct a <span class="bold1">BufferedReader</span> using the constructor shown here:</span></div>
<div class="calibre27"><span>BufferedReader(Reader <span class="italic">inputReader</span>)</span></div>
<div class="calibre27"><span>Here, <span class="italic">inputReader</span> is the stream that is linked to the instance of <span class="bold1">BufferedReader</span> being created. Putting it all together, the following line of code creates a <span class="bold1">BufferedReader</span> that is connected to the keyboard.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00657.jpg" class="calibre660"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>After this statement executes, <span class="bold1">br</span> will be a character-based stream that is linked to the console through <span class="bold1">System.in</span>.</span></div>
<div class="calibre1"><span><span class="bold1">Reading Characters</span></span></div>
<div class="calibre12"><span>Characters can be read from <span class="bold1">System.in</span> using the <span class="bold1">read( )</span> method defined by <span class="bold1">BufferedReader</span> in much the same way as they were read using byte streams. Here are three versions of <span class="bold1">read( )</span> supported by <span class="bold1">BufferedReader</span>.</span></div>
<div class="calibre27"><span>int read( ) throws IOException</span></div>
<div class="calibre12"><span>int read(char <span class="italic">data</span>[ ]) throws IOException</span></div>
<div class="calibre12"><span>int read(char <span class="italic">data</span>[ ], int start, int <span class="italic">max</span>) throws IOException</span></div>
<div class="calibre592"><span>The first version of <span class="bold1">read( )</span> reads a single Unicode character. It returns –1 when the end of the stream is reached. The second version reads characters from the input stream and puts them into <span class="italic">data</span> until either the array is full, the end of stream is reached, or an error occurs. It returns the number of characters read or –1 at the end of the stream. The third version reads input into <span class="italic">data</span> beginning at the location specified by <span class="italic">start</span>. Up to <span class="italic">max</span> characters are stored. It returns the number of characters read or –1 when the end of the stream is encountered. All throw an <span class="bold1">IOException</span> on error. When reading from <span class="bold1">System.in</span>, pressing <small class="calibre16">ENTER</small> generates an end-of-stream condition.</span></div>
<div class="calibre23"><span>The following program demonstrates <span class="bold1">read( )</span> by reading characters from the console until the user types a period. Notice that any I/O exceptions that might be generated are simply thrown out of <span class="bold1">main( )</span>. As mentioned earlier in this chapter, such an approach is common when reading from the console. Of course, you can handle these types of errors under program control, if you choose.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00658.jpg" class="calibre661"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Here is a sample run:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00659.jpg" class="calibre662"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><span class="bold1">Reading Strings</span></span></div>
<div class="calibre12"><span>To read a string from the keyboard, use the version of <span class="bold1">readLine( )</span> that is a member of the <span class="bold1">BufferedReader</span> class. Its general form is shown here:</span></div>
<div class="calibre27"><span>String readLine( ) throws IOException</span></div>
<div class="calibre27"><span>It returns a <span class="bold1">String</span> object that contains the characters read. It returns <span class="bold1">null</span> if an attempt is made to read when at the end of the stream.</span></div>
<div class="calibre23"><span>The following program demonstrates <span class="bold1">BufferedReader</span> and the <span class="bold1">readLine( )</span> method. The program reads and displays lines of text until you enter the word “stop”.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00660.jpg" class="calibre663"/></span></div><div class="calibre11"> </div>
<div id="filepos882167" class="calibre1"><span class="calibre10"><span><span class="bold1">Console Output Using Character Streams</span></span></span></div>
<div class="calibre12"><span>While it is still permissible to use <span class="bold1">System.out</span> to write to the console under Java, its use is recommended mostly for debugging purposes or for sample programs such as those found in this book. For real-world programs, the preferred method of writing to the console when using Java is through a <span class="bold1">PrintWriter</span> stream. <span class="bold1">PrintWriter</span> is one of the character-based classes. As explained, using a character-based class for console output makes it easier to internationalize your program.</span></div>
<div class="calibre23"><span><span class="bold1">PrintWriter</span> defines several constructors. The one we will use is shown here:</span></div>
<div class="calibre27"><span>PrintWriter(OutputStream <span class="italic">outputStream</span>, boolean <span class="italic">flushingOn</span>)</span></div>
<div class="calibre27"><span>Here, <span class="italic">outputStream</span> is an object of type <span class="bold1">OutputStream</span> and <span class="italic">flushingOn</span> controls whether Java flushes the output stream every time a <span class="bold1">println( )</span> method (among others) is called. If <span class="italic">flushingOn</span> is <span class="bold1">true</span>, flushing automatically takes place. If <span class="bold1">false</span>, flushing is not automatic.</span></div>
<div class="calibre23"><span><span class="bold1">PrintWriter</span> supports the <span class="bold1">print( )</span> and <span class="bold1">println( )</span> methods for all types including <span class="bold1">Object</span>. Thus, you can use these methods in just the same way as they have been used with <span class="bold1">System.out</span>. If an argument is not a primitive type, the <span class="bold1">PrintWriter</span> methods will call the object’s <span class="bold1">toString( )</span> method and then print out the result.</span></div>
<div class="calibre23"><span>To write to the console using a <span class="bold1">PrintWriter</span>, specify <span class="bold1">System.out</span> for the output stream and flush the stream after each call to <span class="bold1">println( )</span>. For example, this line of code creates a <span class="bold1">PrintWriter</span> that is connected to console output.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00661.jpg" class="calibre664"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>The following application illustrates using a <span class="bold1">PrintWriter</span> to handle console output.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00662.jpg" class="calibre665"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>The output from this program is</span></div>
<div class="calibre1"><span><img alt="image" src="images/00663.jpg" class="calibre666"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Remember that there is nothing wrong with using <span class="bold1">System.out</span> to write simple text output to the console when you are learning Java or debugging your programs. However, using a <span class="bold1">PrintWriter</span> will make your real-world applications easier to internationalize. Since no advantage is to be gained by using a <span class="bold1">PrintWriter</span> in the sample programs shown in this book, for convenience we will continue to use <span class="bold1">System.out</span> to write to the console.</span></div>
<div id="filepos885521" class="calibre1"><span class="calibre10"><span><span class="bold1">File I/O Using Character Streams</span></span></span></div>
<div class="calibre12"><span>Although byte-oriented file handling is the most common, it is possible to use character-based streams for this purpose. The advantage to the character streams is that they operate directly on Unicode characters. Thus, if you want to store Unicode text, the character streams are certainly your best option. In general, to perform character-based file I/O, you will use the <span class="bold1">FileReader</span> and <span class="bold1">FileWriter</span> classes.</span></div>
<div id="filepos886141" class="calibre1"><span class="calibre10"><span><span class="bold1">Using a FileWriter</span></span></span></div>
<div class="calibre12"><span><span class="bold1">FileWriter</span> creates a <span class="bold1">Writer</span> that you can use to write to a file. Two commonly used constructors are shown here:</span></div>
<div class="calibre27"><span>FileWriter(String <span class="italic">fileName</span>) throws IOException</span></div>
<div class="calibre12"><span>FileWriter(String <span class="italic">fileName</span>, boolean <span class="italic">append</span>) throws IOException</span></div>
<div class="calibre27"><span>Here, <span class="italic">fileName</span> is the full path name of a file. If <span class="italic">append</span> is <span class="bold1">true</span>, then output is appended to the end of the file. Otherwise, the file is overwritten. Either throws an <span class="bold1">IOException</span> on failure. <span class="bold1">FileWriter</span> is derived from <span class="bold1">OutputStreamWriter</span> and <span class="bold1">Writer</span>. Thus, it has access to the methods defined by these classes.</span></div>
<div class="calibre23"><span>Here is a simple key-to-disk utility that reads lines of text entered at the keyboard and writes them to a file called "test.txt". Text is read until the user enters the word "stop". It uses a <span class="bold1">FileWriter</span> to output to the file.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00664.jpg" class="calibre232"/></span></div><div class="calibre11"> </div>
<div id="filepos887595" class="calibre1"><span class="calibre10"><span><span class="bold1">Using a FileReader</span></span></span></div>
<div class="calibre12"><span>The <span class="bold1">FileReader</span> class creates a <span class="bold1">Reader</span> that you can use to read the contents of a file. A commonly used constructor is shown here:</span></div>
<div class="calibre27"><span>FileReader(String <span class="italic">fileName</span>) throws FileNotFoundException</span></div>
<div class="calibre27"><span>Here, <span class="italic">fileName</span> is the full path name of a file. It throws a <span class="bold1">FileNotFoundException</span> if the file does not exist. <span class="bold1">FileReader</span> is derived from <span class="bold1">InputStreamReader</span> and <span class="bold1">Reader</span>. Thus, it has access to the methods defined by these classes.</span></div>
<div class="calibre23"><span>The following program creates a simple disk-to-screen utility that reads a text file called "test.txt" and displays its contents on the screen. Thus, it is the complement of the key-to-disk utility shown in the previous section.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00665.jpg" class="calibre667"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>In this example, notice that the <span class="bold1">FileReader</span> is wrapped in a <span class="bold1">BufferedReader</span>. This gives it access to <span class="bold1">readLine( )</span>. Also, closing the <span class="bold1">BufferedReader</span>, <span class="bold1">br</span> in this case, automatically closes the file.</span></div>
<div class="calibre35"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   I have heard about another I/O package called NIO. Can you tell me about it?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   Originally called <span class="italic">New I/O</span>, NIO was added to Java by JDK 1.4. It supports a channel-based approach to I/O operations. The NIO classes are contained in <span class="bold1">java.nio</span> and its subordinate packages, such as <span class="bold1">java.nio.channels</span> and <span class="bold1">java.nio.charset</span>.</span></div>
<div class="calibre624"><span>NIO is built on two foundational items: <span class="italic">buffers</span> and <span class="italic">channels</span>. A buffer holds data. A channel represents an open connection to an I/O device, such as a file or a socket. In general, to use the new I/O system, you obtain a channel to an I/O device and a buffer to hold data. You then operate on the buffer, inputting or outputting data as needed.</span></div>
<div class="calibre624"><span>Two other entities used by NIO are charsets and selectors. A <span class="italic">charset</span> defines the way that bytes are mapped to characters. You can encode a sequence of characters into bytes using an <span class="italic">encoder</span>. You can decode a sequence of bytes into characters using a <span class="italic">decoder</span>. A <span class="italic">selector</span> supports key-based, non-blocking, multiplexed I/O. In other words, selectors enable you to perform I/O through multiple channels. Selectors are most applicable to socket-backed channels.</span></div>
<div class="calibre624"><span>Beginning with JDK 7, NIO was substantially enhanced, so much so that the term <span class="italic">NIO.2</span> is often used. The improvements included three new packages (<span class="bold1">java.nio.file</span>, <span class="bold1">java.nio.file.attribute</span>, and <span class="bold1">java.nio.file.spi</span>); several new classes, interfaces, and methods; and direct support for stream-based I/O. The additions greatly expanded the ways in which NIO can be used, especially with files.</span></div>
<div class="calibre624"><span>It is important to understand that NIO does not replace the I/O classes found in <span class="bold1">java.io</span>, which are discussed in this chapter. Instead, the NIO classes are designed to supplement the standard I/O system, offering an alternative approach, which can be beneficial in some circumstances.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos892041" class="calibre9"><span class="calibre10"><span><span class="bold1">Using Java’s Type Wrappers to Convert Numeric Strings</span></span></span></div>
<div class="calibre12"><span>Before leaving the topic of I/O, we will examine a technique useful when reading numeric strings. As you know, Java’s <span class="bold1">println( )</span> method provides a convenient way to output various types of data to the console, including numeric values of the built-in types, such as <span class="bold1">int</span> and <span class="bold1">double</span>. Thus, <span class="bold1">println( )</span> automatically converts numeric values into their human-readable form. However, methods like <span class="bold1">read( )</span> do not provide a parallel functionality that reads and converts a string containing a numeric value into its internal, binary format. For example, there is no version of <span class="bold1">read( )</span> that reads a string such as "100" and then automatically converts it into its corresponding binary value that is able to be stored in an <span class="bold1">int</span> variable. Instead, Java provides various other ways to accomplish this task. Perhaps the easiest is to use one of Java’s <span class="italic">type wrappers</span>.</span></div>
<div class="calibre23"><span>Java’s type wrappers are classes that encapsulate, or <span class="italic">wrap</span>, the primitive types. Type wrappers are needed because the primitive types are not objects. This limits their use to some extent. For example, a primitive type cannot be passed by reference. To address this kind of need, Java provides classes that correspond to each of the primitive types.</span></div>
<div class="calibre23"><span>The type wrappers are <span class="bold1">Double</span>, <span class="bold1">Float</span>, <span class="bold1">Long</span>, <span class="bold1">Integer</span>, <span class="bold1">Short</span>, <span class="bold1">Byte</span>, <span class="bold1">Character</span>, and <span class="bold1">Boolean</span>. These classes offer a wide array of methods that allow you to fully integrate the primitive types into Java’s object hierarchy. As a side benefit, the numeric wrappers also define methods that convert a numeric string into its corresponding binary equivalent. Several of these conversion methods are shown here. Each returns a binary value that corresponds to the string.</span></div>
<div class="calibre11"> </div><table border="1" cellpadding="3" cellspacing="0" class="calibre37">
<colgroup class="calibre38">
<col class="calibre72"/>
<col class="calibre73"/>
</colgroup>
<tr class="calibre41">
<td valign="top" class="calibre83"><span class="bold1">Wrapper</span>    </td>
<td valign="top" class="calibre83"><span class="bold1">Conversion Method</span></td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">Double            </td>
<td valign="top" class="calibre42">static double parseDouble(String <span class="italic">str</span>) throws NumberFormatException</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">Float</td>
<td valign="top" class="calibre42">static float parseFloat(String <span class="italic">str</span>) throws NumberFormatException</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">Long</td>
<td valign="top" class="calibre42">static long parseLong(String <span class="italic">str</span>) throws NumberFormatException</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">Integer</td>
<td valign="top" class="calibre42">static int parseInt(String <span class="italic">str</span>) throws NumberFormatException</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">Short</td>
<td valign="top" class="calibre42">static short parseShort(String <span class="italic">str</span>) throws NumberFormatException</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">Byte</td>
<td valign="top" class="calibre42">static byte parseByte(String <span class="italic">str</span>) throws NumberFormatException</td>
</tr>
</table><div class="calibre43"> </div>
<div class="calibre12"><span>The integer wrappers also offer a second parsing method that allows you to specify the radix.</span></div>
<div class="calibre23"><span>The parsing methods give us an easy way to convert a numeric value, read as a string from the keyboard or a text file, into its proper internal format. For example, the following program demonstrates <span class="bold1">parseInt( )</span> and <span class="bold1">parseDouble( )</span>. It averages a list of numbers entered by the user. It first asks the user for the number of values to be averaged. It then reads that number using <span class="bold1">readLine( )</span> and uses <span class="bold1">parseInt( )</span> to convert the string into an integer. Next, it inputs the values, using <span class="bold1">parseDouble( )</span> to convert the strings into their <span class="bold1">double</span> equivalents.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00666.jpg" class="calibre668"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Here is a sample run:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00667.jpg" class="calibre669"/></span></div><div class="calibre11"> </div>
<div class="calibre670"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   What else can the primitive type wrapper classes do?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   The primitive type wrappers provide a number of methods that help integrate the primitive types into the object hierarchy. For example, various storage mechanisms provided by the Java library, including maps, lists, and sets, work only with objects. Thus, to store an <span class="bold1">int</span>, for example, in a list, it must be wrapped in an object. Also, all type wrappers have a method called <span class="bold1">compareTo( )</span>, which compares the value contained within the wrapper; <span class="bold1">equals( )</span>, which tests two values for equality; and methods that return the value of the object in various forms. The topic of type wrappers is taken up again in <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_019.html#filepos994143">Chapter 12</a>, when autoboxing is discussed.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre11"> </div><table cellspacing="0" cellpadding="0" class="calibre37">
<colgroup class="calibre38">
<col class="calibre72"/>
<col class="calibre73"/>
</colgroup>
<tr class="calibre41">
<td valign="top" id="filepos898926" class="calibre74"><span class="calibre10"><span class="bold1">Try This 10-2</span> </span></td>
<td valign="top" class="calibre75"><span class="calibre10">Creating a Disk-Based Help System</span></td>
</tr></table><div class="calibre43"> </div>
<div class="calibre1"><span><img alt="image" src="images/00668.jpg" class="calibre671"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>In <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_011.html#filepos421161">Try This 4-1</a>, you created a <span class="bold1">Help</span> class that displayed information about Java’s control statements. In that implementation, the help information was stored within the class itself, and the user selected help from a menu of numbered options.</span></div>
<div class="calibre23"><span>Although this approach was fully functional, it is certainly not the ideal way of creating a Help system. For example, to add to or change the help information, the source code of the program needed to be modified. Also, the selection of the topic by number rather than by name is tedious, and is not suitable for long lists of topics. Here, we will remedy these shortcomings by creating a disk-based Help system.</span></div>
<div class="calibre23"><span>The disk-based Help system stores help information in a help file. The help file is a standard text file that can be changed or expanded at will, without changing the Help program. The user obtains help about a topic by typing in its name. The Help system searches the help file for the topic. If it is found, information about the topic is displayed.</span></div>
<div class="calibre19"><span>  <span class="bold1">1.</span>  Create the help file that will be used by the Help system. The help file is a standard text file that is organized like this:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00669.jpg" class="calibre672"/></span></div>
<div class="calibre47"><span>        The name of each topic must be preceded by a #, and the topic name must be on a line of its own. Preceding each topic name with a # allows the program to quickly find the start of each topic. After the topic name are any number of information lines about the topic. However, there must be a blank line between the end of one topic’s information and the start of the next topic. Also, there must be no trailing spaces at the end of any help-topic lines.</span></div>
<div class="calibre47"><span>        Here is a simple help file that you can use to try the disk-based Help system. It stores information about Java’s control statements.</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00670.jpg" class="calibre673"/></span></div>
<div class="calibre47"><span>        Call this file <span class="bold1">helpfile.txt</span>.</span></div>
<div class="calibre47"><span>  <span class="bold1">2.</span>  Create a file called <span class="bold1">FileHelp.java</span>.</span></div>
<div class="calibre47"><span>  <span class="bold1">3.</span>  Begin creating the new <span class="bold1">Help</span> class with these lines of code.</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00671.jpg" class="calibre674"/></span></div>
<div class="calibre47"><span>        The name of the help file is passed to the <span class="bold1">Help</span> constructor and stored in the instance variable <span class="bold1">helpfile</span>. Since each instance of <span class="bold1">Help</span> will have its own copy of <span class="bold1">helpfile</span>, each instance can use a different file. Thus, you can create different sets of help files for different sets of topics.</span></div>
<div class="calibre47"><span>  <span class="bold1">4.</span>  Add the <span class="bold1">helpOn( )</span> method shown here to the <span class="bold1">Help</span> class. This method retrieves help on the specified topic.</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00672.jpg" class="calibre675"/></span></div>
<div class="calibre47"><span>        The first thing to notice is that <span class="bold1">helpOn( )</span> handles all possible I/O exceptions itself and does not include a <span class="bold1">throws</span> clause. By handling its own exceptions, it prevents this burden from being passed on to all code that uses it. Thus, other code can simply call <span class="bold1">helpOn( )</span> without having to wrap that call in a <span class="bold1">try</span>/<span class="bold1">catch</span> block.</span></div>
<div class="calibre47"><span>        The help file is opened using a <span class="bold1">FileReader</span> that is wrapped in a <span class="bold1">BufferedReader</span>. Since the help file contains text, using a character stream allows the Help system to be more efficiently internationalized.</span></div>
<div class="calibre47"><span>        The <span class="bold1">helpOn( )</span> method works like this. A string containing the name of the topic is passed in the <span class="bold1">what</span> parameter. The help file is then opened. Then, the file is searched, looking for a match between <span class="bold1">what</span> and a topic in the file. Remember, in the file, each topic is preceded by a #, so the search loop scans the file for #s. When it finds one, it then checks to see if the topic following that # matches the one passed in <span class="bold1">what</span>. If it does, the information associated with that topic is displayed. If a match is found, <span class="bold1">helpOn( )</span> returns <span class="bold1">true</span>. Otherwise, it returns <span class="bold1">false</span>.</span></div>
<div class="calibre47"><span>  <span class="bold1">5.</span>  The <span class="bold1">Help</span> class also provides a method called <span class="bold1">getSelection( )</span>. It prompts the user for a topic and returns the topic string entered by the user.</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00673.jpg" class="calibre676"/></span></div>
<div class="calibre47"><span>        This method creates a <span class="bold1">BufferedReader</span> attached to <span class="bold1">System.in</span>. It then prompts for the name of a topic, reads the topic, and returns it to the caller.</span></div>
<div class="calibre47"><span>  <span class="bold1">6.</span>  The entire disk-based Help system is shown here:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00674.jpg" class="calibre677"/></span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00675.jpg" class="calibre678"/></span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00676.jpg" class="calibre679"/></span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre670"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   In addition to the</span> parse <span class="bold1">methods defined by the primitive type wrappers, is there another easy way to convert a numeric string entered at the keyboard into its equivalent binary format?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   Yes! Another way to convert a numeric string into its internal, binary format is to use one of the methods defined by the <span class="bold1">Scanner</span> class, packaged in <span class="bold1">java.util</span>. <span class="bold1">Scanner</span> reads formatted (that is, human-readable) input and converts it into its binary form. <span class="bold1">Scanner</span> can be used to read input from a variety of sources, including the console and files. Therefore, you can use <span class="bold1">Scanner</span> to read a numeric string entered at the keyboard and assign its value to a variable. Although <span class="bold1">Scanner</span> contains far too many features to describe in detail, the following illustrates its basic usage.</span></div>
<div class="calibre148"><span>To use <span class="bold1">Scanner</span> to read from the keyboard, you must first create a <span class="bold1">Scanner</span> linked to console input. To do this, you will use the following constructor:</span></div>
<div class="calibre1"><span>Scanner(InputStream <span class="italic">from</span>)</span></div>
<div class="calibre1"><span>This creates a <span class="bold1">Scanner</span> that uses the stream specified by <span class="italic">from</span> as a source for input. You can use this constructor to create a <span class="bold1">Scanner</span> linked to console input, as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00677.jpg" class="calibre329"/></span></div>
<div class="calibre1"><span>This works because <span class="bold1">System.in</span> is an object of type <span class="bold1">InputStream</span>. After this line executes, <span class="bold1">conin</span> can be used to read input from the keyboard.</span></div>
<div class="calibre624"><span>Once you have created a <span class="bold1">Scanner</span>, it is a simple matter to use it to read numeric input. Here is the general procedure:</span></div>
<div class="calibre19"><span>  <span class="bold1">1.</span>  Determine if a specific type of input is available by calling one of <span class="bold1">Scanner</span>’s <span class="bold1">hasNext</span><span class="italic">X</span> methods, where <span class="italic">X</span> is the type of data desired.</span></div>
<div class="calibre47"><span>  <span class="bold1">2.</span>  If input is available, read it by calling one of <span class="bold1">Scanner</span>’s <span class="bold1">next</span><span class="italic">X</span> methods.</span></div>
<div class="calibre1"><span>As the preceding indicates, <span class="bold1">Scanner</span> defines two sets of methods that enable you to read input. The first are the <span class="bold1">hasNext</span> methods. These include methods such as <span class="bold1">hasNextInt( )</span> and <span class="bold1">hasNextDouble( )</span>, for example. Each of the <span class="bold1">hasNext</span> methods returns <span class="bold1">true</span> if the desired data type is the next available item in the data stream, and <span class="bold1">false</span> otherwise. For example, calling <span class="bold1">hasNextInt( )</span> returns <span class="bold1">true</span> only if the next item in the stream is the human-readable form of an integer. If the desired data is available, you can read it by calling one of <span class="bold1">Scanner</span>’s <span class="bold1">next</span> methods, such as <span class="bold1">nextInt( )</span> or <span class="bold1">nextDouble( )</span>. These methods convert the human-readable form of the data into its internal, binary representation and return the result. For example, to read an integer, call <span class="bold1">nextInt( )</span>.</span></div>
<div class="calibre624"><span>The following sequence shows how to read an integer from the keyboard.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00678.jpg" class="calibre680"/></span></div>
<div class="calibre1"><span>Using this code, if you enter the number <span class="bold1">123</span> on the keyboard, then <span class="bold1">i</span> will contain the value 123.</span></div>
<div class="calibre624"><span>Technically, you can call a <span class="bold1">next</span> method without first calling a <span class="bold1">hasNext</span> method. However, doing so is not usually a good idea. If a <span class="bold1">next</span> method cannot find the type of data it is looking for, it throws an <span class="bold1">InputMismatchException</span>. For this reason, it is best to first confirm that the desired type of data is available by calling a <span class="bold1">hasNext</span> method before calling its corresponding <span class="bold1">next</span> method.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos912415" class="calibre1"><span class="calibre10"><span><img alt="image" src="images/00059.jpg" class="calibre104"/>   <span class="bold1"><span class="italic">Chapter 10 Self Test</span></span></span></span></div><div class="calibre11"> </div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos912696" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1547351">1</a>.</span>  Why does Java define both byte and character streams?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos912918" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1547858">2</a>.</span>  Even though console input and output is text-based, why does Java still use byte streams for this purpose?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos913193" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1548367">3</a>.</span>  Show how to open a file for reading bytes.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos913404" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1548885">4</a>.</span>  Show how to open a file for reading characters.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos913620" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1549409">5</a>.</span>  Show how to open a file for random-access I/O.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos913835" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1549927">6</a>.</span>  How can you convert a numeric string such as "123.23" into its binary equivalent?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos914099" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1550439">7</a>.</span>  Write a program that copies a text file. In the process, have it convert all spaces into hyphens. Use the byte stream file classes. Use the traditional approach to closing a file by explicitly calling <span class="bold1">close( )</span>.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos914485" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1551140">8</a>.</span>  Rewrite the program described in question 7 so that it uses the character stream classes. This time, use the <span class="bold1">try</span>-with-resources statement to automatically close the file.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos914831" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1551633">9</a>.</span>  What type of stream is <span class="bold1">System.in</span>?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos915024" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1551941">10</a>.</span>  What does the <span class="bold1">read( )</span> method of <span class="bold1">InputStream</span> return when the end of the stream is reached?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos915282" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1552312">11</a>.</span>  What type of stream is used to read binary data?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos915485" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1552634">12</a>.</span>   <span class="bold1">Reader</span> and <span class="bold1">Writer</span> are at the top of the ____________ class hierarchies.</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos915733" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1552983">13</a>.</span>  The <span class="bold1">try</span>-with-resources statement is used for ___________ ____________ ____________.</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos915978" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1553354">14</a>.</span>  If you are using the traditional method of closing a file, then closing a file within a <span class="bold1">finally</span> block is generally a good approach. True or False?</span></div>  <div class="mbppagebreak" id="calibre_pb_17"></div>
</body></html>
