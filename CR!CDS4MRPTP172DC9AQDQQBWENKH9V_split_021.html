<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Java&amp;#8482;: A Beginner&amp;#8217;s Guide Sixth Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="filepos1145762" class="calibre29"><span><img alt="image" src="images/00003.jpg" class="calibre30"/></span></div><div class="calibre11"> </div>
<div class="calibre31"><span class="calibre2"><span><big class="calibre3"><big class="calibre4"><big class="calibre5"><big class="calibre6"><big class="calibre32"><big class="calibre4">Chapter 14</big></big></big></big></big></big></span></span></div>
<div class="calibre9"><span class="calibre2"><span>Lambda Expressions and Method References</span></span></div><div class="calibre33"> </div>
<div class="calibre1"><span class="calibre10"><span><span class="bold1">Key Skills &amp; Concepts</span></span></span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Know the general form of a lambda expression</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Understand the definition of a functional interface</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Use expression lambdas</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Use block lambdas</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Use generic functional interfaces</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Understand variable capture in a lambda expression</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Throw an exception from a lambda expression</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Understand the method reference</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Understand the constructor reference</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Know about the predefined functional interfaces in <span class="bold1">java.util.function</span></span></div>
<div class="calibre1"><span><img alt="image" src="images/00004.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre12"><span><span><span class="calibre2"><span class="bold1">W</span></span></span>ith the release of JDK 8, a new feature has been added to Java that profoundly enhances the expressive power of the language. This feature is the <span class="italic">lambda expression</span>. Not only do lambda expressions add new syntax elements to the language, they also streamline the way that certain common constructs are implemented. In much the same way that the addition of generics reshaped Java years ago, lambda expressions are reshaping Java today. They truly are that important.</span></div>
<div class="calibre23"><span>The addition of lambda expressions have also provided the catalyst for other new Java features. You have already seen one of them—the default method—which was described in <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_015.html#filepos693174">Chapter 8</a>. It lets you define default behavior for an <span class="bold1">interface</span> method. Another example is the method reference, described later in this chapter, which lets you refer to a method without executing it. Furthermore, the inclusion of lambda expressions resulted in new capabilities being incorporated into the API library.</span></div>
<div class="calibre23"><span>Beyond the benefits that lambda expressions bring to the language, there is another reason why they constitute such an important addition to Java. Over the past few years, lambda expressions have become a major focus of computer language design. For example, they have been added to languages such as C# and C++. Their inclusion in Java helps it remain the vibrant, innovative language that programmers have come to expect. This chapter presents an introduction to this exciting new feature.</span></div>
<div id="filepos1150281" class="calibre1"><span class="calibre10"><span><span class="bold1">Introducing Lambda Expressions</span></span></span></div>
<div class="calibre12"><span>Key to understanding the lambda expression are two constructs. The first is the lambda expression, itself. The second is the functional interface. Let’s begin with a simple definition of each.</span></div>
<div class="calibre23"><span>A <span class="italic">lambda expression</span> is, essentially, an anonymous (that is, unnamed) method. However, this method is not executed on its own. Instead, it is used to implement a method defined by a functional interface. Thus, a lambda expression results in a form of anonymous class. Lambda expressions are also commonly referred to as <span class="italic">closures</span>.</span></div>
<div class="calibre23"><span>A <span class="italic">functional interface</span> is an interface that contains one and only one abstract method. Normally, this method specifies the intended purpose of the interface. Thus, a functional interface typically represents a single action. For example, the standard interface <span class="bold1">Runnable</span> is a functional interface because it defines only one method: <span class="bold1">run( )</span>. Therefore, <span class="bold1">run( )</span> defines the action of <span class="bold1">Runnable</span>. Furthermore, a functional interface defines the <span class="italic">target type</span> of a lambda expression. Here is a key point: a lambda expression can be used only in a context in which a target type is specified. One other thing: a functional interface is sometimes referred to as a <span class="italic">SAM type</span>, where SAM stands for <span class="italic">Single Abstract Method</span>.</span></div>
<div class="calibre23"><span>Let’s now look more closely at both lambda expressions and functional interfaces.</span></div>
<div class="calibre44"><span class="calibre10"><span><span class="bold1"><span class="italic">NOTE</span></span></span></span></div>
<div class="calibre9"><span><img alt="image" src="images/00006.jpg" class="calibre45"/></span></div>
<div class="calibre9"><span>A functional interface may specify any public method defined by <span class="bold1">Object</span>, such as <span class="bold1">equals( )</span>, without affecting its “functional interface” status. The public <span class="bold1">Object</span> methods are considered implicit members of a functional interface because they are automatically implemented by an instance of a functional interface.</span></div><div class="calibre11"> </div>
<div id="filepos1152760" class="calibre1"><span class="calibre10"><span><span class="bold1">Lambda Expression Fundamentals</span></span></span></div>
<div class="calibre12"><span>The lambda expression introduces a new syntax element and operator into the Java language. The new operator, sometimes referred to as the <span class="italic">lambda operator</span> or the <span class="italic">arrow operator</span>, is <span class="bold1">–&gt;</span>. It divides a lambda expression into two parts. The left side specifies any parameters required by the lambda expression. On the right side is the <span class="italic">lambda body</span>, which specifies the actions of the lambda expression. Java defines two types of lambda bodies. One type consists of a single expression, and the other type consists of a block of code. We will begin with lambdas that define a single expression.</span></div>
<div class="calibre23"><span>At this point, it will be helpful to look at a few examples of lambda expressions before continuing. Let’s begin with what is probably the simplest type of lambda expression you can write. It evaluates to a constant value and is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00875.jpg" class="calibre843"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>This lambda expression takes no parameters, thus the parameter list is empty. It returns the constant value 98.6. The return type is inferred to be <span class="bold1">double</span>. Therefore, it is similar to the following method:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00876.jpg" class="calibre844"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Of course, the method defined by a lambda expression does not have a name.</span></div>
<div class="calibre23"><span>A slightly more interesting lambda expression is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00877.jpg" class="calibre845"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>This lambda expression obtains a pseudo-random value from <span class="bold1">Math.random( )</span>, multiplies it by 100, and returns the result. It, too, does not require a parameter.</span></div>
<div class="calibre23"><span>When a lambda expression requires a parameter, it is specified in the parameter list on the left side of the lambda operator. Here is a simple example:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00878.jpg" class="calibre846"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>This lambda expression returns the reciprocal of the value of parameter <span class="bold1">n</span>. Thus, if <span class="bold1">n</span> is 4.0, the reciprocal is 0.25. Although it is possible to explicitly specify the type of a parameter, such as <span class="bold1">n</span> in this case, often you won’t need to because, in many cases, its type can be inferred. Like a named method, a lambda expression can specify as many parameters as needed.</span></div>
<div class="calibre23"><span>Any valid type can be used as the return type of a lambda expression. For example, this lambda expression returns <span class="bold1">true</span> if the value of parameter <span class="bold1">n</span> is even and <span class="bold1">false</span> otherwise.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00879.jpg" class="calibre847"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Thus, the return type of this lambda expression is <span class="bold1">boolean</span>.</span></div>
<div class="calibre23"><span>One other point before moving on. When a lambda expression has only one parameter, it is not necessary to surround the parameter name with parentheses when it is specified on the left side of the lambda operator. For example, this is also a valid way to write the lambda expression just shown:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00880.jpg" class="calibre848"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>For consistency, this book will surround all lambda expression parameter lists with parentheses, even those containing only one parameter. Of course, you are free to adopt a different style.</span></div>
<div id="filepos1157183" class="calibre1"><span class="calibre10"><span><span class="bold1">Functional Interfaces</span></span></span></div>
<div class="calibre12"><span>As stated, a functional interface is an interface that specifies only one abstract method. Before continuing, recall from <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_015.html#filepos693174">Chapter 8</a> that not all interface methods are abstract. Beginning with JDK 8, it is possible for an interface to have one or more default methods. Default methods are <span class="italic">not</span> abstract. Neither are <span class="bold1">static</span> interface methods. Thus, an interface method is abstract only if it is does not specify an implementation. This means that a functional interface can include default and/or <span class="bold1">static</span> methods, but in all cases it must have one and only one abstract method. Because non-default, non-<span class="bold1">static</span> interface methods are implicitly abstract, there is no need to use the <span class="bold1">abstract</span> modifier (although you can specify it, if you like).</span></div>
<div class="calibre23"><span>Here is an example of a functional interface:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00881.jpg" class="calibre849"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>In this case, the method <span class="bold1">getValue( )</span> is implicitly abstract, and it is the only method defined by <span class="bold1">MyValue</span>. Thus, <span class="bold1">MyValue</span> is a functional interface, and its function is defined by <span class="bold1">getValue( )</span>.</span></div>
<div class="calibre23"><span>As mentioned earlier, a lambda expression is not executed on its own. Rather, it forms the implementation of the abstract method defined by the functional interface that specifies its target type. As a result, a lambda expression can be specified only in a context in which a target type is defined. One of these contexts is created when a lambda expression is assigned to a functional interface reference. Other target type contexts include variable initialization, <span class="bold1">return</span> statements, and method arguments, to name a few.</span></div>
<div class="calibre23"><span>Let’s work through a simple example. First, a reference to the functional interface <span class="bold1">MyValue</span> is declared:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00882.jpg" class="calibre850"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Next, a lambda expression is assigned to that interface reference:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00883.jpg" class="calibre851"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>This lambda expression is compatible with <span class="bold1">getValue( )</span> because, like <span class="bold1">getValue( )</span>, it has no parameters and returns a <span class="bold1">double</span> result. In general, the type of the abstract method defined by the functional interface and the type of the lambda expression must be compatible. If they aren’t, a compile-time error will result.</span></div>
<div class="calibre23"><span>As you can probably guess, the two steps just shown can be combined into a single statement, if desired:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00884.jpg" class="calibre295"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, <span class="bold1">myVal</span> is initialized with the lambda expression.</span></div>
<div class="calibre23"><span>When a lambda expression occurs in a target type context, an instance of a class is automatically created that implements the functional interface, with the lambda expression defining the behavior of the abstract method declared by the functional interface. When that method is called through the target, the lambda expression is executed. Thus, a lambda expression gives us a way to transform a code segment into an object.</span></div>
<div class="calibre23"><span>In the preceding example, the lambda expression becomes the implementation for the <span class="bold1">getValue( )</span> method. As a result, the following displays the value 98.6:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00885.jpg" class="calibre852"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Because the lambda expression assigned to <span class="bold1">myVal</span> returns the value 98.6, that is the value obtained when <span class="bold1">getValue( )</span> is called.</span></div>
<div class="calibre23"><span>If the lambda expression takes one or more parameters, then the abstract method in the functional interface must also take the same number of parameters. For example, here is a functional interface called <span class="bold1">MyParamValue</span>, which lets you pass a value to <span class="bold1">getValue( )</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00886.jpg" class="calibre853"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>You can use this interface to implement the reciprocal lambda shown in the previous section. For example:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00887.jpg" class="calibre854"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>You can then use <span class="bold1">myPval</span> like this:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00888.jpg" class="calibre780"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, <span class="bold1">getValue( )</span> is implemented by the lambda expression referred to by <span class="bold1">myPval</span>, which returns the reciprocal of the argument. In this case, 4.0 is passed to <span class="bold1">getValue( )</span>, which returns 0.25.</span></div>
<div class="calibre23"><span>There is something else of interest in the preceding example. Notice that the type of <span class="bold1">n</span> is not specified. Rather, its type is inferred from the context. In this case, its type is inferred from the parameter type of <span class="bold1">getValue( )</span> as defined by the <span class="bold1">MyParamValue</span> interface, which is <span class="bold1">double</span>. It is also possible to explicitly specify the type of a parameter in a lambda expression. For example, this is also a valid way to write the preceding:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00889.jpg" class="calibre855"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, <span class="bold1">n</span> is explicitly specified as <span class="bold1">double</span>. Usually it is not necessary to explicitly specify the type.</span></div>
<div class="calibre23"><span>Before moving on, it is important to emphasize a key point: For a lambda expression to be used in a target type context, the type of the abstract method and the type of the lambda expression must be compatible. For example, if the abstract method specifies two <span class="bold1">int</span> parameters, then the lambda must specify two parameters whose type either is explicitly <span class="bold1">int</span> or can be implicitly inferred as <span class="bold1">int</span> by the context. In general, the type and number of the lambda expression’s parameters must be compatible with the method’s parameters and its return type.</span></div>
<div id="filepos1164611" class="calibre1"><span class="calibre10"><span><span class="bold1">Lambda Expressions in Action</span></span></span></div>
<div class="calibre12"><span>With the preceding discussion in mind, let’s look at some simple examples that put the basic lambda expression concepts into action. The first example assembles the pieces shown in the foregoing section into a complete program that you can run and experiment with.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00890.jpg" class="calibre856"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Sample output from the program is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00891.jpg" class="calibre857"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>As mentioned, the lambda expression must be compatible with the abstract method that it is intended to implement. For this reason, the commented-out lines at the end of the preceding program are illegal. The first, because a value of type <span class="bold1">String</span> is not compatible with <span class="bold1">double</span>, which is the return type required by <span class="bold1">getValue( )</span>. The second, because <span class="bold1">getValue(int)</span> in <span class="bold1">MyParamValue</span> requires a parameter, and one is not provided.</span></div>
<div class="calibre23"><span>A key aspect of a functional interface is that it can be used with any lambda expression that is compatible with it. For example, consider the following program. It defines a functional interface called <span class="bold1">NumericTest</span> that declares the abstract method <span class="bold1">test( )</span>. This method has two <span class="bold1">int</span> parameters and returns a <span class="bold1">boolean</span> result. Its purpose is to determine if the two arguments passed to <span class="bold1">test( )</span> satisfy some condition. It returns the result of the test. In <span class="bold1">main( )</span>, three different tests are created through the use of lambda expressions. One tests if the first argument can be evenly divided by the second; the second determines if the first argument is less than the second; and the third returns <span class="bold1">true</span> if the absolute values of the arguments are equal. Notice that the lambda expressions that implement these tests have two parameters and return a <span class="bold1">boolean</span> result. This is, of course, necessary since <span class="bold1">test( )</span> has two parameters and returns a <span class="bold1">boolean</span> result.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00892.jpg" class="calibre856"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>The output is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00893.jpg" class="calibre858"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>As the program illustrates, because all three lambda expressions are compatible with <span class="bold1">test( )</span>, all can be executed through a <span class="bold1">NumericTest</span> reference. In fact, there is no need to use three separate <span class="bold1">NumericTest</span> reference variables because the same one could have been used for all three tests. For example, you could create the variable <span class="bold1">myTest</span> and then use it to refer to each test, in turn, as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00894.jpg" class="calibre161"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Of course, using different reference variables called <span class="bold1">isFactor</span>, <span class="bold1">lessThan</span>, and <span class="bold1">absEqual</span>, as the original program does, makes it very clear to which lambda expression each variable refers.</span></div>
<div class="calibre23"><span>There is one other point of interest in the preceding program. Notice how the two parameters are specified for the lambda expressions. For example, here is the one that determines if one number is a factor of another:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00895.jpg" class="calibre859"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Notice that <span class="bold1">n</span> and <span class="bold1">d</span> are separated by commas. In general, whenever more than one parameter is required, the parameters are specified, separated by commas, in a parenthesized list on the left side of the lambda operator.</span></div>
<div class="calibre23"><span>Although the preceding examples used primitive values as the parameter types and return type of the abstract method defined by a functional interface, there is no restriction in this regard. For example, the following program declares a functional interface called <span class="bold1">StringTest</span>. It has a method called <span class="bold1">test( )</span> that takes two <span class="bold1">String</span> parameters and returns a <span class="bold1">boolean</span> result. Thus, it can be used to test some condition related to strings. Here, a lambda expression is created that determines if one string is contained within another:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00896.jpg" class="calibre860"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>The output is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00897.jpg" class="calibre861"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Notice that the lambda expression uses the <span class="bold1">indexOf( )</span> method defined by the <span class="bold1">String</span> class to determine if one string is part of another. This works because the parameters <span class="bold1">a</span> and <span class="bold1">b</span> are determined by type inference to be of type <span class="bold1">String</span>. Thus, it is permissible to call a <span class="bold1">String</span> method on <span class="bold1">a</span>.</span></div>
<div class="calibre35"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   Earlier you mentioned that I can explicitly declare the type of a parameter in a lambda expression if needed. In cases in which a lambda expression requires two or more parameters, must I specify the types of all parameters, or can I let one or more use type inference?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   In cases in which you need to explicitly declare the type of a parameter, then all of the parameters in the list must have declared types. For example, this is legal:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00898.jpg" class="calibre862"/></span></div>
<div class="calibre1"><span>But this is not legal:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00899.jpg" class="calibre863"/></span></div>
<div class="calibre1"><span>Nor is this legal:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00900.jpg" class="calibre863"/></span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos1172183" class="calibre9"><span class="calibre10"><span><span class="bold1">Block Lambda Expressions</span></span></span></div>
<div class="calibre12"><span>The body of the lambdas shown in the preceding examples consist of a single expression. These types of lambda bodies are referred to as <span class="italic">expression bodies</span>, and lambdas that have expression bodies are sometimes called <span class="italic">expression lambdas</span>. In an expression body, the code on the right side of the lambda operator must consist of a single expression, which becomes the lambda’s value. Although expression lambdas are quite useful, sometimes the situation will require more than a single expression. To handle such cases, Java supports a second type of lambda expression in which the code on the right side of the lambda operator consists of a block of code that can contain more than one statement. This type of lambda body is called a <span class="italic">block body</span>. Lambdas that have block bodies are sometimes referred to as <span class="italic">block lambdas</span>.</span></div>
<div class="calibre23"><span>A block lambda expands the types of operations that can be handled within a lambda expression because it allows the body of the lambda to contain multiple statements. For example, in a block lambda you can declare variables, use loops, specify <span class="bold1">if</span> and <span class="bold1">switch</span> statements, create nested blocks, and so on. A block lambda is easy to create. Simply enclose the body within braces as you would any other block of statements.</span></div>
<div class="calibre23"><span>Aside from allowing multiple statements, block lambdas are used much like the expression lambdas just discussed. One key difference, however, is that you must explicitly use a <span class="bold1">return</span> statement to return a value. This is necessary because a block lambda body does not represent a single expression.</span></div>
<div class="calibre23"><span>Here is an example that uses a block lambda to find the smallest positive factor of an <span class="bold1">int</span> value. It uses an interface called <span class="bold1">NumericFunc</span> that has a method called <span class="bold1">func( )</span>, which takes one <span class="bold1">int</span> argument and returns an <span class="bold1">int</span> result. Thus, <span class="bold1">NumericFunc</span> supports a numeric function on values of type <span class="bold1">int</span>.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00901.jpg" class="calibre864"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The output is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00902.jpg" class="calibre865"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>In the program, notice that the block lambda declares a variable called <span class="bold1">result</span>, uses a <span class="bold1">for</span> loop, and has a <span class="bold1">return</span> statement. These are legal inside a block lambda body. In essence, the block body of a lambda is similar to a method body. One other point. When a <span class="bold1">return</span> statement occurs within a lambda expression, it simply causes a return from the lambda. It does not cause an enclosing method to return.</span></div>
<div id="filepos1175390" class="calibre1"><span class="calibre10"><span><span class="bold1">Generic Functional Interfaces</span></span></span></div>
<div class="calibre12"><span>A lambda expression, itself, cannot specify type parameters. Thus, a lambda expression cannot be generic. (Of course, because of type inference, all lambda expressions exhibit some “generic-like” qualities.) However, the functional interface associated with a lambda expression can be generic. In this case, the target type of the lambda expression is determined, in part, by the type argument or arguments specified when a functional interface reference is declared.</span></div>
<div class="calibre23"><span>To understand the value of generic functional interfaces, consider this. Earlier in this chapter, two different functional interfaces were created, one called <span class="bold1">NumericTest</span> and the other called <span class="bold1">StringTest</span>. They were used to determine if two values satisfied some condition. To do this, both defined a method called <span class="bold1">test( )</span> that took two parameters and returned a <span class="bold1">boolean</span> result. In the case of <span class="bold1">NumericTest</span>, the values being tested were integers. For <span class="bold1">StringTest</span>, the values were of type <span class="bold1">String</span>. Thus, the only difference between the two methods was the type of data they operated on. Such a situation is perfect for generics. Instead of having two functional interfaces whose methods differ only in their data types, it is possible to declare one generic interface that can be used to handle both circumstances. The following program shows this approach:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00903.jpg" class="calibre714"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The output is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00904.jpg" class="calibre866"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>In the program, the generic functional interface <span class="bold1">SomeTest</span> is declared as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00905.jpg" class="calibre867"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, <span class="bold1">T</span> specifies the type of both parameters for <span class="bold1">test( )</span>. This means that it is compatible with any lambda expression that takes two parameters of the same type and returns a <span class="bold1">boolean</span> result.</span></div>
<div class="calibre23"><span>The <span class="bold1">SomeTest</span> interface is used to provide a reference to three different types of lambdas. The first uses type <span class="bold1">Integer</span>, the second uses type <span class="bold1">Double</span>, and the third uses type <span class="bold1">String</span>. Thus, the same functional interface can be used to refer to the <span class="bold1">isFactor</span>, <span class="bold1">isFactorD</span>, and <span class="bold1">isIn</span> lambdas. Only the type argument passed to <span class="bold1">SomeTest</span> differs.</span></div>
<div class="calibre23"><span>As a point of interest, the <span class="bold1">NumericFunc</span> interface shown in the previous section can also be rewritten as a generic interface. This is an exercise in “<a href="#filepos1145762">Chapter 14</a> Self Test,” at the end of this chapter.</span></div>
<div class="calibre18"> </div><table cellspacing="0" cellpadding="0" class="calibre37">
<colgroup class="calibre38">
<col class="calibre72"/>
<col class="calibre73"/>
</colgroup>
<tr class="calibre41">
<td valign="top" id="filepos1178923" class="calibre74"><span class="calibre10"><span class="bold1">Try This 14-1</span> </span></td>
<td valign="top" class="calibre75"><span class="calibre10">Pass a Lambda Expression as an Argument</span></td>
</tr></table><div class="calibre43"> </div>
<div class="calibre1"><span><img alt="image" src="images/00906.jpg" class="calibre868"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>A lambda expression can be used in any context that provides a target type. The target contexts used by the preceding examples are assignment and initialization. Another one is when a lambda expression is passed as an argument. In fact, passing a lambda expression as an argument is a common use of lambdas. Moreover, it is a very powerful use because it gives you a way to pass executable code as an argument to a method. This greatly enhances the expressive power of Java.</span></div>
<div class="calibre23"><span>To illustrate the process, this project creates three string functions that perform the following operations: reverse a string, reverse the case of letters within a string, and replace spaces with hyphens. These functions are implemented as lambda expressions of the functional interface <span class="bold1">StringFunc</span>. They are then passed as the first argument to a method called <span class="bold1">changeStr( )</span>. This method applies the string function to the string passed as the second argument to <span class="bold1">changeStr( )</span> and returns the result. Thus, <span class="bold1">changeStr( )</span> can be used to apply a variety of different string functions.</span></div>
<div class="calibre19"><span>  <span class="bold1">1</span>.  Create a file called <span class="bold1">LambdaArgumentDemo.java</span>.</span></div>
<div class="calibre47"><span>  <span class="bold1">2</span>.  To the file, add the functional interface <span class="bold1">StringFunc</span>, as shown here:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00907.jpg" class="calibre869"/></span></div>
<div class="calibre47"><span>        This interface defines the method <span class="bold1">func( )</span>, which takes a <span class="bold1">String</span> argument and returns a <span class="bold1">String</span>. Thus, <span class="bold1">func( )</span> can act on a string and return the result.</span></div>
<div class="calibre47"><span>  <span class="bold1">3</span>.  Begin the <span class="bold1">LambdaArgumentDemo</span> class, as shown here, by defining the <span class="bold1">changeStr( )</span> method:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00908.jpg" class="calibre870"/></span></div>
<div class="calibre47"><span>        As the comment indicates, <span class="bold1">changeStr( )</span> has two parameters. The type of the first is <span class="bold1">StringFunc</span>. This means it can be passed a reference to any <span class="bold1">StringFunc</span> instance. Thus, it can be passed a reference to an instance created by a lambda expression that is compatible with <span class="bold1">StringFunc</span>. The string to be acted on is passed to <span class="bold1">s</span>. The resulting string is returned.</span></div>
<div class="calibre47"><span>  <span class="bold1">4</span>.  Begin the <span class="bold1">main( )</span> method, as shown here:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00909.jpg" class="calibre871"/></span></div>
<div class="calibre47"><span>        Here, <span class="bold1">inStr</span> refers to the string that will be acted on, and <span class="bold1">outStr</span> will receive the modified string.</span></div>
<div class="calibre47"><span>  <span class="bold1">5</span>.  Define a lambda expression that reverses the characters in a string and assign it to a <span class="bold1">StringFunc</span> reference. Notice that this is another example of a block lambda.</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00910.jpg" class="calibre589"/></span></div>
<div class="calibre47"><span>  <span class="bold1">6</span>.  Call <span class="bold1">changeStr( )</span>, passing in the <span class="bold1">reverse</span> lambda and <span class="bold1">inStr</span>. Assign the result to <span class="bold1">outStr</span>, and display the result.</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00911.jpg" class="calibre872"/></span></div>
<div class="calibre47"><span>        Because the first parameter to <span class="bold1">changeStr( )</span> is of type <span class="bold1">StringFunc</span>, the <span class="bold1">reverse</span> lambda can be passed to it. Recall that a lambda expression causes an instance of its target type to be created, which in this case is <span class="bold1">StringFunc</span>. Thus, a lambda expression gives you a way to effectively pass a code sequence to a method.</span></div>
<div class="calibre47"><span>  <span class="bold1">7</span>.  Finish the program by adding lambdas that replace spaces with hyphens and invert the case of the letters, as shown next. Notice that both of these lambdas are embedded in the call to <span class="bold1">changeStr( )</span>, itself, rather than using a separate <span class="bold1">StringFunc</span> variable.</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00912.jpg" class="calibre761"/></span></div>
<div class="calibre47"><span>        As you can see by looking at this code, embedding the lambda that replaces spaces with hyphens in the call to <span class="bold1">changeStr( )</span> is both convenient and easy to understand. This is because it is a short, expression lambda that simply calls <span class="bold1">replace( )</span> to replace spaces with hyphens. The <span class="bold1">replace( )</span> method is another method defined by the <span class="bold1">String</span> class. The version used here takes as arguments the character to be replaced and its replacement. It returns a modified string.</span></div>
<div class="calibre21"><span>            For the sake of illustration, the lambda that inverts the case of the letters in a string is also embedded in the call to <span class="bold1">changeStr( )</span>. However, in this case, rather unwieldy code is produced that is somewhat hard to follow. Usually, it is better to assign such a lambda to a separate reference variable (as was done for the string-reversing lambda), and then pass that variable to the method. Of course, it is technically correct to pass a block lambda as an argument, as the example shows.</span></div>
<div class="calibre21"><span>            One other point: notice that the invert-case lambda uses the <span class="bold1">static</span> methods <span class="bold1">isUpperCase( )</span>, <span class="bold1">toUpperCase( )</span>, and <span class="bold1">toLowerCase( )</span> defined by <span class="bold1">Character</span>. Recall that <span class="bold1">Character</span> is a wrapper class for <span class="bold1">char</span>. The <span class="bold1">isUpperCase( )</span> method returns <span class="bold1">true</span> if its argument is an uppercase letter and <span class="bold1">false</span> otherwise. The <span class="bold1">toUpperCase( )</span> and <span class="bold1">toLowerCase( )</span> perform the indicated action and return the result. In addition to these methods, <span class="bold1">Character</span> defines several others that manipulate or test characters. You will want to explore them on your own.</span></div>
<div class="calibre47"><span>  <span class="bold1">8</span>.  Here is all the code assembled into a complete program.</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00913.jpg" class="calibre873"/></span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00914.jpg" class="calibre874"/></span></div>
<div class="calibre592"><span>The following output is produced:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00915.jpg" class="calibre875"/></span></div><div class="calibre11"> </div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre670"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   In addition to variable initialization, assignment, and argument passing, what other places constitute a target type context for a lambda expression?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   Casts, the <span class="bold1">?</span> operator, array initializers, <span class="bold1">return</span> statements, and lambda expressions, themselves, can also serve as target type contexts.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos1189285" class="calibre9"><span class="calibre10"><span><span class="bold1">Lambda Expressions and Variable Capture</span></span></span></div>
<div class="calibre12"><span>Variables defined by the enclosing scope of a lambda expression are accessible within the lambda expression. For example, a lambda expression can use an instance variable or <span class="bold1">static</span> variable defined by its enclosing class. A lambda expression also has access to <span class="bold1">this</span> (both explicitly and implicitly), which refers to the invoking instance of the lambda expression’s enclosing class. Thus, a lambda expression can obtain or set the value of an instance variable or <span class="bold1">static</span> variable and call a method defined by its enclosing class.</span></div>
<div class="calibre23"><span>However, when a lambda expression uses a local variable from its enclosing scope, a special situation is created that is referred to as a <span class="italic">variable capture</span>. In this case, a lambda expression may only use local variables that are <span class="italic">effectively final</span>. An effectively final variable is one whose value does not change after it is first assigned. There is no need to explicitly declare such a variable as <span class="bold1">final</span>, although doing so would not be an error. (The <span class="bold1">this</span> parameter of an enclosing scope is automatically effectively final, and lambda expressions do not have a <span class="bold1">this</span> of their own.)</span></div>
<div class="calibre23"><span>It is important to understand that a local variable of the enclosing scope cannot be modified by the lambda expression. Doing so would remove its effectively final status, thus rendering it illegal for capture.</span></div>
<div class="calibre23"><span>The following program illustrates the difference between effectively final and mutable local variables:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00916.jpg" class="calibre707"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>As the comments indicate, <span class="bold1">num</span> is effectively final and can, therefore, be used inside <span class="bold1">myLambda</span>. This is why the <span class="bold1">println( )</span> statement outputs the number 18. When <span class="bold1">func( )</span> is called with the argument 8, the value of <span class="bold1">v</span> inside the lambda is set by adding <span class="bold1">num</span> (which is 10) to the value passed to <span class="bold1">n</span> (which is 8). Thus, <span class="bold1">func( )</span> returns 18. This works because <span class="bold1">num</span> is not modified after it is initialized. However, if <span class="bold1">num</span> were to be modified, either inside the lambda or outside of it, <span class="bold1">num</span> would lose its effectively <span class="bold1">final</span> status. This would cause an error, and the program would not compile.</span></div>
<div class="calibre23"><span>It is important to emphasize that a lambda expression can use and modify an instance variable from its invoking class. It just can’t use a local variable of its enclosing scope unless that variable is effectively final.</span></div>
<div id="filepos1192372" class="calibre1"><span class="calibre10"><span><span class="bold1">Throw an Exception from Within a Lambda Expression</span></span></span></div>
<div class="calibre12"><span>A lambda expression can throw an exception. If it throws a checked exception, however, then that exception must be compatible with the exception(s) listed in the <span class="bold1">throws</span> clause of the abstract method in the functional interface. For example, if a lambda expression throws an <span class="bold1">IOException</span>, then the abstract method in the functional interface must list <span class="bold1">IOException</span> in a <span class="bold1">throws</span> clause. This situation is demonstrated by the following program:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00917.jpg" class="calibre786"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Because a call to <span class="bold1">read( )</span> could result in an <span class="bold1">IOException</span>, the <span class="bold1">ioAction( )</span> method of the functional interface <span class="bold1">MyIOAction</span> must include <span class="bold1">IOException</span> in a <span class="bold1">throws</span> clause. Without it, the program will not compile because the lambda expression will no longer be compatible with <span class="bold1">ioAction( )</span>. To prove this, simply remove the <span class="bold1">throws</span> clause and try compiling the program. As you will see, an error will result.</span></div>
<div class="calibre35"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   Can a lambda expression use a parameter that is an array?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   Yes. However, when the type of the parameter is inferred, the parameter to the lambda expression is <span class="italic">not</span> specified using the normal array syntax. Rather, the parameter is specified as a simple name, such as <span class="bold1">n</span>, not as <span class="bold1">n[ ]</span>. Remember, the type of a lambda expression parameter will be inferred from the target context. Thus, if the target context requires an array, then the parameter’s type will automatically be inferred as an array. To better understand this, let’s work through a short example.</span></div>
<div class="calibre624"><span>Here is a generic functional interface called <span class="bold1">MyTransform</span>, which can be used to apply some transform to the elements of an array:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00918.jpg" class="calibre876"/></span></div>
<div class="calibre1"><span>Notice that the parameter to the <span class="bold1">transform( )</span> method is an array of type <span class="bold1">T</span>. Now, consider the following lambda expression that uses <span class="bold1">MyTransform</span> to convert the elements of an array of <span class="bold1">Double</span> values into their square roots:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00919.jpg" class="calibre877"/></span></div>
<div class="calibre1"><span>Here, the type of <span class="bold1">a</span> in <span class="bold1">transform( )</span> is <span class="bold1">Double[ ]</span>, because <span class="bold1">Double</span> is specified as the type parameter for <span class="bold1">MyTransform</span> when <span class="bold1">sqrts</span> is declared. Therefore, the type of <span class="bold1">v</span> in the lambda expression is inferred as <span class="bold1">Double[ ]</span>. It is not necessary (or legal) to specify it as <span class="bold1">v[ ]</span>.</span></div>
<div class="calibre624"><span>One last point: It is legal to declare the lambda parameter as <span class="bold1">Double[ ] v</span>, because doing so explicitly declares the type of the parameter. However, doing so gains nothing in this case.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos1196487" class="calibre9"><span class="calibre10"><span><span class="bold1">Method References</span></span></span></div>
<div class="calibre12"><span>There is an important feature related to lambda expressions called the <span class="italic">method reference</span>. A method reference provides a way to refer to a method without executing it. It relates to lambda expressions because it, too, requires a target type context that consists of a compatible functional interface. When evaluated, a method reference also creates an instance of a functional interface. There are different types of method references. We will begin with method references to <span class="bold1">static</span> methods.</span></div>
<div id="filepos1197173" class="calibre1"><span class="calibre10"><span><span class="bold1">Method References to static Methods</span></span></span></div>
<div class="calibre12"><span>A method reference to a <span class="bold1">static</span> method is created by specifying the method name preceded by its class name, using this general syntax:</span></div>
<div class="calibre27"><span><span class="italic">ClassName</span>::<span class="italic">methodName</span></span></div>
<div class="calibre27"><span>Notice that the class name is separated from the method name by a double colon. The <span class="bold1">::</span> is a new separator that has been added to Java by JDK 8 expressly for this purpose. This method reference can be used anywhere in which it is compatible with its target type.</span></div>
<div class="calibre23"><span>The following program demonstrates the <span class="bold1">static</span> method reference. It does so by first declaring a functional interface called <span class="bold1">IntPredicate</span> that has a method called <span class="bold1">test( )</span>. This method has an <span class="bold1">int</span> parameter and returns a <span class="bold1">boolean</span> result. Thus, it can be used to test an integer value against some condition. The program then creates a class called <span class="bold1">MyIntPredicates</span>, which defines three <span class="bold1">static</span> methods, with each one checking if a value satisfies some condition. The methods are called <span class="bold1">isPrime( )</span>, <span class="bold1">isEven( )</span>, and <span class="bold1">isPositive( )</span>, and each method performs the test indicated by its name. Inside <span class="bold1">MethodRefDemo</span>, a method called <span class="bold1">numTest( )</span> is created that has as its first parameter, a reference to <span class="bold1">IntPredicate</span>. Its second parameter specifies the integer being tested. Inside <span class="bold1">main( )</span>, three different tests are performed by calling <span class="bold1">numTest( )</span>, passing in a method reference to the test to perform.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00920.jpg" class="calibre152"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00921.jpg" class="calibre878"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The output is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00922.jpg" class="calibre520"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>In the program, pay special attention to this line:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00923.jpg" class="calibre879"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, a reference to the <span class="bold1">static</span> method <span class="bold1">isPrime( )</span> is passed as the first argument to <span class="bold1">numTest( )</span>. This works because <span class="bold1">isPrime</span> is compatible with the <span class="bold1">IntPredicate</span> functional interface. Thus, the expression <span class="bold1">MyIntPredicates::isPrime</span> evaluates to a reference to an object in which <span class="bold1">isPrime( )</span> provides the implementation of <span class="bold1">test( )</span> in <span class="bold1">IntPredicate</span>. The other two calls to <span class="bold1">numTest( )</span> work in the same way.</span></div>
<div id="filepos1200286" class="calibre1"><span class="calibre10"><span><span class="bold1">Method References to Instance Methods</span></span></span></div>
<div class="calibre12"><span>A reference to an instance method on a specific object is create by this basic syntax:</span></div>
<div class="calibre27"><span><span class="italic">objRef</span>::<span class="italic">methodName</span></span></div>
<div class="calibre27"><span>As you can see, the syntax is similar to that used for a <span class="bold1">static</span> method, except that an object reference is used instead of a class name. Thus, the method referred to by the method reference operates relative to <span class="italic">objRef</span>. The following program illustrates this point. It uses the same <span class="bold1">IntPredicate</span> interface and <span class="bold1">test( )</span> method as the previous program. However, it creates a class called <span class="bold1">MyIntNum</span>, which stores an <span class="bold1">int</span> value and defines the method <span class="bold1">isFactor( )</span>, which determines if the value passed is a factor of the value stored by the <span class="bold1">MyIntNum</span> instance. The <span class="bold1">main( )</span> method then creates two <span class="bold1">MyIntNum</span> instances. It then calls <span class="bold1">numTest( )</span>, passing in a method reference to the <span class="bold1">isFactor( )</span> method and the value to be checked. In each case, the method reference operates relative to the specific object.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00924.jpg" class="calibre880"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>This program produces the following output:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00925.jpg" class="calibre881"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>In the program, pay special attention to the line:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00926.jpg" class="calibre119"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, the method reference assigned to <span class="bold1">ip</span> refers to an instance method <span class="bold1">isFactor( )</span> on <span class="bold1">myNum</span>. Thus, when <span class="bold1">test( )</span> is called through that reference, as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00927.jpg" class="calibre778"/></span></div><div class="calibre11"> </div>
<div class="calibre27"><span>the method will call <span class="bold1">isFactor( )</span> on <span class="bold1">myNum</span>, which is the object specified when the method reference was created. The same situation occurs with the method reference <span class="bold1">myNum2::isFactor</span>, except that <span class="bold1">isFactor( )</span> will be called on <span class="bold1">myNum2</span>. This is confirmed by the output.</span></div>
<div class="calibre23"><span>It is also possible to handle a situation in which you want to specify an instance method that can be used with any object of a given class—not just a specified object. In this case, you will create a method reference as shown here:</span></div>
<div class="calibre27"><span><span class="italic">ClassName</span>::<span class="italic">instanceMethodName</span></span></div>
<div class="calibre27"><span>Here, the name of the class is used instead of a specific object, even though an instance method is specified. With this form, the first parameter of the functional interface matches the invoking object and the second parameter matches the parameter (if any) specified by the method. Here is an example. It reworks the previous example. First, it replaces <span class="bold1">IntPredicate</span> with the interface <span class="bold1">MyIntNumPredicate</span>. In this case, the first parameter to <span class="bold1">test( )</span> is of type <span class="bold1">MyIntNum</span>. It will be used to receive the object being operated upon. This allows the program to create a method reference to the instance method <span class="bold1">isFactor( )</span> that can be used with any <span class="bold1">MyIntNum</span> object.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00928.jpg" class="calibre882"/></span></div><div class="calibre11"> </div>
<div class="calibre29"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   How do I specify a method reference to a generic method?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   Often, because of type inference, you won’t need to explicitly specify a type argument to a generic method when obtaining its method reference, but Java does include a syntax to handle those cases in which you do. For example, assuming the following:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00929.jpg" class="calibre883"/></span></div>
<div class="calibre1"><span>the following statement is valid:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00930.jpg" class="calibre884"/></span></div>
<div class="calibre1"><span>Here, the type argument for the generic method <span class="bold1">myGenMeth</span> is explicitly specified. Notice that the type argument occurs after the <span class="bold1">::</span>. This syntax can be generalized: When a generic method is specified as a method reference, its type argument comes after the <span class="bold1">::</span> and before the method name. In cases in which a generic class is specified, the type argument follows the class name and precedes the <span class="bold1">::</span>.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre12"><span>The output is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00931.jpg" class="calibre885"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>In the program, pay special attention to this line:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00932.jpg" class="calibre886"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>It creates a method reference to the instance method <span class="bold1">isFactor( )</span> that will work with any object of type <span class="bold1">MyIntNum</span>. For example, when <span class="bold1">test( )</span> is called through the <span class="bold1">inp</span>, as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00933.jpg" class="calibre887"/></span></div><div class="calibre11"> </div>
<div class="calibre27"><span>it results in a call to <span class="bold1">myNum.isFactor(3)</span>. In other words, <span class="bold1">myNum</span> becomes the object on which <span class="bold1">isFactor(3)</span> is called.</span></div>
<div id="filepos1207260" class="calibre1"><span class="calibre10"><span><span class="bold1">Constructor References</span></span></span></div>
<div class="calibre12"><span>Similar to the way that you can create references to methods, you can also create references to constructors. Here is the general form of the syntax that you will use:</span></div>
<div class="calibre27"><span><span class="italic">classname</span>::new</span></div>
<div class="calibre27"><span>This reference can be assigned to any functional interface reference that defines a method compatible with the constructor. Here is a simple example:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00934.jpg" class="calibre888"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The output is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00935.jpg" class="calibre889"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>In the program, notice that the <span class="bold1">func( )</span> method of <span class="bold1">MyFunc</span> returns a reference of type <span class="bold1">MyClass</span> and has a <span class="bold1">String</span> parameter. Next, notice that <span class="bold1">MyClass</span> defines two constructors. The first specifies a parameter of type <span class="bold1">String</span>. The second is the default, parameterless constructor. Now, examine the following line:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00936.jpg" class="calibre890"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, the expression <span class="bold1">MyClass::new</span> creates a constructor reference to a <span class="bold1">MyClass</span> constructor. In this case, because <span class="bold1">MyFunc</span>’s <span class="bold1">func( )</span> method takes a <span class="bold1">String</span> parameter, the constructor being referred to is <span class="bold1">MyClass(String s)</span> because it is the one that matches. Also notice that the reference to this constructor is assigned to a <span class="bold1">MyFunc</span> reference called <span class="bold1">myClassCons</span>. After this statement executes, <span class="bold1">myClassCons</span> can be used to create an instance of <span class="bold1">MyClass</span>, as this line shows:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00937.jpg" class="calibre300"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>In essence, <span class="bold1">myClassCons</span> has become another way to call <span class="bold1">MyClass(String s)</span>.</span></div>
<div class="calibre23"><span>If you wanted <span class="bold1">MyClass::new</span> to use <span class="bold1">MyClass</span>’s default constructor, then you would need to use a functional interface that defines a method that has no parameter. For example, if you define <span class="bold1">MyFunc2</span>, as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00938.jpg" class="calibre891"/></span></div><div class="calibre11"> </div>
<div class="calibre27"><span>then the following line will assign to <span class="bold1">MyClassCons</span> a reference to <span class="bold1">MyClass</span>’s default (i.e., parameterless) constructor:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00939.jpg" class="calibre892"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>In general, the constructor that will be used when <span class="bold1">::new</span> is specified is the one whose parameters match those specified by the functional interface.</span></div>
<div class="calibre35"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   Can I declare a constructor reference that creates an array?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   Yes. To create a constructor reference for an array, use this construct:</span></div>
<div class="calibre1"><span><span class="italic">type</span>[]::new</span></div>
<div class="calibre1"><span>Here, <span class="italic">type</span> specifies the type of object being created. For example, assuming the form of <span class="bold1">MyClass</span> shown in the preceding example and given the <span class="bold1">MyClassArrayCreator</span> interface shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00940.jpg" class="calibre893"/></span></div>
<div class="calibre1"><span>the following creates an array of <span class="bold1">MyClass</span> objects and gives each element an initial value:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00941.jpg" class="calibre894"/></span></div>
<div class="calibre1"><span>Here, the call to <span class="bold1">func(3)</span> causes a three-element array to be created. This example can be generalized. Any functional interface that will be used to create an array must contain a method that takes a single <span class="bold1">int</span> parameter and returns a reference to the array of the specified size.</span></div>
<div class="calibre624"><span>As a point of interest, you can create a generic functional interface that can be used with other types of classes, as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00942.jpg" class="calibre895"/></span></div>
<div class="calibre1"><span>For example, you could create an array of five <span class="bold1">Thread</span> objects like this:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00943.jpg" class="calibre896"/></span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre23"><span>One last point: In the case of creating a constructor reference for a generic class, you can specify the type parameter in the normal way, after the class name. For example, if <span class="bold1">MyGenClass</span> is declared like this:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00944.jpg" class="calibre897"/></span></div><div class="calibre11"> </div>
<div class="calibre27"><span>then the following creates a constructor reference with a type argument of <span class="bold1">Integer</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00945.jpg" class="calibre552"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Because of type inference, you won’t always need to specify the type argument, but you can when necessary.</span></div>
<div id="filepos1214229" class="calibre1"><span class="calibre10"><span><span class="bold1">Predefined Functional Interfaces</span></span></span></div>
<div class="calibre12"><span>Up to this point, the examples in this chapter have defined their own functional interfaces so that the fundamental concepts behind lambda expressions and functional interfaces could be clearly illustrated. In many cases, however, you won’t need to define your own functional interface because JDK 8 adds a new package called <span class="bold1">java.util.function</span> that provides several predefined ones. Here is a sampling:</span></div>
<div class="calibre11"> </div><table cellpadding="3" cellspacing="0" border="1" class="calibre37">
<tr class="calibre41">
<td valign="top" class="calibre83"><span class="bold1">Interface</span></td>
<td valign="top" class="calibre83"><span class="bold1">Purpose</span></td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">UnaryOperator&lt;T&gt;</td>
<td valign="top" class="calibre42">Apply a unary operation to an object of type <span class="bold1">T</span> and return the result, which is also of type <span class="bold1">T</span>. Its method is called <span class="bold1">apply( )</span>.</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">BinaryOperator&lt;T&gt;</td>
<td valign="top" class="calibre42">Apply an operation to two objects of type <span class="bold1">T</span> and return the result, which is also of type <span class="bold1">T</span>. Its method is called <span class="bold1">apply( )</span>.</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">Consumer&lt;T&gt;</td>
<td valign="top" class="calibre42">Apply an operation on an object of type <span class="bold1">T</span>. Its method is called <span class="bold1">accept( )</span>.</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">Supplier&lt;T&gt;</td>
<td valign="top" class="calibre42">Return an object of type <span class="bold1">T</span>. Its method is called <span class="bold1">get( )</span>.</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">Function&lt;T, R&gt;</td>
<td valign="top" class="calibre42">Apply an operation to an object of type <span class="bold1">T</span> and return the result as an object of type <span class="bold1">R</span>. Its method is called <span class="bold1">apply( )</span>.</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">Predicate&lt;T&gt;</td>
<td valign="top" class="calibre42">Determine if an object of type <span class="bold1">T</span> fulfills some constraint. Returns a <span class="bold1">boolean</span> value that indicates the outcome. Its method is called <span class="bold1">test( )</span>.</td>
</tr>
</table><div class="calibre43"> </div>
<div class="calibre23"><span>The following program shows the <span class="bold1">Predicate</span> interface in action. It uses <span class="bold1">Predicate</span> as the functional interface for a lambda expression the determines if a number is even. <span class="bold1">Predicate</span>’s abstract method is called <span class="bold1">test( )</span>, and it is shown here:</span></div>
<div class="calibre27"><span>boolean test(T <span class="italic">val</span>)</span></div>
<div class="calibre27"><span>It must return <span class="bold1">true</span> if <span class="italic">val</span> satisfies some constraint or condition. As it is used here, it will return <span class="bold1">true</span> if <span class="italic">val</span> is even.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00946.jpg" class="calibre223"/></span></div><div class="calibre11"> </div>
<div class="calibre29"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   At the start of this chapter, you mentioned that the inclusion of lambda expressions resulted in new capabilities being incorporated into the API library. Can you give me an example?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   </span>One of the most important enhancements to the Java API library added by JDK 8 is the new stream package <span class="bold1">java.util.stream</span>. This package defines several stream classes, the most general of which is <span class="bold1">Stream</span>. As it relates to <span class="bold1">java.util.stream</span>, a <span class="italic">stream</span> is a conduit for data. Thus, a stream represents a sequence of objects. Furthermore, a stream supports many types of operations that let you create a <span class="italic">pipeline</span> that performs a series of actions on the data. Often, these actions are represented by lambda expressions. For example, using the stream API, you can construct sequences of actions that resemble, in concept, the type of database queries for which you might use SQL. Furthermore, in many cases, such actions can be performed in parallel, thus providing a high level of efficiency, especially when large data sets are involved. Put simply, the stream API provides a powerful means of handling data in an efficient, yet easy to use way. One last point: although the streams supported by the new stream API have some similarities with the I/O streams described in <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_017.html#filepos823752">Chapter 10</a>, they are not the same.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre12"><span>The program produces the following output:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00947.jpg" class="calibre898"/></span></div><div class="calibre11"> </div>
<div id="filepos1220056" class="calibre44"><span class="calibre10"><span><img alt="image" src="images/00059.jpg" class="calibre104"/>   <span class="bold1"><span class="italic">Chapter 14 Self Test</span></span></span></span></div><div class="calibre11"> </div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1220337" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1575663">1</a></span>.  What is the lambda operator?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1220534" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1576004">2</a></span>.  What is a functional interface?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1220734" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1576387">3</a></span>.  How do functional interfaces and lambda expressions relate?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1220962" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1576870">4</a></span>.  What are the two general types of lambda expressions?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1221184" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1577451">5</a></span>.  Show a lambda expression that returns <span class="bold1">true</span> if a number is between 10 and 20, inclusive.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1221447" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1577870">6</a></span>.  Create a functional interface that can support the lambda expression you created in question 5. Call the interface <span class="bold1">MyTest</span> and its abstract method <span class="bold1">testing( )</span>.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1221787" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1578366">7</a></span>.  Create a block lambda that computes the factorial of an integer value. Demonstrate its use. Use <span class="bold1">NumericFunc</span>, shown in this chapter, for the functional interface.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1222124" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1578860">8</a></span>.  Create a generic functional interface called <span class="bold1">MyFunc&lt;T&gt;</span>. Call its abstract method <span class="bold1">func( )</span>. Have <span class="bold1">func( )</span> return a reference of type <span class="bold1">T</span>. Have it take a parameter of type <span class="bold1">T</span>. (Thus, <span class="bold1">MyFunc</span> will be a generic version of <span class="bold1">NumericFunc</span> shown in the chapter.) Demonstrate its use by rewriting your answer to question 7 so it uses <span class="bold1">MyFunc&lt;T&gt;</span> rather than <span class="bold1">NumericFunc</span>.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1222735" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1579619">9</a></span>.  Using the program shown in <a href="#filepos1178923">Try This 14-1</a>, create a lambda expression that removes all spaces from a string and returns the result. Demonstrate this method by passing it to <span class="bold1">changeStr( )</span>.</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1223107" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1580644">10</a></span>.  Can a lambda expression use a local variable? If so, what constraint must be met?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1223343" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1581032">11</a></span>.  If a lambda expression throws a checked exception, the abstract method in the functional interface must have a <span class="bold1">throws</span> clause that includes that exception. True or False?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1223674" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1581464">12</a></span>.  What is a method reference?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1223856" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1581813">13</a></span>.  When evaluated, a method reference creates an instance of the ____________ ___________ supplied by its target context.</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1224129" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1582203">14</a></span>.  Given a class called <span class="bold1">MyClass</span> that contains a <span class="bold1">static</span> method called <span class="bold1">myStaticMethod( )</span>, show how to specify a method reference to <span class="bold1">myStaticMethod( )</span>.</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1224457" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1582687">15</a></span>.  Given a class called <span class="bold1">MyClass</span> that contains an instance method called <span class="bold1">myInstMethod( )</span> and assuming an object of <span class="bold1">MyClass</span> called <span class="bold1">mcObj</span>, show how to create a method reference to <span class="bold1">myInstMethod( )</span> on <span class="bold1">mcObj</span>.</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1224853" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1583239">16</a></span>.  To the <span class="bold1">MethodRefDemo2</span> program, add a new method to <span class="bold1">MyIntNum</span> called <span class="bold1">hasCommonFactor( )</span>. Have it return <span class="bold1">true</span> if its <span class="bold1">int</span> argument and the value stored in the invoking <span class="bold1">MyIntNum</span> object have at least one factor in common. For example, 9 and 12 have a common factor, which is 3, but 9 and 16 have no common factor. Demonstrate <span class="bold1">hasCommonFactor( )</span> via a method reference.</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1225419" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1584444">17</a></span>.  How is a constructor reference specified?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1225615" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1584880">18</a></span>.  Java defines several predefined functional interfaces in what package?</span></div>  <div class="mbppagebreak" id="calibre_pb_21"></div>
</body></html>
