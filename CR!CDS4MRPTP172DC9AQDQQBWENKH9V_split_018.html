<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Java&amp;#8482;: A Beginner&amp;#8217;s Guide Sixth Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="filepos916252" class="calibre29"><span><img alt="image" src="images/00003.jpg" class="calibre30"/></span></div><div class="calibre11"> </div>
<div class="calibre31"><span class="calibre2"><span><big class="calibre3"><big class="calibre4"><big class="calibre5"><big class="calibre6"><big class="calibre32"><big class="calibre4">Chapter 11</big></big></big></big></big></big></span></span></div>
<div class="calibre9"><span class="calibre2"><span>Multithreaded Programming</span></span></div><div class="calibre33"> </div>
<div class="calibre1"><span class="calibre10"><span><span class="bold1">Key Skills &amp; Concepts</span></span></span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Understand multithreading fundamentals</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Know the <span class="bold1">Thread</span> class and the <span class="bold1">Runnable</span> interface</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Create a thread</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Create multiple threads</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Determine when a thread ends</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Use thread priorities</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Understand thread synchronization</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Use synchronized methods</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Use synchronized blocks</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Communicate between threads</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Suspend, resume, and stop threads</span></div>
<div class="calibre1"><span><img alt="image" src="images/00004.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre12"><span><span class="bold1"><span><span class="calibre2">A</span></span></span>lthough Java contains many innovative features, one of its most exciting is its built-in support for <span class="italic">multithreaded programming</span>. A multithreaded program contains two or more parts that can run concurrently. Each part of such a program is called a <span class="italic">thread</span>, and each thread defines a separate path of execution. Thus, multithreading is a specialized form of multitasking.</span></div>
<div id="filepos919577" class="calibre1"><span class="calibre10"><span><span class="bold1">Multithreading Fundamentals</span></span></span></div>
<div class="calibre12"><span>There are two distinct types of multitasking: process-based and thread-based. It is important to understand the difference between the two. A process is, in essence, a program that is executing. Thus, <span class="italic">process-based</span> multitasking is the feature that allows your computer to run two or more programs concurrently. For example, it is process-based multitasking that allows you to run the Java compiler at the same time you are using a text editor or browsing the Internet. In process-based multitasking, a program is the smallest unit of code that can be dispatched by the scheduler.</span></div>
<div class="calibre23"><span>In a <span class="italic">thread-based</span> multitasking environment, the thread is the smallest unit of dispatchable code. This means that a single program can perform two or more tasks at once. For instance, a text editor can be formatting text at the same time that it is printing, as long as these two actions are being performed by two separate threads. Although Java programs make use of process-based multitasking environments, process-based multitasking is not under the control of Java. Multithreaded multitasking is.</span></div>
<div class="calibre23"><span>A principal advantage of multithreading is that it enables you to write very efficient programs because it lets you utilize the idle time that is present in most programs. As you probably know, most I/O devices, whether they be network ports, disk drives, or the keyboard, are much slower than the CPU. Thus, a program will often spend a majority of its execution time waiting to send or receive information to or from a device. By using multithreading, your program can execute another task during this idle time. For example, while one part of your program is sending a file over the Internet, another part can be reading keyboard input, and still another can be buffering the next block of data to send.</span></div>
<div class="calibre23"><span>As you probably know, over the past few years, multiprocessor and multicore systems have become commonplace. Of course, single-processor systems are still in widespread use. It is important to understand that Java’s multithreading features work in both types of systems. In a single-core system, concurrently executing threads share the CPU, with each thread receiving a slice of CPU time. Therefore, in a single-core system, two or more threads do not actually run at the same time, but idle CPU time is utilized. However, in multiprocessor/multicore systems, it is possible for two or more threads to actually execute simultaneously. In many cases, this can further improve program efficiency and increase the speed of certain operations.</span></div>
<div class="calibre23"><span>A thread can be in one of several states. It can be <span class="italic">running</span>. It can be <span class="italic">ready to run</span> as soon as it gets CPU time. A running thread can be <span class="italic">suspended</span>, which is a temporary halt to its execution. It can later be <span class="italic">resumed</span>. A thread can be <span class="italic">blocked</span> when waiting for a resource. A thread can be <span class="italic">terminated</span>, in which case its execution ends and cannot be resumed.</span></div>
<div class="calibre23"><span>Along with thread-based multitasking comes the need for a special type of feature called <span class="italic">synchronization</span>, which allows the execution of threads to be coordinated in certain well-defined ways. Java has a complete subsystem devoted to synchronization, and its key features are also described here.</span></div>
<div class="calibre23"><span>If you have programmed for operating systems such as Windows, then you are already familiar with multithreaded programming. However, the fact that Java manages threads through language elements makes multithreading especially convenient. Many of the details are handled for you.</span></div>
<div id="filepos923735" class="calibre1"><span class="calibre10"><span><span class="bold1">The Thread Class and Runnable Interface</span></span></span></div>
<div class="calibre12"><span>Java’s multithreading system is built upon the <span class="bold1">Thread</span> class and its companion interface, <span class="bold1">Runnable</span>. Both are packaged in <span class="bold1">java.lang</span>. <span class="bold1">Thread</span> encapsulates a thread of execution. To create a new thread, your program will either extend <span class="bold1">Thread</span> or implement the <span class="bold1">Runnable</span> interface.</span></div>
<div class="calibre23"><span>The <span class="bold1">Thread</span> class defines several methods that help manage threads. Here are some of the more commonly used ones (we will be looking at these more closely as they are used):</span></div>
<div class="calibre11"> </div><table cellpadding="3" cellspacing="0" border="1" class="calibre37">
<tr class="calibre41">
<td valign="top" class="calibre83"><span class="bold1">Method</span></td>
<td valign="top" class="calibre83"><span class="bold1">Meaning</span></td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">final String getName( )</td>
<td valign="top" class="calibre42">Obtains a thread’s name.</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">final int getPriority( )</td>
<td valign="top" class="calibre42">Obtains a thread’s priority.</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">final boolean isAlive( )</td>
<td valign="top" class="calibre42">Determines whether a thread is still running.</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">final void join( )</td>
<td valign="top" class="calibre42">Waits for a thread to terminate.</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">void run( )</td>
<td valign="top" class="calibre42">Entry point for the thread.</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">static void sleep(long <span class="italic">milliseconds</span>)</td>
<td valign="top" class="calibre42">Suspends a thread for a specified period of milliseconds.</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">void start( )</td>
<td valign="top" class="calibre42">Starts a thread by calling its run( ) method.</td></tr></table><div class="calibre43"> </div>
<div class="calibre23"><span>All processes have at least one thread of execution, which is usually called the <span class="italic">main thread</span>, because it is the one that is executed when your program begins. Thus, the main thread is the thread that all of the preceding example programs in the book have been using. From the main thread, you can create other threads.</span></div>
<div id="filepos926746" class="calibre1"><span class="calibre10"><span><span class="bold1">Creating a Thread</span></span></span></div>
<div class="calibre12"><span>You create a thread by instantiating an object of type <span class="bold1">Thread</span>. The <span class="bold1">Thread</span> class encapsulates an object that is runnable. As mentioned, Java defines two ways in which you can create a runnable object:</span></div>
<div class="calibre24"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   You can implement the <span class="bold1">Runnable</span> interface.</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   You can extend the <span class="bold1">Thread</span> class.</span></div>
<div class="calibre592"><span>Most of the examples in this chapter will use the approach that implements <span class="bold1">Runnable</span>. However, <a href="#filepos938299">Try This 11-1</a> shows how to implement a thread by extending <span class="bold1">Thread</span>. Remember: Both approaches still use the <span class="bold1">Thread</span> class to instantiate, access, and control the thread. The only difference is how a thread-enabled class is created.</span></div>
<div class="calibre23"><span>The <span class="bold1">Runnable</span> interface abstracts a unit of executable code. You can construct a thread on any object that implements the <span class="bold1">Runnable</span> interface. <span class="bold1">Runnable</span> defines only one method called <span class="bold1">run( )</span>, which is declared like this:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00679.jpg" class="calibre562"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Inside <span class="bold1">run( )</span>, you will define the code that constitutes the new thread. It is important to understand that <span class="bold1">run( )</span> can call other methods, use other classes, and declare variables just like the main thread. The only difference is that <span class="bold1">run( )</span> establishes the entry point for another, concurrent thread of execution within your program. This thread will end when <span class="bold1">run( )</span> returns.</span></div>
<div class="calibre23"><span>After you have created a class that implements <span class="bold1">Runnable</span>, you will instantiate an object of type <span class="bold1">Thread</span> on an object of that class. <span class="bold1">Thread</span> defines several constructors. The one that we will use first is shown here:</span></div>
<div class="calibre27"><span>Thread(Runnable <span class="italic">threadOb</span>)</span></div>
<div class="calibre27"><span>In this constructor, <span class="italic">threadOb</span> is an instance of a class that implements the <span class="bold1">Runnable</span> interface. This defines where execution of the thread will begin.</span></div>
<div class="calibre23"><span>Once created, the new thread will not start running until you call its <span class="bold1">start( )</span> method, which is declared within <span class="bold1">Thread</span>. In essence, <span class="bold1">start( )</span> executes a call to <span class="bold1">run( )</span>. The <span class="bold1">start( )</span> method is shown here:</span></div>
<div class="calibre27"><span>void start( )</span></div>
<div class="calibre592"><span>Here is an example that creates a new thread and starts it running:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00680.jpg" class="calibre681"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00681.jpg" class="calibre682"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Let’s look closely at this program. First, <span class="bold1">MyThread</span> implements <span class="bold1">Runnable</span>. This means that an object of type <span class="bold1">MyThread</span> is suitable for use as a thread and can be passed to the <span class="bold1">Thread</span> constructor.</span></div>
<div class="calibre23"><span>Inside <span class="bold1">run( )</span>, a loop is established that counts from 0 to 9. Notice the call to <span class="bold1">sleep( )</span>. The <span class="bold1">sleep( )</span> method causes the thread from which it is called to suspend execution for the specified period of milliseconds. Its general form is shown here:</span></div>
<div class="calibre27"><span>static void sleep(long <span class="italic">milliseconds</span>) throws InterruptedException</span></div>
<div class="calibre27"><span>The number of milliseconds to suspend is specified in <span class="italic">milliseconds</span>. This method can throw an <span class="bold1">InterruptedException</span>. Thus, calls to it must be wrapped in a <span class="bold1">try</span> block. The <span class="bold1">sleep( )</span> method also has a second form, which allows you to specify the period in terms of milliseconds and nanoseconds if you need that level of precision. In <span class="bold1">run( )</span>, <span class="bold1">sleep( )</span> pauses the thread for 400 milliseconds each time through the loop. This lets the thread run slow enough for you to watch it execute.</span></div>
<div class="calibre23"><span>Inside <span class="bold1">main( )</span>, a new <span class="bold1">Thread</span> object is created by the following sequence of statements:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00682.jpg" class="calibre683"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>As the comments suggest, first an object of <span class="bold1">MyThread</span> is created. This object is then used to construct a <span class="bold1">Thread</span> object. This is possible because <span class="bold1">MyThread</span> implements <span class="bold1">Runnable</span>. Finally, execution of the new thread is started by calling <span class="bold1">start( )</span>. This causes the child thread’s <span class="bold1">run( )</span> method to begin. After calling <span class="bold1">start( )</span>, execution returns to <span class="bold1">main( )</span>, and it enters <span class="bold1">main( )</span>’s <span class="bold1">for</span> loop. Notice that this loop iterates 50 times, pausing 100 milliseconds each time through the loop. Both threads continue running, sharing the CPU in single-CPU systems, until their loops finish. The output produced by this program is as follows. Because of differences between computing environments, the precise output that you see may differ slightly from that shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00683.jpg" class="calibre684"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>There is another point of interest to notice in this first threading example. To illustrate the fact that the main thread and <span class="bold1">mt</span> execute concurrently, it is necessary to keep <span class="bold1">main( )</span> from terminating until <span class="bold1">mt</span> is finished. Here, this is done through the timing differences between the two threads. Because the calls to <span class="bold1">sleep( )</span> inside <span class="bold1">main( )</span>’s <span class="bold1">for</span> loop cause a total delay of 5 seconds (50 iterations times 100 milliseconds), but the total delay within <span class="bold1">run( )</span>’s loop is only 4 seconds (10 iterations times 400 milliseconds), <span class="bold1">run( )</span> will finish approximately 1 second before <span class="bold1">main( )</span>. As a result, both the main thread and <span class="bold1">mt</span> will execute concurrently until <span class="bold1">mt</span> ends. Then, about 1 second later <span class="bold1">main( )</span> ends.</span></div>
<div class="calibre23"><span>Although this use of timing differences to ensure that <span class="bold1">main( )</span> finishes last is sufficient for this simple example, it is not something that you would normally use in practice. Java provides much better ways of waiting for a thread to end. It is, however, sufficient for the next few programs. Later in this chapter, you will see a better way for one thread to wait until another completes.</span></div>
<div class="calibre23"><span>One other point: In a multithreaded program, you often will want the main thread to be the last thread to finish running. As a general rule, a program continues to run until all of its threads have ended. Thus, having the main thread finish last is not a requirement. It is, however, often a good practice to follow—especially when you are first learning about threads.</span></div>
<div id="filepos934855" class="calibre1"><span class="calibre10"><span><span class="bold1">Some Simple Improvements</span></span></span></div>
<div class="calibre12"><span>While the preceding program is perfectly valid, some simple improvements will make it more efficient and easier to use. First, it is possible to have a thread begin execution as soon as it is created. In the case of <span class="bold1">MyThread</span>, this is done by instantiating a <span class="bold1">Thread</span> object inside <span class="bold1">MyThread</span>’s constructor. Second, there is no need for <span class="bold1">MyThread</span> to store the name of the thread since it is possible to give a name to a thread when it is created. To do so, use this version of <span class="bold1">Thread</span>’s constructor:</span></div>
<div class="calibre27"><span>Thread(Runnable <span class="italic">threadOb</span>, String <span class="italic">name</span>)</span></div>
<div class="calibre27"><span>Here, <span class="italic">name</span> becomes the name of the thread.</span></div>
<div class="calibre35"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   You state that in a multithreaded program, one will often want the main thread to finish last. Can you explain?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   The main thread is a convenient place to perform the orderly shutdown of your program, such as the closing of files. It also provides a well-defined exit point for your program. Therefore, it often makes sense for it to finish last. Fortunately, as you will soon see, it is trivially easy for the main thread to wait until the child threads have completed.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre23"><span>You can obtain the name of a thread by calling <span class="bold1">getName( )</span> defined by <span class="bold1">Thread</span>. Its general form is shown here:</span></div>
<div class="calibre27"><span>final String getName( )</span></div>
<div class="calibre592"><span>Although not needed by the following program, you can set the name of a thread after it is created by using <span class="bold1">setName( )</span>, which is shown here:</span></div>
<div class="calibre27"><span>final void setName(String <span class="italic">threadName</span>)</span></div>
<div class="calibre27"><span>Here, <span class="italic">threadName</span> specifies the name of the thread.</span></div>
<div class="calibre23"><span>Here is the improved version of the preceding program:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00684.jpg" class="calibre685"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>This version produces the same output as before. Notice that the thread is stored in <span class="bold1">thrd</span> inside <span class="bold1">MyThread</span>.</span></div>
<div class="calibre18"> </div><table cellspacing="0" cellpadding="0" class="calibre37">
<colgroup class="calibre38">
<col class="calibre72"/>
<col class="calibre73"/>
</colgroup>
<tr class="calibre41">
<td valign="top" id="filepos938299" class="calibre74"><span class="calibre10"><span class="bold1">Try This 11-1</span> </span></td>
<td valign="top" class="calibre75"><span class="calibre10">Extending Thread</span></td>
</tr></table><div class="calibre43"> </div>
<div class="calibre1"><span><img alt="image" src="images/00685.jpg" class="calibre686"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Implementing <span class="bold1">Runnable</span> is one way to create a class that can instantiate thread objects. Extending <span class="bold1">Thread</span> is the other. In this project, you will see how to extend <span class="bold1">Thread</span> by creating a program functionally identical to the <span class="bold1">UseThreadsImproved</span> program.</span></div>
<div class="calibre23"><span>When a class extends <span class="bold1">Thread</span>, it must override the <span class="bold1">run( )</span> method, which is the entry point for the new thread. It must also call <span class="bold1">start( )</span> to begin execution of the new thread. It is possible to override other <span class="bold1">Thread</span> methods, but doing so is not required.</span></div>
<div class="calibre19"><span>  <span class="bold1">1.</span>  Create a file called <span class="bold1">ExtendThread.java</span>. Into this file, copy the code from the second threading example (<span class="bold1">UseThreadsImproved.java</span>).</span></div>
<div class="calibre47"><span>  <span class="bold1">2.</span>  Change the declaration of <span class="bold1">MyThread</span> so that it extends <span class="bold1">Thread</span> rather than implementing <span class="bold1">Runnable</span>, as shown here:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00686.jpg" class="calibre687"/></span></div>
<div class="calibre47"><span>  <span class="bold1">3.</span>  Remove this line:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00687.jpg" class="calibre149"/></span></div>
<div class="calibre47"><span>        The <span class="bold1">thrd</span> variable is no longer needed, since <span class="bold1">MyThread</span> includes an instance of <span class="bold1">Thread</span> and can refer to itself.</span></div>
<div class="calibre47"><span>  <span class="bold1">4.</span>  Change the <span class="bold1">MyThread</span> constructor so that it looks like this:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00688.jpg" class="calibre688"/></span></div>
<div class="calibre47"><span>        As you can see, first <span class="bold1">super</span> is used to call this version of <span class="bold1">Thread</span>’s constructor:</span></div>
<div class="calibre47"><span>        Thread(String <span class="italic">name</span>);</span></div>
<div class="calibre47"><span>        Here, <span class="italic">name</span> is the name of the thread.</span></div>
<div class="calibre47"><span>  <span class="bold1">5.</span>  Change <span class="bold1">run( )</span> so it calls <span class="bold1">getName( )</span> directly, without qualifying it with the <span class="bold1">thrd</span> variable. It should look like this:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00689.jpg" class="calibre689"/></span></div>
<div class="calibre47"><span>  <span class="bold1">6.</span>  Here is the completed program that now extends <span class="bold1">Thread</span> rather than implementing <span class="bold1">Runnable</span>. The output is the same as before.</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00690.jpg" class="calibre690"/></span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos942878" class="calibre9"><span class="calibre10"><span><span class="bold1">Creating Multiple Threads</span></span></span></div>
<div class="calibre12"><span>The preceding examples have created only one child thread. However, your program can spawn as many threads as it needs. For example, the following program creates three child threads:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00691.jpg" class="calibre525"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Sample output from this program follows:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00692.jpg" class="calibre691"/></span></div><div class="calibre11"> </div>
<div class="calibre29"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   Why does Java have two ways to create child threads (by extending</span> Thread <span class="bold1">or implementing</span> Runnable<span class="bold1">) and which approach is better?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   The <span class="bold1">Thread</span> class defines several methods that can be overridden by a derived class. Of these methods, the only one that must be overridden is <span class="bold1">run( )</span>. This is, of course, the same method required when you implement <span class="bold1">Runnable</span>. Some Java programmers feel that classes should be extended only when they are being enhanced or modified in some way. So, if you will not be overriding any of <span class="bold1">Thread</span>’s other methods, it is probably best to simply implement <span class="bold1">Runnable</span>. Also, by implementing <span class="bold1">Runnable</span>, you enable your thread to inherit a class other than <span class="bold1">Thread</span>.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre1"><span><img alt="image" src="images/00693.jpg" class="calibre692"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>As you can see, once started, all three child threads share the CPU. Notice that the threads are started in the order in which they are created. However, this may not always be the case. Java is free to schedule the execution of threads in its own way. Of course, because of differences in timing or environment, the precise output from the program may differ, so don’t be surprised if you see slightly different results when you try the program.</span></div>
<div id="filepos945726" class="calibre1"><span class="calibre10"><span><span class="bold1">Determining When a Thread Ends</span></span></span></div>
<div class="calibre12"><span>It is often useful to know when a thread has ended. For example, in the preceding examples, for the sake of illustration it was helpful to keep the main thread alive until the other threads ended. In those examples, this was accomplished by having the main thread sleep longer than the child threads that it spawned. This is, of course, hardly a satisfactory or generalizable solution!</span></div>
<div class="calibre23"><span>Fortunately, <span class="bold1">Thread</span> provides two means by which you can determine if a thread has ended. First, you can call <span class="bold1">isAlive( )</span> on the thread. Its general form is shown here:</span></div>
<div class="calibre27"><span>final boolean isAlive( )</span></div>
<div class="calibre27"><span>The <span class="bold1">isAlive( )</span> method returns <span class="bold1">true</span> if the thread upon which it is called is still running. It returns <span class="bold1">false</span> otherwise. To try <span class="bold1">isAlive( )</span>, substitute this version of <span class="bold1">MoreThreads</span> for the one shown in the preceding program:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00694.jpg" class="calibre693"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>This version produces output that is similar to the previous version, except that <span class="bold1">main( )</span> ends as soon as the other threads finish. The difference is that it uses <span class="bold1">isAlive( )</span> to wait for the child threads to terminate. Another way to wait for a thread to finish is to call <span class="bold1">join( )</span>, shown here:</span></div>
<div class="calibre27"><span>final void join( ) throws InterruptedException</span></div>
<div class="calibre27"><span>This method waits until the thread on which it is called terminates. Its name comes from the concept of the calling thread waiting until the specified thread <span class="italic">joins</span> it. Additional forms of <span class="bold1">join( )</span> allow you to specify a maximum amount of time that you want to wait for the specified thread to terminate.</span></div>
<div class="calibre23"><span>Here is a program that uses <span class="bold1">join( )</span> to ensure that the main thread is the last to stop:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00695.jpg" class="calibre694"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Sample output from this program is shown here. Remember that when you try the program, your precise output may vary slightly.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00696.jpg" class="calibre695"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>As you can see, after the calls to <span class="bold1">join( )</span> return, the threads have stopped executing.</span></div>
<div id="filepos948776" class="calibre1"><span class="calibre10"><span><span class="bold1">Thread Priorities</span></span></span></div>
<div class="calibre12"><span>Each thread has associated with it a priority setting. A thread’s priority determines, in part, how much CPU time a thread receives relative to the other active threads. In general, over a given period of time, low-priority threads receive little. High-priority threads receive a lot. As you might expect, how much CPU time a thread receives has profound impact on its execution characteristics and its interaction with other threads currently executing in the system.</span></div>
<div class="calibre23"><span>It is important to understand that factors other than a thread’s priority also affect how much CPU time a thread receives. For example, if a high-priority thread is waiting on some resource, perhaps for keyboard input, then it will be blocked, and a lower priority thread will run. However, when that high-priority thread gains access to the resource, it can preempt the low-priority thread and resume execution. Another factor that affects the scheduling of threads is the way the operating system implements multitasking. (See “Ask the Expert” at the end of this section.) Thus, just because you give one thread a high priority and another a low priority does not necessarily mean that one thread will run faster or more often than the other. It’s just that the high-priority thread has greater potential access to the CPU.</span></div>
<div class="calibre23"><span>When a child thread is started, its priority setting is equal to that of its parent thread. You can change a thread’s priority by calling <span class="bold1">setPriority( )</span>, which is a member of <span class="bold1">Thread</span>. This is its general form:</span></div>
<div class="calibre27"><span>final void setPriority(int <span class="italic">level</span>)</span></div>
<div class="calibre27"><span>Here, <span class="italic">level</span> specifies the new priority setting for the calling thread. The value of <span class="italic">level</span> must be within the range <span class="bold1">MIN_PRIORITY</span> and <span class="bold1">MAX_PRIORITY</span>. Currently, these values are 1 and 10, respectively. To return a thread to default priority, specify <span class="bold1">NORM_PRIORITY</span>, which is currently 5. These priorities are defined as <span class="bold1">static final</span> variables within <span class="bold1">Thread</span>.</span></div>
<div class="calibre23"><span>You can obtain the current priority setting by calling the <span class="bold1">getPriority( )</span> method of <span class="bold1">Thread</span>, shown here:</span></div>
<div class="calibre27"><span>final int getPriority( )</span></div>
<div class="calibre592"><span>The following example demonstrates two threads at different priorities. The threads are created as instances of <span class="bold1">Priority</span>. The <span class="bold1">run( )</span> method contains a loop that counts the number of iterations. The loop stops when either the count reaches 10,000,000 or the static variable <span class="bold1">stop</span> is <span class="bold1">true</span>. Initially, <span class="bold1">stop</span> is set to <span class="bold1">false</span>, but the first thread to finish counting sets <span class="bold1">stop</span> to <span class="bold1">true</span>. This causes the second thread to terminate with its next time slice. Each time through the loop the string in <span class="bold1">currentName</span> is checked against the name of the executing thread. If they don’t match, it means that a task-switch occurred. Each time a task-switch happens, the name of the new thread is displayed, and <span class="bold1">currentName</span> is given the name of the new thread. Displaying each thread switch allows you to watch (in a very imprecise way) when the threads gain access to the CPU. After both threads stop, the number of iterations for each loop is displayed.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00697.jpg" class="calibre696"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00698.jpg" class="calibre697"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00699.jpg" class="calibre698"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Here is a sample run on a single-core system:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00700.jpg" class="calibre699"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>In this run, the high-priority thread got a vast majority of the CPU time. Of course, the exact output produced by this program will depend upon the speed of your CPU, the number of CPUs in your system, the operating system you are using, and the number of other tasks running in the system.</span></div>
<div class="calibre35"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   Does the operating system’s implementation of multitasking affect how much CPU time a thread receives?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   Aside from a thread’s priority setting, the most important factor affecting thread execution is the way the operating system implements multitasking and scheduling. Some operating systems use preemptive multitasking in which each thread receives a time slice, at least occasionally. Other systems use nonpreemptive scheduling in which one thread must yield execution before another thread will execute. In nonpreemptive systems, it is easy for one thread to dominate, preventing others from running.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos954911" class="calibre9"><span class="calibre10"><span><span class="bold1">Synchronization</span></span></span></div>
<div class="calibre12"><span>When using multiple threads, it is sometimes necessary to coordinate the activities of two or more. The process by which this is achieved is called <span class="italic">synchronization</span>. The most common reason for synchronization is when two or more threads need access to a shared resource that can be used by only one thread at a time. For example, when one thread is writing to a file, a second thread must be prevented from doing so at the same time. Another reason for synchronization is when one thread is waiting for an event that is caused by another thread. In this case, there must be some means by which the first thread is held in a suspended state until the event has occurred. Then, the waiting thread must resume execution.</span></div>
<div class="calibre23"><span>Key to synchronization in Java is the concept of the <span class="italic">monitor</span>, which controls access to an object. A monitor works by implementing the concept of a <span class="italic">lock</span>. When an object is locked by one thread, no other thread can gain access to the object. When the thread exits, the object is unlocked and is available for use by another thread.</span></div>
<div class="calibre23"><span>All objects in Java have a monitor. This feature is built into the Java language, itself. Thus, all objects can be synchronized. Synchronization is supported by the keyword <span class="bold1">synchronized</span> and a few well-defined methods that all objects have. Since synchronization was designed into Java from the start, it is much easier to use than you might first expect. In fact, for many programs, the synchronization of objects is almost transparent.</span></div>
<div class="calibre23"><span>There are two ways that you can synchronize your code. Both involve the use of the <span class="bold1">synchronized</span> keyword, and both are examined here.</span></div>
<div id="filepos956962" class="calibre1"><span class="calibre10"><span><span class="bold1">Using Synchronized Methods</span></span></span></div>
<div class="calibre12"><span>You can synchronize access to a method by modifying it with the <span class="bold1">synchronized</span> keyword. When that method is called, the calling thread enters the object’s monitor, which then locks the object. While locked, no other thread can enter the method, or enter any other synchronized method defined by the object’s class. When the thread returns from the method, the monitor unlocks the object, allowing it to be used by the next thread. Thus, synchronization is achieved with virtually no programming effort on your part.</span></div>
<div class="calibre23"><span>The following program demonstrates synchronization by controlling access to a method called <span class="bold1">sumArray( )</span>, which sums the elements of an integer array.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00701.jpg" class="calibre700"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00702.jpg" class="calibre701"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00703.jpg" class="calibre702"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>The output from the program is shown here. (The precise output may differ on your computer.)</span></div>
<div class="calibre1"><span><img alt="image" src="images/00704.jpg" class="calibre703"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Let’s examine this program in detail. The program creates three classes. The first is <span class="bold1">SumArray</span>. It contains the method <span class="bold1">sumArray( )</span>, which sums an integer array. The second class is <span class="bold1">MyThread</span>, which uses a <span class="bold1">static</span> object of type <span class="bold1">SumArray</span> to obtain the sum of an integer array. This object is called <span class="bold1">sa</span> and because it is <span class="bold1">static</span>, there is only one copy of it that is shared by all instances of <span class="bold1">MyThread</span>. Finally, the class <span class="bold1">Sync</span> creates two threads and has each compute the sum of an integer array.</span></div>
<div class="calibre23"><span>Inside <span class="bold1">sumArray( )</span>, <span class="bold1">sleep( )</span> is called to purposely allow a task switch to occur, if one can—but it can’t. Because <span class="bold1">sumArray( )</span> is synchronized, it can be used by only one thread at a time. Thus, when the second child thread begins execution, it does not enter <span class="bold1">sumArray( )</span> until after the first child thread is done with it. This ensures that the correct result is produced.</span></div>
<div class="calibre23"><span>To fully understand the effects of <span class="bold1">synchronized</span>, try removing it from the declaration of <span class="bold1">sumArray( )</span>. After doing this, <span class="bold1">sumArray( )</span> is no longer synchronized, and any number of threads may use it concurrently. The problem with this is that the running total is stored in <span class="bold1">sum</span>, which will be changed by each thread that calls <span class="bold1">sumArray( )</span> through the <span class="bold1">static</span> object <span class="bold1">sa</span>. Thus, when two threads call <span class="bold1">sa.sumArray( )</span> at the same time, incorrect results are produced because <span class="bold1">sum</span> reflects the summation of both threads, mixed together. For example, here is sample output from the program after <span class="bold1">synchronized</span> has been removed from <span class="bold1">sumArray( )</span>’s declaration. (The precise output may differ on your computer.)</span></div>
<div class="calibre1"><span><img alt="image" src="images/00705.jpg" class="calibre704"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>As the output shows, both child threads are calling <span class="bold1">sa.sumArray( )</span> concurrently, and the value of <span class="bold1">sum</span> is corrupted. Before moving on, let’s review the key points of a synchronized method:</span></div>
<div class="calibre24"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   A synchronized method is created by preceding its declaration with <span class="bold1">synchronized</span>.</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   For any given object, once a synchronized method has been called, the object is locked and no synchronized methods on the same object can be used by another thread of execution.</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Other threads trying to call an in-use synchronized object will enter a wait state until the object is unlocked.</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   When a thread leaves the synchronized method, the object is unlocked.</span></div>
<div id="filepos962130" class="calibre1"><span class="calibre10"><span><span class="bold1">The synchronized Statement</span></span></span></div>
<div class="calibre12"><span>Although creating <span class="bold1">synchronized</span> methods within classes that you create is an easy and effective means of achieving synchronization, it will not work in all cases. For example, you might want to synchronize access to some method that is not modified by <span class="bold1">synchronized</span>. This can occur because you want to use a class that was not created by you but by a third party, and you do not have access to the source code. Thus, it is not possible for you to add <span class="bold1">synchronized</span> to the appropriate methods within the class. How can access to an object of this class be synchronized? Fortunately, the solution to this problem is quite easy: You simply put calls to the methods defined by this class inside a <span class="bold1">synchronized</span> block.</span></div>
<div class="calibre23"><span>This is the general form of a <span class="bold1">synchronized</span> block:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00706.jpg" class="calibre705"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, <span class="italic">objref</span> is a reference to the object being synchronized. Once a synchronized block has been entered, no other thread can call a synchronized method on the object referred to by <span class="italic">objref</span> until the block has been exited.</span></div>
<div class="calibre23"><span>For example, another way to synchronize calls to <span class="bold1">sumArray( )</span> is to call it from within a synchronized block, as shown in this version of the program:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00707.jpg" class="calibre706"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00708.jpg" class="calibre707"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>This version produces the same, correct output as the one shown earlier that uses a synchronized method.</span></div>
<div class="calibre35"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   I have heard of something called the “concurrency utilities.” What are these? Also, what is the Fork/Join Framework?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   The concurrency utilities, which are packaged in <span class="bold1">java.util.concurrent</span> (and its subpackages), support concurrent programming. Among several other items, they offer synchronizers, thread pools, execution managers, and locks that expand your control over thread execution. One of the most exciting features of the concurrent API is the Fork/Join Framework.</span></div>
<div class="calibre624"><span>The Fork/Join Framework supports what is often termed <span class="italic">parallel programming</span>. This is the name commonly given to the techniques that take advantage of computers that contain two or more processors (including multicore systems) by subdividing a task into subtasks, with each subtask executing on its own processor. As you can imagine, such an approach can lead to significantly higher throughput and performance. The key advantage of the Fork/Join Framework is ease of use; it streamlines the development of multithreaded code that automatically scales to utilize the number of processors in a system. Thus, it facilitates the creation of concurrent solutions to some common programming tasks, such as performing operations on the elements of an array. The concurrency utilities in general, and the Fork/Join Framework specifically, are features that you will want to explore after you have become more experienced with multithreading.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos966495" class="calibre9"><span class="calibre10"><span><span class="bold1">Thread Communication Using notify( ), wait( ), and notifyAll( )</span></span></span></div>
<div class="calibre12"><span>Consider the following situation. A thread called T is executing inside a synchronized method and needs access to a resource called R that is temporarily unavailable. What should T do? If T enters some form of polling loop that waits for R, T ties up the object, preventing other threads’ access to it. This is a less than optimal solution because it partially defeats the advantages of programming for a multithreaded environment. A better solution is to have T temporarily relinquish control of the object, allowing another thread to run. When R becomes available, T can be notified and resume execution. Such an approach relies upon some form of interthread communication in which one thread can notify another that it is blocked and be notified that it can resume execution. Java supports interthread communication with the <span class="bold1">wait( )</span>, <span class="bold1">notify( )</span>, and <span class="bold1">notifyAll( )</span> methods.</span></div>
<div class="calibre23"><span>The <span class="bold1">wait( )</span>, <span class="bold1">notify( )</span>, and <span class="bold1">notifyAll( )</span> methods are part of all objects because they are implemented by the <span class="bold1">Object</span> class. These methods should be called only from within a <span class="bold1">synchronized</span> context. Here is how they are used. When a thread is temporarily blocked from running, it calls <span class="bold1">wait( )</span>. This causes the thread to go to sleep and the monitor for that object to be released, allowing another thread to use the object. At a later point, the sleeping thread is awakened when some other thread enters the same monitor and calls <span class="bold1">notify( )</span>, or <span class="bold1">notifyAll( )</span>.</span></div>
<div class="calibre23"><span>Following are the various forms of <span class="bold1">wait( )</span> defined by <span class="bold1">Object</span>:</span></div>
<div class="calibre27"><span>final void wait( ) throws InterruptedException</span></div>
<div class="calibre27"><span>final void wait(long <span class="italic">millis</span>) throws InterruptedException</span></div>
<div class="calibre27"><span>final void wait(long <span class="italic">millis</span>, int <span class="italic">nanos</span>) throws InterruptedException</span></div>
<div class="calibre27"><span>The first form waits until notified. The second form waits until notified or until the specified period of milliseconds has expired. The third form allows you to specify the wait period in terms of nanoseconds.</span></div>
<div class="calibre23"><span>Here are the general forms for <span class="bold1">notify( )</span> and <span class="bold1">notifyAll( )</span>:</span></div>
<div class="calibre27"><span>final void notify( )</span></div>
<div class="calibre27"><span>final void notifyAll( )</span></div>
<div class="calibre27"><span>A call to <span class="bold1">notify( )</span> resumes one waiting thread. A call to <span class="bold1">notifyAll( )</span> notifies all threads, with the highest priority thread gaining access to the object.</span></div>
<div class="calibre23"><span>Before looking at an example that uses <span class="bold1">wait( )</span>, an important point needs to be made. Although <span class="bold1">wait( )</span> normally waits until <span class="bold1">notify( )</span> or <span class="bold1">notifyAll( )</span> is called, there is a possibility that in very rare cases the waiting thread could be awakened due to a <span class="italic">spurious wakeup</span>. The conditions that lead to a spurious wakeup are complex and beyond the scope of this book. However, Oracle recommends that because of the remote possibility of a spurious wakeup, calls to <span class="bold1">wait( )</span> should take place within a loop that checks the condition on which the thread is waiting. The following example shows this technique.</span></div>
<div id="filepos970367" class="calibre1"><span class="calibre10"><span><span class="bold1">An Example That Uses wait( ) and notify( )</span></span></span></div>
<div class="calibre12"><span>To understand the need for and the application of <span class="bold1">wait( )</span> and <span class="bold1">notify( )</span>, we will create a program that simulates the ticking of a clock by displaying the words Tick and Tock on the screen. To accomplish this, we will create a class called <span class="bold1">TickTock</span> that contains two methods: <span class="bold1">tick( )</span> and <span class="bold1">tock( )</span>. The <span class="bold1">tick( )</span> method displays the word "Tick", and <span class="bold1">tock( )</span> displays "Tock". To run the clock, two threads are created, one that calls <span class="bold1">tick( )</span> and one that calls <span class="bold1">tock( )</span>. The goal is to make the two threads execute in a way that the output from the program displays a consistent "Tick Tock"—that is, a repeated pattern of one tick followed by one tock.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00709.jpg" class="calibre708"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00710.jpg" class="calibre284"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00711.jpg" class="calibre709"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Here is the output produced by the program:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00712.jpg" class="calibre710"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Let’s take a close look at this program. The heart of the clock is the <span class="bold1">TickTock</span> class. It contains two methods, <span class="bold1">tick( )</span> and <span class="bold1">tock( )</span>, which communicate with each other to ensure that a Tick is always followed by a Tock, which is always followed by a Tick, and so on. Notice the <span class="bold1">state</span> field. When the clock is running, <span class="bold1">state</span> will hold either the string "ticked" or "tocked", which indicates the current state of the clock. In <span class="bold1">main( )</span>, a <span class="bold1">TickTock</span> object called <span class="bold1">tt</span> is created, and this object is used to start two threads of execution.</span></div>
<div class="calibre23"><span>The threads are based on objects of type <span class="bold1">MyThread</span>. The <span class="bold1">MyThread</span> constructor is passed two arguments. The first becomes the name of the thread. This will be either "Tick" or "Tock". The second is a reference to the <span class="bold1">TickTock</span> object, which is <span class="bold1">tt</span> in this case. Inside the <span class="bold1">run( )</span> method of <span class="bold1">MyThread</span>, if the name of the thread is "Tick", then calls to <span class="bold1">tick( )</span> are made. If the name of the thread is "Tock", then the <span class="bold1">tock( )</span> method is called. Five calls that pass <span class="bold1">true</span> as an argument are made to each method. The clock runs as long as <span class="bold1">true</span> is passed. A final call that passes <span class="bold1">false</span> to each method stops the clock.</span></div>
<div class="calibre23"><span>The most important part of the program is found in the <span class="bold1">tick( )</span> and <span class="bold1">tock( )</span> methods of <span class="bold1">TickTock</span>. We will begin with the <span class="bold1">tick( )</span> method, which, for convenience, is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00713.jpg" class="calibre711"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>First, notice that <span class="bold1">tick( )</span> is modified by <span class="bold1">synchronized</span>. Remember, <span class="bold1">wait( )</span> and <span class="bold1">notify( )</span> apply only to synchronized methods. The method begins by checking the value of the <span class="bold1">running</span> parameter. This parameter is used to provide a clean shutdown of the clock. If it is <span class="bold1">false</span>, then the clock has been stopped. If this is the case, <span class="bold1">state</span> is set to "ticked" and a call to <span class="bold1">notify( )</span> is made to enable any waiting thread to run. We will return to this point in a moment.</span></div>
<div class="calibre23"><span>Assuming that the clock is running when <span class="bold1">tick( )</span> executes, the word "Tick" is displayed, <span class="bold1">state</span> is set to "ticked", and then a call to <span class="bold1">notify( )</span> takes place. The call to <span class="bold1">notify( )</span> allows a thread waiting on the same object to run. Next, <span class="bold1">wait( )</span> is called within a <span class="bold1">while</span> loop. The call to <span class="bold1">wait( )</span> causes <span class="bold1">tick( )</span> to suspend until another thread calls <span class="bold1">notify( )</span>. Therefore, the loop will not iterate until another thread calls <span class="bold1">notify( )</span> on the same object. As a result, when <span class="bold1">tick( )</span> is called, it displays one "Tick", lets another thread run, and then suspends.</span></div>
<div class="calibre23"><span>The <span class="bold1">while</span> loop that calls <span class="bold1">wait( )</span> checks the value of <span class="bold1">state</span>, waiting for it to equal "tocked", which will be the case only after the <span class="bold1">tock( )</span> method executes. As explained, using a <span class="bold1">while</span> loop to check this condition prevents a spurious wakeup from incorrectly restarting the thread. If <span class="bold1">state</span> does not equal "tocked" when <span class="bold1">wait( )</span> returns, it means that a spurious wakeup occurred, and <span class="bold1">wait( )</span> is simply called again.</span></div>
<div class="calibre23"><span>The <span class="bold1">tock( )</span> method is an exact copy of <span class="bold1">tick( )</span> except that it displays "Tock" and sets <span class="bold1">state</span> to "tocked". Thus, when entered, it displays "Tock", calls <span class="bold1">notify( )</span>, and then waits. When viewed as a pair, a call to <span class="bold1">tick( )</span> can only be followed by a call to <span class="bold1">tock( )</span>, which can only be followed by a call to <span class="bold1">tick( )</span>, and so on. Therefore, the two methods are mutually synchronized.</span></div>
<div class="calibre23"><span>The reason for the call to <span class="bold1">notify( )</span> when the clock is stopped is to allow a final call to <span class="bold1">wait( )</span> to succeed. Remember, both <span class="bold1">tick( )</span> and <span class="bold1">tock( )</span> execute a call to <span class="bold1">wait( )</span> after displaying their message. The problem is that when the clock is stopped, one of the methods will still be waiting. Thus, a final call to <span class="bold1">notify( )</span> is required in order for the waiting method to run. As an experiment, try removing this call to <span class="bold1">notify( )</span> and watch what happens. As you will see, the program will “hang,” and you will need to press CTRL-C to exit. The reason for this is that when the final call to <span class="bold1">tock( )</span> calls <span class="bold1">wait( )</span>, there is no corresponding call to <span class="bold1">notify( )</span> that lets <span class="bold1">tock( )</span> conclude. Thus, <span class="bold1">tock( )</span> just sits there, waiting forever.</span></div>
<div class="calibre23"><span>Before moving on, if you have any doubt that the calls to <span class="bold1">wait( )</span> and <span class="bold1">notify( )</span> are actually needed to make the “clock” run right, substitute this version of <span class="bold1">TickTock</span> into the preceding program. It has all calls to <span class="bold1">wait( )</span> and <span class="bold1">notify( )</span> removed.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00714.jpg" class="calibre712"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>After the substitution, the output produced by the program will look like this:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00715.jpg" class="calibre713"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Clearly, the <span class="bold1">tick( )</span> and <span class="bold1">tock( )</span> methods are no longer working together!</span></div>
<div class="calibre35"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   I have heard the term <span class="italic">deadlock</span> applied to misbehaving multithreaded programs. What is it, and how can I avoid it? Also, what is a <span class="italic">race condition</span>, and how can I avoid that, too?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   Deadlock is, as the name implies, a situation in which one thread is waiting for another thread to do something, but that other thread is waiting on the first. Thus, both threads are suspended, waiting on each other, and neither executes. This situation is analogous to two overly polite people, both insisting that the other step through a door first!</span></div>
<div class="calibre624"><span>Avoiding deadlock seems easy, but it’s not. For example, deadlock can occur in roundabout ways. The cause of the deadlock often is not readily understood just by looking at the source code to the program because concurrently executing threads can interact in complex ways at run time. To avoid deadlock, careful programming and thorough testing is required. Remember, if a multithreaded program occasionally “hangs,” deadlock is the likely cause.</span></div>
<div class="calibre624"><span>A race condition occurs when two (or more) threads attempt to access a shared resource at the same time, without proper synchronization. For example, one thread may be writing a new value to a variable while another thread is incrementing the variable’s current value. Without synchronization, the new value of the variable will depend upon the order in which the threads execute. (Does the second thread increment the original value or the new value written by the first thread?) In situations like this, the two threads are said to be “racing each other,” with the final outcome determined by which thread finishes first. Like deadlock, a race condition can occur in difficult-to-discover ways. The solution is prevention: careful programming that properly synchronizes access to shared resources.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos980888" class="calibre9"><span class="calibre10"><span><span class="bold1">Suspending, Resuming, and Stopping Threads</span></span></span></div>
<div class="calibre12"><span>It is sometimes useful to suspend execution of a thread. For example, a separate thread can be used to display the time of day. If the user does not desire a clock, then its thread can be suspended. Whatever the case, it is a simple matter to suspend a thread. Once suspended, it is also a simple matter to restart the thread.</span></div>
<div class="calibre23"><span>The mechanisms to suspend, stop, and resume threads differ between early versions of Java and more modern versions, beginning with Java 2. Prior to Java 2, a program used <span class="bold1">suspend( )</span>, <span class="bold1">resume( )</span>, and <span class="bold1">stop( )</span>, which are methods defined by <span class="bold1">Thread</span>, to pause, restart, and stop the execution of a thread. They have the following forms:</span></div>
<div class="calibre27"><span>final void resume( )</span></div>
<div class="calibre27"><span>final void suspend( )</span></div>
<div class="calibre27"><span>final void stop( )</span></div>
<div class="calibre592"><span>While these methods seem to be a perfectly reasonable and convenient approach to managing the execution of threads, they must no longer be used. Here’s why. The <span class="bold1">suspend( )</span> method of the <span class="bold1">Thread</span> class was deprecated by Java 2. This was done because <span class="bold1">suspend( )</span> can sometimes cause serious problems that involve deadlock. The <span class="bold1">resume( )</span> method is also deprecated. It does not cause problems but cannot be used without the <span class="bold1">suspend( )</span> method as its counterpart. The <span class="bold1">stop( )</span> method of the <span class="bold1">Thread</span> class was also deprecated by Java 2. This was done because this method too can sometimes cause serious problems.</span></div>
<div class="calibre23"><span>Since you cannot now use the <span class="bold1">suspend( )</span>, <span class="bold1">resume( )</span>, or <span class="bold1">stop( )</span> methods to control a thread, you might at first be thinking that there is no way to pause, restart, or terminate a thread. But, fortunately, this is not true. Instead, a thread must be designed so that the <span class="bold1">run( )</span> method periodically checks to determine if that thread should suspend, resume, or stop its own execution. Typically, this is accomplished by establishing two flag variables: one for suspend and resume, and one for stop. For suspend and resume, as long as the flag is set to “running,” the <span class="bold1">run( )</span> method must continue to let the thread execute. If this variable is set to “suspend,” the thread must pause. For the stop flag, if it is set to “stop,” the thread must terminate.</span></div>
<div class="calibre23"><span>The following example shows one way to implement your own versions of <span class="bold1">suspend( )</span>, <span class="bold1">resume( )</span>, and <span class="bold1">stop( )</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00716.jpg" class="calibre714"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00717.jpg" class="calibre715"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00718.jpg" class="calibre716"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Sample output from this program is shown here. (Your output may differ slightly.)</span></div>
<div class="calibre1"><span><img alt="image" src="images/00719.jpg" class="calibre717"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Here is how the program works. The thread class <span class="bold1">MyThread</span> defines two Boolean variables, <span class="bold1">suspended</span> and <span class="bold1">stopped</span>, which govern the suspension and termination of a thread. Both are initialized to <span class="bold1">false</span> by the constructor. The <span class="bold1">run( )</span> method contains a <span class="bold1">synchronized</span> statement block that checks <span class="bold1">suspended</span>. If that variable is <span class="bold1">true</span>, the <span class="bold1">wait( )</span> method is invoked to suspend the execution of the thread. To suspend execution of the thread, call <span class="bold1">mysuspend( )</span>, which sets <span class="bold1">suspended</span> to <span class="bold1">true</span>. To resume execution, call <span class="bold1">myresume( )</span>, which sets <span class="bold1">suspended</span> to <span class="bold1">false</span> and invokes <span class="bold1">notify( )</span> to restart the thread.</span></div>
<div class="calibre23"><span>To stop the thread, call <span class="bold1">mystop( )</span>, which sets <span class="bold1">stopped</span> to <span class="bold1">true</span>. In addition, <span class="bold1">mystop( )</span> sets <span class="bold1">suspended</span> to <span class="bold1">false</span> and then calls <span class="bold1">notify( )</span>. These steps are necessary to stop a suspended thread.</span></div>
<div class="calibre35"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   Multithreading seems like a great way to improve the efficiency of my programs. Can you give me any tips on effectively using it?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   The key to effectively utilizing multithreading is to think concurrently rather than serially. For example, when you have two subsystems within a program that are fully independent of each other, consider making them into individual threads. A word of caution is in order, however. If you create too many threads, you can actually degrade the performance of your program rather than enhance it. Remember, overhead is associated with context switching. If you create too many threads, more CPU time will be spent changing contexts than in executing your program!</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre11"> </div><table cellspacing="0" cellpadding="0" class="calibre37">
<colgroup class="calibre38">
<col class="calibre72"/>
<col class="calibre73"/>
</colgroup>
<tr class="calibre41">
<td valign="top" id="filepos987254" class="calibre74"><span class="calibre10"><span class="bold1">Try This 11-2</span> </span></td>
<td valign="top" class="calibre75"><span class="calibre10">Using the Main Thread</span></td>
</tr></table><div class="calibre43"> </div>
<div class="calibre1"><span><img alt="image" src="images/00720.jpg" class="calibre718"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>All Java programs have at least one thread of execution, called the <span class="italic">main thread</span>, which is given to the program automatically when it begins running. So far, we have been taking the main thread for granted. In this project, you will see that the main thread can be handled just like all other threads.</span></div>
<div class="calibre19"><span>  <span class="bold1">1.</span>  Create a file called <span class="bold1">UseMain.java</span>.</span></div>
<div class="calibre47"><span>  <span class="bold1">2.</span>  To access the main thread, you must obtain a <span class="bold1">Thread</span> object that refers to it. You do this by calling the <span class="bold1">currentThread( )</span> method, which is a <span class="bold1">static</span> member of <span class="bold1">Thread</span>. Its general form is shown here:</span></div>
<div class="calibre47"><span>        static Thread currentThread( )</span></div>
<div class="calibre47"><span>        This method returns a reference to the thread in which it is called. Therefore, if you call <span class="bold1">currentThread( )</span> while execution is inside the main thread, you will obtain a reference to the main thread. Once you have this reference, you can control the main thread just like any other thread.</span></div>
<div class="calibre47"><span>  <span class="bold1">3.</span>  Enter the following program into the file. It obtains a reference to the main thread, and then gets and sets the main thread’s name and priority.</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00721.jpg" class="calibre719"/></span></div>
<div class="calibre47"><span>  <span class="bold1">4.</span>  The output from the program is shown here:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00722.jpg" class="calibre720"/></span></div>
<div class="calibre47"><span>  <span class="bold1">5.</span>  You need to be careful about what operations you perform on the main thread. For example, if you add the following code to the end of <span class="bold1">main( )</span>, the program will never terminate because it will be waiting for the main thread to end!</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00723.jpg" class="calibre721"/></span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos990755" class="calibre1"><span class="calibre10"><span><img alt="image" src="images/00059.jpg" class="calibre104"/>   <span class="bold1"><span class="italic">Chapter 11 Self Test</span></span></span></span></div><div class="calibre11"> </div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos991036" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1553920">1</a>.</span>  How does Java’s multithreading capability enable you to write more efficient programs?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos991298" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1554496">2</a>.</span>  Multithreading is supported by the _________ class and the ________ interface.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos991545" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1554932">3</a>.</span>  When creating a runnable object, why might you want to extend <span class="bold1">Thread</span> rather than implement <span class="bold1">Runnable</span>?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos991828" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1555439">4</a>.</span>  Show how to use <span class="bold1">join( )</span> to wait for a thread object called <span class="bold1">MyThrd</span> to end.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos992084" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1555851">5</a>.</span>  Show how to set a thread called <span class="bold1">MyThrd</span> to three levels above normal priority.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos992337" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1556260">6</a>.</span>  What is the effect of adding the <span class="bold1">synchronized</span> keyword to a method?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos992579" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1556723">7</a>.</span>  The <span class="bold1">wait( )</span> and <span class="bold1">notify( )</span> methods are used to perform _______________________.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos992840" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1557103">8</a>.</span>  Change the <span class="bold1">TickTock</span> class so that it actually keeps time. That is, have each tick take one half second, and each tock take one half second. Thus, each tick-tock will take one second. (Don’t worry about the time it takes to switch tasks, etc.)</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos993265" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1558046">9</a>.</span>  Why can’t you use <span class="bold1">suspend( )</span>, <span class="bold1">resume( )</span>, and <span class="bold1">stop( )</span> for new programs?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos993516" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1558532">10</a>.</span>  What method defined by <span class="bold1">Thread</span> obtains the name of a thread?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos993737" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1558867">11</a>.</span>  What does <span class="bold1">isAlive( )</span> return?</span></div>
<div class="calibre47"><span><span class="bold1">12.</span>  On your own, try adding synchronization to the <span class="bold1">Queue</span> class developed in previous chapters so that it is safe for multithreaded use.</span></div>  <div class="mbppagebreak" id="calibre_pb_18"></div>
</body></html>
