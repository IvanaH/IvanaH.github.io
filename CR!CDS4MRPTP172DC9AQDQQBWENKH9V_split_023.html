<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Java&amp;#8482;: A Beginner&amp;#8217;s Guide Sixth Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="filepos1300493" class="calibre29"><span><img alt="image" src="images/00003.jpg" class="calibre30"/></span></div><div class="calibre11"> </div>
<div class="calibre31"><span class="calibre2"><span><big class="calibre3"><big class="calibre4"><big class="calibre5"><big class="calibre6"><big class="calibre32"><big class="calibre4">Chapter 16</big></big></big></big></big></big></span></span></div>
<div class="calibre9"><span class="calibre2"><span>Introducing Swing</span></span></div><div class="calibre33"> </div>
<div class="calibre1"><span class="calibre10"><span><span class="bold1">Key Skills &amp; Concepts</span></span></span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Know the origins and design philosophy of Swing</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Understand Swing components and containers</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Know layout manager basics</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Create, compile, and run a simple Swing application</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Use <span class="bold1">JButton</span></span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Work with <span class="bold1">JTextField</span></span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Create a <span class="bold1">JCheckBox</span></span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Work with <span class="bold1">JList</span></span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Use anonymous inner classes or lambda expressions to handle events</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Create a Swing applet</span></div>
<div class="calibre1"><span><img alt="image" src="images/00004.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre12"><span><span><span class="calibre2">W</span></span>ith the exception of the applet examples shown in <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_022.html#filepos1225806">Chapter 15</a>, all of the programs in this book have been console-based. This means that they do not make use of a graphical user interface (GUI). Although console-based programs are excellent for teaching the basics of Java and for some types of programs, such as server-side code, most real-world applications will be GUI-based. At the time of this writing, the most widely used Java GUI is Swing.</span></div>
<div class="calibre23"><span>Swing defines a collection of classes and interfaces that support a rich set of visual components, such as buttons, text fields, scroll panes, check boxes, trees, and tables, to name a few. Collectively, these controls can be used to construct powerful, yet easy-to-use graphical interfaces. Because of its widespread use, Swing is something with which all Java programmers should be familiar. Therefore, this chapter provides an introduction to this important GUI framework.</span></div>
<div class="calibre23"><span>It is important to state at the outset that Swing is a very large topic that requires an entire book of its own. This chapter can only scratch its surface. However, the material presented here will give you a general understanding of Swing, including its history, basic concepts, and design philosophy. It then introduces five commonly used Swing components: the label, push button, text field, check box, and list. The chapter ends by showing how to create a Swing-based applet. Although this chapter describes only a small part of Swing’s features, after completing it, you will be able to begin writing simple GUI-based programs. You will also have a foundation upon which to continue your study of Swing.</span></div>
<div class="calibre23"><span>Before moving on, it is necessary to mention that a new GUI framework called JavaFX has recently been created for Java. JavaFX provides a powerful, streamlined, flexible approach that simplifies the creation of visually exciting GUIs. As such, JavaFX has clearly been positioned as the platform of the future. Because of its importance, an introduction to JavaFX is provided in <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_024.html#filepos1394297">Chapter 17</a>. Of course, Swing will continue to be in use for a long time, in part because of the large amount of legacy code that exists for it. Therefore, both Swing and JavaFX are likely to be part of any Java programmer’s job going forward.</span></div>
<div class="calibre44"><span class="calibre10"><span><span class="bold1"><span class="italic">NOTE</span></span></span></span></div>
<div class="calibre9"><span><img alt="image" src="images/00006.jpg" class="calibre45"/></span></div>
<div class="calibre9"><span>For a comprehensive introduction to Swing, see my book <span class="italic">Swing: A Beginner’s Guide</span> (McGraw-Hill Professional, 2007).</span></div><div class="calibre11"> </div>
<div id="filepos1306264" class="calibre1"><span class="calibre10"><span><span class="bold1">The Origins and Design Philosophy of Swing</span></span></span></div>
<div class="calibre12"><span>Swing did not exist in the early days of Java. Rather, it was a response to deficiencies present in Java’s original GUI subsystem: the Abstract Window Toolkit (AWT). The AWT defines a basic set of components that support a usable, but limited, graphical interface. One reason for the limited nature of the AWT is that it translates its various visual components into their corresponding, platform-specific equivalents, or <span class="italic">peers</span>. This means that the look and feel of an AWT component is defined by the platform, not by Java. Because the AWT components use native code resources, they are referred to as <span class="italic">heavyweight</span>.</span></div>
<div class="calibre23"><span>The use of native peers led to several problems. First, because of differences between operating systems, a component might look, or even act, differently on different platforms. This potential variability threatened the overarching philosophy of Java: write once, run anywhere. Second, the look and feel of each component was fixed (because it is defined by the platform) and could not be (easily) changed. Third, the use of heavyweight components caused some frustrating restrictions. For example, a heavyweight component was always opaque.</span></div>
<div class="calibre23"><span>Not long after Java’s original release, it became apparent that the limitations and restrictions present in the AWT were sufficiently serious that a better approach was needed. The solution was Swing. Introduced in 1997, Swing was included as part of the Java Foundation Classes (JFC). Swing was initially available for use with Java 1.1 as a separate library. However, beginning with Java 1.2, Swing (and the rest of JFC) was fully integrated into Java.</span></div>
<div class="calibre23"><span>Swing addresses the limitations associated with the AWT’s components through the use of two key features: <span class="italic">lightweight components</span> and a <span class="italic">pluggable look and feel</span>. Although they are largely transparent to the programmer, these two features are at the foundation of Swing’s design philosophy and the reason for much of its power and flexibility. Let’s look at each.</span></div>
<div class="calibre23"><span>With very few exceptions, Swing components are <span class="italic">lightweight</span>. This means that a component is written entirely in Java. They do not rely on platform-specific peers. Lightweight components have some important advantages, including efficiency and flexibility. Furthermore, because lightweight components do not translate into platform-specific peers, the look and feel of each component is determined by Swing, not by the underlying operating system. This means that each component can work in a consistent manner across all platforms.</span></div>
<div class="calibre23"><span>Because each Swing component is rendered by Java code rather than by platform-specific peers, it is possible to separate the look and feel of a component from the logic of the component, and this is what Swing does. Separating out the look and feel provides a significant advantage: it becomes possible to change the way that a component is rendered without affecting any of its other aspects. In other words, it is possible to “plug in” a new look and feel for any given component without creating any side effects in the code that uses that component.</span></div>
<div class="calibre23"><span>Java provides look-and-feels, such as metal and Nimbus, that are available to all Swing users. The metal look and feel is also called the <span class="italic">Java look and feel</span>. It is a platform-independent look and feel that is available in all Java execution environments. It is also the default look and feel. For this reason, the default Java look and feel (metal) is used by the examples in this chapter.</span></div>
<div class="calibre23"><span>Swing’s pluggable look and feel is made possible because Swing uses a modified version of the classic <span class="italic">model-view-controller (MVC)</span> architecture. In MVC terminology, the <span class="italic">model</span> corresponds to the state information associated with the component. For example, in the case of a check box, the <span class="italic">model</span> contains a field that indicates if the box is checked or unchecked. The <span class="italic">view</span> determines how the component is displayed on the screen, including any aspects of the view that are affected by the current state of the model. The <span class="italic">controller</span> determines how the component reacts to the user. For example, when the user clicks a check box, the controller reacts by changing the model to reflect the user’s choice (checked or unchecked). This then results in the view being updated. By separating a component into a model, a view, and a controller, the specific implementation of each can be changed without affecting the other two. For instance, different view implementations can render the same component in different ways without affecting the model or the controller.</span></div>
<div class="calibre23"><span>Although the MVC architecture and the principles behind it are conceptually sound, the high level of separation between the view and the controller was not beneficial for Swing components. Instead, Swing uses a modified version of MVC that combines the view and the controller into a single logical entity called the <span class="italic">UI delegate</span>. For this reason, Swing’s approach is called either the <span class="italic">model-delegate</span> architecture or the <span class="italic">separable model</span> architecture. Therefore, although Swing’s component architecture is based on MVC, it does not use a classical implementation of it. Although you won’t work directly with models or UI delegates in this chapter, they are, nevertheless, present behind the scene.</span></div>
<div class="calibre23"><span>As you work through this chapter, you will see that even though Swing embodies very sophisticated design concepts, it is easy to use. In fact, one could argue that Swing’s ease of use is its most important advantage. Simply stated, Swing makes manageable the often difficult task of developing your program’s user interface. This lets you concentrate on the GUI itself, rather than on implementation details.</span></div>
<div class="calibre35"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   You say that Swing defines a GUI that is superior to the AWT. Does this mean that Swing replaces the AWT?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   No, Swing does not replace the AWT. Rather, Swing builds upon the foundation provided by the AWT. Thus, the AWT is still a crucial part of Java. Swing also uses the same event handling mechanism as the AWT (which was described in <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_022.html#filepos1225806">Chapter 15</a>). Although knowledge of the AWT is not required by this chapter, you need a solid understanding of its structure and features if you seek full Swing mastery.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos1314146" class="calibre9"><span class="calibre10"><span><span class="bold1">Components and Containers</span></span></span></div>
<div class="calibre12"><span>A Swing GUI consists of two key items: <span class="italic">components</span> and <span class="italic">containers</span>. However, this distinction is mostly conceptual because all containers are also components. The difference between the two is found in their intended purpose: As the term is commonly used, a component is an independent visual control, such as a push button or text field. A container holds a group of components. Thus, a container is a special type of component that is designed to hold other components. Furthermore, in order for a component to be displayed, it must be held within a container. Thus, all Swing GUIs will have at least one container. Because containers are components, a container can also hold other containers. This enables Swing to define what is called a <span class="italic">containment hierarchy</span>, at the top of which must be a <span class="italic">top-level container</span>.</span></div>
<div id="filepos1315179" class="calibre1"><span class="calibre10"><span><span class="bold1">Components</span></span></span></div>
<div class="calibre12"><span>In general, Swing components are derived from the <span class="bold1">JComponent</span> class. (The only exceptions to this are the four top-level containers, described in the next section.) <span class="bold1">JComponent</span> provides the functionality that is common to all components. For example, <span class="bold1">JComponent</span> supports the pluggable look and feel. <span class="bold1">JComponent</span> inherits the AWT classes <span class="bold1">Container</span> and <span class="bold1">Component</span>. Thus, a Swing component is built on and compatible with an AWT component.</span></div>
<div class="calibre23"><span>All of Swing’s components are represented by classes defined within the package <span class="bold1">javax.swing</span>. The following table shows the class names for Swing components (including those used as containers):</span></div>
<div class="calibre1"><span><img alt="image" src="images/00982.jpg" class="calibre930"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Notice that all component classes begin with the letter <span class="bold1">J</span>. For example, the class for a label is <span class="bold1">JLabel</span>, the class for a push button is <span class="bold1">JButton</span>, and the class for a check box is <span class="bold1">JCheckBox</span>. This chapter introduces five commonly used components: <span class="bold1">JLabel</span>, <span class="bold1">JButton</span>, <span class="bold1">JTextField</span>, <span class="bold1">JCheckBox</span>, and <span class="bold1">JList</span>. Once you understand their basic operation, it will be easy for you to learn to use the others.</span></div>
<div id="filepos1316772" class="calibre1"><span class="calibre10"><span><span class="bold1">Containers</span></span></span></div>
<div class="calibre12"><span>Swing defines two types of containers. The first are top-level containers: <span class="bold1">JFrame</span>, <span class="bold1">JApplet</span>, <span class="bold1">JWindow</span>, and <span class="bold1">JDialog</span>. These containers do not inherit <span class="bold1">JComponent</span>. They do, however, inherit the AWT classes <span class="bold1">Component</span> and <span class="bold1">Container</span>. Unlike Swing’s other components, which are lightweight, the top-level containers are heavyweight. This makes the top-level containers a special case in the Swing component library.</span></div>
<div class="calibre23"><span>As the name implies, a top-level container must be at the top of a containment hierarchy. A top-level container is not contained within any other container. Furthermore, every containment hierarchy must begin with a top-level container. The one most commonly used for applications is <span class="bold1">JFrame</span>. The one used for applets is <span class="bold1">JApplet</span>.</span></div>
<div class="calibre23"><span>The second type of container supported by Swing is the lightweight container. Lightweight containers <span class="italic">do</span> inherit <span class="bold1">JComponent</span>. Examples of lightweight containers are <span class="bold1">JPanel</span>, <span class="bold1">JScrollPane</span>, and <span class="bold1">JRootPane</span>. Lightweight containers are often used to collectively organize and manage groups of related components because a lightweight container can be contained within another container. Thus, you can use lightweight containers to create subgroups of related controls that are contained within an outer container.</span></div>
<div id="filepos1318438" class="calibre1"><span class="calibre10"><span><span class="bold1">The Top-Level Container Panes</span></span></span></div>
<div class="calibre12"><span>Each top-level container defines a set of <span class="italic">panes</span>. At the top of the hierarchy is an instance of <span class="bold1">JRootPane</span>. <span class="bold1">JRootPane</span> is a lightweight container whose purpose is to manage the other panes. It also helps manage the optional menu bar. The panes that compose the root pane are called the <span class="italic">glass pane</span>, the <span class="italic">content pane</span>, and the <span class="italic">layered pane</span>.</span></div>
<div class="calibre23"><span>The glass pane is the top-level pane. It sits above and completely covers all other panes. The glass pane enables you to manage mouse events that affect the entire container (rather than an individual control) or to paint over any other component, for example. In most cases, you won’t need to use the glass pane directly. The layered pane allows components to be given a depth value. This value determines which component overlays another. (Thus, the layered pane lets you specify a Z-order for a component, although this is not something that you will usually need to do.) The layered pane holds the content pane and the (optional) menu bar. Although the glass pane and the layered panes are integral to the operation of a top-level container and serve important purposes, much of what they provide occurs behind the scene.</span></div>
<div class="calibre23"><span>The pane with which your application will interact the most is the content pane, because this is the pane to which you will add visual components. In other words, when you add a component, such as a button, to a top-level container, you will add it to the content pane. Therefore, the content pane holds the components that the user interacts with.</span></div>
<div id="filepos1320338" class="calibre1"><span class="calibre10"><span><span class="bold1">Layout Managers</span></span></span></div>
<div class="calibre12"><span>Before you begin writing a Swing program, there is one more thing that you need to be aware of: the <span class="italic">layout manager</span>. The layout manager controls the position of components within a container. Java offers several layout managers. Most are provided by the AWT (within <span class="bold1">java.awt</span>), but Swing adds a few of its own. All layout managers are instances of a class that implements the <span class="bold1">LayoutManager</span> interface. (Some will also implement the <span class="bold1">LayoutManager2</span> interface.) Here is a list of a few of the layout managers available to the Swing programmer:</span></div>
<div class="calibre11"> </div><table cellspacing="0" cellpadding="3" border="1" class="calibre37">
<colgroup class="calibre38">
<col class="calibre39"/>
<col class="calibre40"/>
</colgroup>
<tr class="calibre41">
<td valign="top" class="calibre42">FlowLayout</td>
<td valign="top" class="calibre42">A simple layout that positions components left-to-right, top-to-bottom. (Positions components right-to-left for some cultural settings.)</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">BorderLayout</td>
<td valign="top" class="calibre42">Positions components within the center or the borders of the container. This is the default layout for a content pane.</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">GridLayout</td>
<td valign="top" class="calibre42">Lays out components within a grid.</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">GridBagLayout</td>
<td valign="top" class="calibre42">Lays out different size components within a flexible grid.</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">BoxLayout</td>
<td valign="top" class="calibre42">Lays out components vertically or horizontally within a box.</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">SpringLayout</td>
<td valign="top" class="calibre42">Lays out components subject to a set of constraints.</td>
</tr>
</table><div class="calibre43"> </div>
<div class="calibre23"><span>Frankly, the topic of layout managers is quite large, and it is not possible to examine it in detail in this book. Fortunately, this chapter uses only two layout managers—<span class="bold1">BorderLayout</span> and <span class="bold1">FlowLayout</span>—and both are very easy to use.</span></div>
<div class="calibre23"><span><span class="bold1">BorderLayout</span> is the default layout manager for the content pane. It implements a layout style that defines five locations to which a component can be added. The first is the center. The other four are the sides (i.e., borders), which are called north, south, east, and west. By default, when you add a component to the content pane, you are adding the component to the center. To add a component to one of the other regions, specify its name.</span></div>
<div class="calibre23"><span>Although a border layout is useful in some situations, often another, more flexible layout manager is needed. One of the simplest is <span class="bold1">FlowLayout</span>. A flow layout lays out components one row at a time, top to bottom. When one row is full, layout advances to the next row. Although this scheme gives you little control over the placement of components, it is quite simple to use. However, be aware that if you resize the frame, the position of the components will change.</span></div>
<div id="filepos1324094" class="calibre1"><span class="calibre10"><span><span class="bold1">A First Simple Swing Program</span></span></span></div>
<div class="calibre12"><span>Swing programs differ from the console-based programs shown earlier in this book. They also differ from the AWT-based applets shown in <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_022.html#filepos1225806">Chapter 15</a>. Not only do Swing programs use the Swing component set to handle user interaction, but they also have special requirements that relate to threading. The best way to understand the structure of a Swing program is to work through an example. There are two types of Java programs in which Swing is typically used. The first is a desktop application. The second is the applet. This section shows how to create a Swing application. The creation of a Swing applet is described later in this chapter.</span></div>
<div class="calibre23"><span>Although quite short, the following program shows one way to write a Swing application. In the process it demonstrates several key features of Swing. It uses two Swing components: <span class="bold1">JFrame</span> and <span class="bold1">JLabel</span>. <span class="bold1">JFrame</span> is the top-level container that is commonly used for Swing applications. <span class="bold1">JLabel</span> is the Swing component that creates a label, which is a component that displays information. The label is Swing’s simplest component because it is passive. That is, a label does not respond to user input. It just displays output. The program uses a <span class="bold1">JFrame</span> container to hold an instance of a <span class="bold1">JLabel</span>. The label displays a short text message.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00983.jpg" class="calibre416"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Swing programs are compiled and run in the same way as other Java applications. Thus, to compile this program, you can use this command line:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00984.jpg" class="calibre889"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>To run the program, use this command line:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00985.jpg" class="calibre931"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>When the program is run, it will produce the window shown in <a href="#filepos1326617">Figure 16-1</a>.</span></div>
<div class="calibre28">
<div id="filepos1326617" class="calibre29"><span><img alt="image" src="images/00986.jpg" class="calibre932"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00057.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span><span class="bold1">Figure 16-1</span>   The window produced by the <span class="bold1">SwingDemo</span> program</span></div><div class="calibre18"> </div>
</div>
<div id="filepos1327052" class="calibre9"><span class="calibre10"><span><span class="bold1">The First Swing Example Line by Line</span></span></span></div>
<div class="calibre12"><span>Because the <span class="bold1">SwingDemo</span> program illustrates several key Swing concepts, we will examine it carefully, line by line. The program begins by importing the following package:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00987.jpg" class="calibre933"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>This <span class="bold1">javax.swing</span> package contains the components and models defined by Swing. For example, it defines classes that implement labels, buttons, edit controls, and menus. This package will be included in all programs that use Swing.</span></div>
<div class="calibre23"><span>Next, the program declares the <span class="bold1">SwingDemo</span> class and a constructor for that class. The constructor is where most of the action of the program occurs. It begins by creating a <span class="bold1">JFrame</span>, using this line of code:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00988.jpg" class="calibre82"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>This creates a container called <span class="bold1">jfrm</span> that defines a rectangular window complete with a title bar; close, minimize, maximize, and restore buttons; and a system menu. Thus, it creates a standard, top-level window. The title of the window is passed to the constructor.</span></div>
<div class="calibre23"><span>Next, the window is sized using this statement:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00989.jpg" class="calibre749"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The <span class="bold1">setSize( )</span> method sets the dimensions of the window, which are specified in pixels. Its general form is shown here:</span></div>
<div class="calibre27"><span>void setSize(int <span class="italic">width</span>, int <span class="italic">height</span>)</span></div>
<div class="calibre27"><span>In this example, the width of the window is set to 275 and the height is set to 100.</span></div>
<div class="calibre23"><span>By default, when a top-level window is closed (such as when the user clicks the close box), the window is removed from the screen, but the application is not terminated. While this default behavior is useful in some situations, it is not what is needed for most applications. Instead, you will usually want the entire application to terminate when its top-level window is closed. There are a couple of ways to achieve this. The easiest way is to call <span class="bold1">setDefaultCloseOperation( )</span>, as the program does:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00990.jpg" class="calibre934"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>After this call executes, closing the window causes the entire application to terminate. The general form of <span class="bold1">setDefaultCloseOperation( )</span> is shown here:</span></div>
<div class="calibre27"><span>void setDefaultCloseOperation(int <span class="italic">what</span>)</span></div>
<div class="calibre27"><span>The value passed in <span class="italic">what</span> determines what happens when the window is closed. There are several other options in addition to <span class="bold1">JFrame.EXIT_ON_CLOSE</span>. They are shown here:</span></div>
<div class="calibre27"><span>JFrame.DISPOSE_ON_CLOSE</span></div>
<div class="calibre27"><span>JFrame.HIDE_ON_CLOSE</span></div>
<div class="calibre27"><span>JFrame.DO_NOTHING_ON_CLOSE</span></div>
<div class="calibre27"><span>Their names reflect their actions. These constants are declared in <span class="bold1">WindowConstants</span>, which is an interface declared in <span class="bold1">javax.swing</span> that is implemented by <span class="bold1">JFrame</span>.</span></div>
<div class="calibre23"><span>The next line of code creates a <span class="bold1">JLabel</span> component:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00991.jpg" class="calibre780"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span><span class="bold1">JLabel</span> is the easiest-to-use Swing component because it does not accept user input. It simply displays information, which can consist of text, an icon, or a combination of the two. The label created by the program contains only text, which is passed to its constructor.</span></div>
<div class="calibre23"><span>The next line of code adds the label to the content pane of the frame:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00992.jpg" class="calibre935"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>As explained earlier, all top-level containers have a content pane in which components are stored. Thus, to add a component to a frame, you must add it to the frame’s content pane. This is accomplished by calling <span class="bold1">add( )</span> on the <span class="bold1">JFrame</span> reference (<span class="bold1">jfrm</span> in this case). The <span class="bold1">add( )</span> method has several versions. The general form of the one used by the program is shown here:</span></div>
<div class="calibre27"><span>Component add(Component <span class="italic">comp</span>)</span></div>
<div class="calibre27"><span>By default, the content pane associated with a <span class="bold1">JFrame</span> uses a border layout. This version of <span class="bold1">add( )</span> adds the component (in this case, a label) to the center location. Other versions of <span class="bold1">add( )</span> enable you to specify one of the border regions. When a component is added to the center, its size is automatically adjusted to fit the size of the center.</span></div>
<div class="calibre23"><span>The last statement in the <span class="bold1">SwingDemo</span> constructor causes the window to become visible.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00993.jpg" class="calibre936"/></span></div><div class="calibre11"> </div>
<div class="calibre29"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   I have seen Swing programs that use a method called</span> getContentPane( ) <span class="bold1">when adding a component to the content pane. What is this method and do I need to use it?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   This question brings up an important historical point. Prior to JDK 5, when adding a component to the content pane, you could not invoke the <span class="bold1">add( )</span> method directly on a <span class="bold1">JFrame</span> instance. Instead, you needed to explicitly call <span class="bold1">add( )</span> on the content pane of the <span class="bold1">JFrame</span> object. The content pane can be obtained by calling <span class="bold1">getContentPane( )</span> on a <span class="bold1">JFrame</span> instance. The <span class="bold1">getContentPane( )</span> method is shown here:</span></div>
<div class="calibre1"><span>Container getContentPane( )</span></div>
<div class="calibre1"><span>It returns a <span class="bold1">Container</span> reference to the content pane. The <span class="bold1">add( )</span> method was then called on that reference to add a component to a content pane. Thus, in the past, you had to use the following statement to add <span class="bold1">jlab</span> to <span class="bold1">jfrm</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00994.jpg" class="calibre937"/></span></div>
<div class="calibre1"><span>Here, <span class="bold1">getContentPane( )</span> first obtains a reference to the content pane, and then <span class="bold1">add( )</span> adds the component to the container linked to this pane. This same procedure was also required to invoke <span class="bold1">remove( )</span> to remove a component and <span class="bold1">setLayout( )</span> to set the layout manager for the content pane. You will see explicit calls to <span class="bold1">getContentPane( )</span> frequently throughout pre-5.0 code. Today, the use of <span class="bold1">getContentPane( )</span> is no longer necessary. You can simply call <span class="bold1">add( )</span>, <span class="bold1">remove( )</span>, and <span class="bold1">setLayout( )</span> directly on <span class="bold1">JFrame</span> because these methods have been changed so that they automatically operate on the content pane.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre12"><span>The <span class="bold1">setVisible( )</span> method has this general form:</span></div>
<div class="calibre27"><span>void setVisible(boolean <span class="italic">flag</span>)</span></div>
<div class="calibre27"><span>If <span class="italic">flag</span> is <span class="bold1">true</span>, the window will be displayed. Otherwise, it will be hidden. By default, a <span class="bold1">JFrame</span> is invisible, so <span class="bold1">setVisible(true)</span> must be called to show it.</span></div>
<div class="calibre23"><span>Inside <span class="bold1">main( )</span>, a <span class="bold1">SwingDemo</span> object is created, which causes the window and the label to be displayed. Notice that the <span class="bold1">SwingDemo</span> constructor is invoked using these lines of code:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00995.jpg" class="calibre938"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>This sequence causes a <span class="bold1">SwingDemo</span> object to be created on the <span class="italic">event-dispatching thread</span> rather than on the main thread of the application. Here’s why. In general, Swing programs are event-driven. For example, when a user interacts with a component, an event is generated. An event is passed to the application by calling an event handler defined by the application. However, the handler is executed on the event-dispatching thread provided by Swing and not on the main thread of the application. Thus, although event handlers are defined by your program, they are called on a thread that was not created by your program. To avoid problems (such as two different threads trying to update the same component at the same time), all Swing GUI components must be created and updated from the event-dispatching thread, not the main thread of the application. However, <span class="bold1">main( )</span> is executed on the main thread. Thus, it cannot directly instantiate a <span class="bold1">SwingDemo</span> object. Instead, it must create a <span class="bold1">Runnable</span> object that executes on the event-dispatching thread, and have this object create the GUI.</span></div>
<div class="calibre23"><span>To enable the GUI code to be created on the event-dispatching thread, you must use one of two methods that are defined by the <span class="bold1">SwingUtilities</span> class. These methods are <span class="bold1">invokeLater( )</span> and <span class="bold1">invokeAndWait( )</span>. They are shown here:</span></div>
<div class="calibre27"><span>static void invokeLater(Runnable <span class="italic">obj</span>)</span></div>
<div class="calibre27"><span>static void invokeAndWait(Runnable <span class="italic">obj</span>)</span></div>
<div class="calibre12"><blockquote class="calibre66"><span>throws InterruptedException, InvocationTargetException</span></blockquote></div>
<div class="calibre35"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   You state that it is possible to add a component to the other regions of a border layout by using an overloaded version of</span> add( )<span class="bold1">. Can you explain?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   As explained, <span class="bold1">BorderLayout</span> implements a layout style that defines five locations to which a component can be added. The first is the center. The other four are the sides (i.e., borders), which are called north, south, east, and west. By default, when you add a component to the content pane, you are adding the component to the center. To specify one of the other locations, use this form of <span class="bold1">add( )</span>:</span></div>
<div class="calibre1"><span>void add(Component <span class="italic">comp</span>, Object <span class="italic">loc</span>)</span></div>
<div class="calibre1"><span>Here, <span class="italic">comp</span> is the component to add and <span class="italic">loc</span> specifies the location to which it is added. The <span class="italic">loc</span> value is typically one of the following:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00996.jpg" class="calibre939"/></span></div>
<div class="calibre148"><span>In general, <span class="bold1">BorderLayout</span> is most useful when you are creating a <span class="bold1">JFrame</span> that contains a centered component (which might be a group of components held within one of Swing’s lightweight containers) that has a header and/or footer component associated with it. In other situations, one of Java’s other layout managers will be more appropriate.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre12"><span>Here, <span class="italic">obj</span> is a <span class="bold1">Runnable</span> object that will have its <span class="bold1">run( )</span> method called by the event-dispatching thread. The difference between the two methods is that <span class="bold1">invokeLater( )</span> returns immediately, but <span class="bold1">invokeAndWait( )</span> waits until <span class="italic">obj</span><span class="bold1">.run( )</span> returns. You can use these methods to call a method that constructs the GUI for your Swing application, or whenever you need to modify the state of the GUI from code not executed by the event-dispatching thread. You will normally want to use <span class="bold1">invokeLater( )</span>, as the preceding program does. However, when constructing the initial GUI for an applet, you will want to use <span class="bold1">invokeAndWait( )</span>. (Creating Swing applets is described later in this chapter.)</span></div>
<div class="calibre23"><span>One more point: The preceding program does not respond to any events, because <span class="bold1">JLabel</span> is a passive component. In other words, a <span class="bold1">JLabel</span> does not generate any events. Therefore, the preceding program does not include any event handlers. However, all other components generate events to which your program must respond, as the subsequent examples in this chapter show.</span></div>
<div id="filepos1342056" class="calibre1"><span class="calibre10"><span><span class="bold1">Use JButton</span></span></span></div>
<div class="calibre12"><span>One of the most commonly used Swing controls is the push button. A push button is an instance of <span class="bold1">JButton</span>. <span class="bold1">JButton</span> inherits the abstract class <span class="bold1">AbstractButton</span>, which defines the functionality common to all buttons. Swing push buttons can contain text, an image, or both, but this book uses only text-based buttons.</span></div>
<div class="calibre27"><span><span class="bold1">JButton</span> supplies several constructors. The one used here is</span></div>
<div class="calibre27"><span>JButton(String <span class="italic">msg</span>)</span></div>
<div class="calibre27"><span>Here, <span class="italic">msg</span> specifies the string that will be displayed inside the button.</span></div>
<div class="calibre23"><span>When a push button is pressed, it generates an <span class="bold1">ActionEvent</span>. <span class="bold1">ActionEvent</span> is defined by the AWT and also used by Swing. <span class="bold1">JButton</span> provides the following methods, which are used to add or remove an action listener:</span></div>
<div class="calibre27"><span>void addActionListener(ActionListener <span class="italic">al</span>)</span></div>
<div class="calibre27"><span>void removeActionListener(ActionListener <span class="italic">al</span>)</span></div>
<div class="calibre27"><span>Here, <span class="italic">al</span> specifies an object that will receive event notifications. This object must be an instance of a class that implements the <span class="bold1">ActionListener</span> interface.</span></div>
<div class="calibre23"><span>The <span class="bold1">ActionListener</span> interface defines only one method: <span class="bold1">actionPerformed( )</span>. It is shown here:</span></div>
<div class="calibre27"><span>void actionPerformed(ActionEvent <span class="italic">ae</span>)</span></div>
<div class="calibre27"><span>This method is called when a button is pressed. In other words, it is the event handler that is called when a button press event has occurred. Your implementation of <span class="bold1">actionPerformed( )</span> must quickly respond to that event and return. As a general rule, event handlers must not engage in long operations, because doing so will slow down the entire application. If a time-consuming procedure must be performed, then a separate thread should be created for that purpose.</span></div>
<div class="calibre23"><span>Using the <span class="bold1">ActionEvent</span> object passed to <span class="bold1">actionPerformed( )</span>, you can obtain several useful pieces of information relating to the button-press event. The one used by this chapter is the <span class="italic">action command</span> string associated with the button. By default, this is the string displayed inside the button. The action command is obtained by calling <span class="bold1">getActionCommand( )</span> on the event object. It is declared like this:</span></div>
<div class="calibre27"><span>String getActionCommand( )</span></div>
<div class="calibre27"><span>The action command identifies the button. Thus, when using two or more buttons within the same application, the action command gives you an easy way to determine which button was pressed.</span></div>
<div class="calibre23"><span>The following program demonstrates how to create a push button and respond to button-press events. <a href="#filepos1345602">Figure 16-2</a> shows how the example appears on the screen.</span></div>
<div class="calibre28">
<div id="filepos1345602" class="calibre29"><span><img alt="image" src="images/00997.jpg" class="calibre940"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00057.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span><span class="bold1">Figure 16-2</span>   Output from the <span class="bold1">ButtonDemo</span> program</span></div><div class="calibre18"> </div>
</div>
<div class="calibre1"><span><img alt="image" src="images/00998.jpg" class="calibre905"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00999.jpg" class="calibre607"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Let’s take a close look at the new things in this program. First, notice that the program now imports both the <span class="bold1">java.awt</span> and <span class="bold1">java.awt.event</span> packages. The <span class="bold1">java.awt</span> package is needed because it contains the <span class="bold1">FlowLayout</span> class, which supports the flow layout manager. The <span class="bold1">java.awt.event</span> package is needed because it defines the <span class="bold1">ActionListener</span> interface and the <span class="bold1">ActionEvent</span> class.</span></div>
<div class="calibre23"><span>Next, the class <span class="bold1">ButtonDemo</span> is declared. Notice that it implements <span class="bold1">ActionListener</span>. This means that <span class="bold1">ButtonDemo</span> objects can be used to receive action events. Next, a <span class="bold1">JLabel</span> reference is declared. This reference will be used within the <span class="bold1">actionPerformed( )</span> method to display which button has been pressed.</span></div>
<div class="calibre23"><span>The <span class="bold1">ButtonDemo</span> constructor begins by creating a <span class="bold1">JFrame</span> called <span class="bold1">jfrm</span>. It then sets the layout manager for the content pane of <span class="bold1">jfrm</span> to <span class="bold1">FlowLayout</span>, as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01000.jpg" class="calibre191"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>As explained earlier, by default, the content pane uses <span class="bold1">BorderLayout</span> as its layout manager, but for many applications, <span class="bold1">FlowLayout</span> is more convenient. Recall that a flow layout lays out components one row at a time, top to bottom. When one row is full, layout advances to the next row. Although this scheme gives you little control over the placement of components, it is quite simple to use. However, be aware that if you resize the frame, the position of the components will change.</span></div>
<div class="calibre23"><span>After setting the size and the default close operation, <span class="bold1">ButtonDemo( )</span> creates two buttons, as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01001.jpg" class="calibre941"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The first button will contain the text "Up", and the second will contain "Down".</span></div>
<div class="calibre23"><span>Next, the instance of <span class="bold1">ButtonDemo</span> referred to via <span class="bold1">this</span> is added as an action listener for the buttons by these two lines:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01002.jpg" class="calibre364"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>This approach means that the object that creates the buttons will also receive notifications when a button is pressed.</span></div>
<div class="calibre23"><span>Each time a button is pressed, it generates an action event and all registered listeners are notified by calling the <span class="bold1">actionPerformed( )</span> method. The <span class="bold1">ActionEvent</span> object representing the button event is passed as a parameter. In the case of <span class="bold1">ButtonDemo</span>, this event is passed to this implementation of <span class="bold1">actionPerformed( )</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01003.jpg" class="calibre942"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>The event that occurred is passed via <span class="bold1">ae</span>. Inside the method, the action command associated with the button that generated the event is obtained by calling <span class="bold1">getActionCommand( )</span>. (Recall that, by default, the action command is the same as the text displayed by the button.) Based on the contents of that string, the text in the label is set to show which button was pressed.</span></div>
<div class="calibre23"><span>One last point: Remember that <span class="bold1">actionPerformed( )</span> is called on the event-dispatching thread as explained earlier. It must return quickly in order to avoid slowing down the application.</span></div>
<div id="filepos1350455" class="calibre1"><span class="calibre10"><span><span class="bold1">Work with JTextField</span></span></span></div>
<div class="calibre12"><span>Another commonly used control is <span class="bold1">JTextField</span>. It enables the user to enter a line of text. <span class="bold1">JTextField</span> inherits the abstract class <span class="bold1">JTextComponent</span>, which is the superclass of all text components. <span class="bold1">JTextField</span> defines several constructors. The one we will use is shown here:</span></div>
<div class="calibre27"><span>JTextField(int <span class="italic">cols</span>)</span></div>
<div class="calibre27"><span>Here, <span class="italic">cols</span> specifies the width of the text field in columns. It is important to understand that you can enter a string that is longer than the number of columns. It’s just that the physical size of the text field on the screen will be <span class="italic">cols</span> columns wide.</span></div>
<div class="calibre23"><span>When you press <small class="calibre16">ENTER</small> when inputting into a text field, an <span class="bold1">ActionEvent</span> is generated. Therefore, <span class="bold1">JTextField</span> provides the <span class="bold1">addActionListener( )</span> and <span class="bold1">removeActionListener( )</span> methods. To handle action events, you must implement the <span class="bold1">actionPerformed( )</span> method defined by the <span class="bold1">ActionListener</span> interface. The process is similar to handling action events generated by a button, as described earlier.</span></div>
<div class="calibre23"><span>Like a <span class="bold1">JButton</span>, a <span class="bold1">JTextField</span> has an action command string associated with it. By default, the action command is the current content of the text field. However, this default is seldom used. Instead, you will usually set the action command to a fixed value of your own choosing by calling the <span class="bold1">setActionCommand( )</span> method, shown here:</span></div>
<div class="calibre27"><span>void setActionCommand(String <span class="italic">cmd</span>)</span></div>
<div class="calibre27"><span>The string passed in <span class="italic">cmd</span> becomes the new action command. The text in the text field is unaffected. Once you set the action command string, it remains the same no matter what is entered into the text field. One reason that you might want to explicitly set the action command is to provide a way to recognize the text field as the source of an action event. This is especially important when another control in the same frame also generates action events and you want to use the same event handler to process both events. Setting the action command gives you a way to tell them apart. Also, if you don’t set the action command associated with a text field, then by happenstance the contents of the text field might match the action command of another component.</span></div>
<div class="calibre35"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   You explained that the action command associated with a text field can be set by calling</span> setActionCommand( )<span class="bold1">. Can I use this method to set the action command associated with a push button?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   Yes. As explained, by default the action command associated with a push button is the name of the button. To set the action command to a different value, you can use the <span class="bold1">setActionCommand( )</span> method. It works the same for <span class="bold1">JButton</span> as it does for <span class="bold1">JTextField</span>.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre23"><span>To obtain the string that is currently displayed in the text field, call <span class="bold1">getText( )</span> on the <span class="bold1">JTextField</span> instance. It is declared as shown here:</span></div>
<div class="calibre27"><span>String getText( )</span></div>
<div class="calibre27"><span>You can set the text in a <span class="bold1">JTextField</span> by calling <span class="bold1">setText( )</span>, shown next:</span></div>
<div class="calibre27"><span>void setText(String <span class="italic">text</span>)</span></div>
<div class="calibre27"><span>Here, <span class="italic">text</span> is the string that will be put into the text field.</span></div>
<div class="calibre23"><span>The following program demonstrates <span class="bold1">JTextField</span>. It contains one text field, one push button, and two labels. One label prompts the user to enter text into the text field. When the user presses <small class="calibre16">ENTER</small> while focus is within the text field, the contents of the text field are obtained and displayed within a second label. The push button is called Reverse. When pressed, it reverses the contents of the text field. Sample output is shown in <a href="#filepos1355648">Figure 16-3</a>.</span></div>
<div class="calibre28">
<div id="filepos1355648" class="calibre29"><span><img alt="image" src="images/01004.jpg" class="calibre943"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00057.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span><span class="bold1">Figure 16-3</span>   Sample output from the <span class="bold1">TFDemo</span> program</span></div><div class="calibre18"> </div>
</div>
<div class="calibre1"><span><img alt="image" src="images/01005.jpg" class="calibre944"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/01006.jpg" class="calibre945"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Much of the program will be familiar, but a few parts warrant special attention. First, notice that the action command associated with the text field is set to "myTF" by the following line:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01007.jpg" class="calibre735"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>After this line executes, the action command string will always be "myTF" no matter what text is currently held in the text field. Therefore, the action command generated by <span class="bold1">jtf</span> will not accidentally conflict with the action command associated with the Reverse push button. The <span class="bold1">actionPerformed( )</span> method makes use of this fact to determine what event has occurred. If the action command string is "Reverse", it can mean only one thing: that the Reverse push button has been pressed. Otherwise, the action command was generated by the user pressing <small class="calibre16">ENTER</small> while the text field had input focus.</span></div>
<div class="calibre23"><span>Finally, notice this line from within the <span class="bold1">actionPerformed( )</span> method:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01008.jpg" class="calibre946"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>As explained, when the user presses <small class="calibre16">ENTER</small> while focus is inside the text field, an <span class="bold1">ActionEvent</span> is generated and sent to all registered action listeners, through the <span class="bold1">actionPerformed( )</span> method. For <span class="bold1">TFDemo</span>, this method simply obtains the text currently held in the text field by calling <span class="bold1">getText( )</span> on <span class="bold1">jtf</span>. It then displays the text through the label referred to by <span class="bold1">jlabContents</span>.</span></div>
<div id="filepos1358244" class="calibre1"><span class="calibre10"><span><span class="bold1">Create a JCheckBox</span></span></span></div>
<div class="calibre12"><span>After the push button, perhaps the next most widely used control is the check box. In Swing, a check box is an object of type <span class="bold1">JCheckBox</span>. <span class="bold1">JCheckBox</span> inherits <span class="bold1">AbstractButton</span> and <span class="bold1">JToggleButton</span>. Thus, a check box is, essentially, a special type of button.</span></div>
<div class="calibre23"><span><span class="bold1">JCheckBox</span> defines several constructors. The one used here is</span></div>
<div class="calibre27"><span>JCheckBox(String <span class="italic">str</span>)</span></div>
<div class="calibre27"><span>It creates a check box that has the text specified by <span class="italic">str</span> as a label.</span></div>
<div class="calibre23"><span>When a check box is selected or deselected (that is, checked or unchecked), an item event is generated. Item events are represented by the <span class="bold1">ItemEvent</span> class. Item events are handled by classes that implement the <span class="bold1">ItemListener</span> interface. This interface specifies only one method: <span class="bold1">itemStateChanged( )</span>, which is shown here:</span></div>
<div class="calibre27"><span>void itemStateChanged(ItemEvent <span class="italic">ie</span>)</span></div>
<div class="calibre27"><span>The item event is received in <span class="italic">ie</span>.</span></div>
<div class="calibre23"><span>To obtain a reference to the item that changed, call <span class="bold1">getItem( )</span> on the <span class="bold1">ItemEvent</span> object. This method is shown here:</span></div>
<div class="calibre27"><span>Object getItem( )</span></div>
<div class="calibre27"><span>The reference returned must be cast to the component class being handled, which in this case is <span class="bold1">JCheckBox</span>.</span></div>
<div class="calibre23"><span>You can obtain the text associated with a check box by calling <span class="bold1">getText( )</span>. You can set the text after a check box is created by calling <span class="bold1">setText( )</span>. These methods work the same as they do for <span class="bold1">JButton</span>, described earlier.</span></div>
<div class="calibre23"><span>The easiest way to determine the state of a check box is to call the <span class="bold1">isSelected( )</span> method. It is shown here:</span></div>
<div class="calibre27"><span>boolean isSelected( )</span></div>
<div class="calibre27"><span>It returns true if the check box is selected and false otherwise.</span></div>
<div class="calibre23"><span>The following program demonstrates check boxes. It creates three check boxes called Alpha, Beta, and Gamma. Each time the state of a box is changed, the current action is displayed. Also, the list of all currently selected check boxes is displayed. Sample output is shown in <a href="#filepos1361256">Figure 16-4</a>.</span></div>
<div class="calibre28">
<div id="filepos1361256" class="calibre29"><span><img alt="image" src="images/01009.jpg" class="calibre947"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00057.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span><span class="bold1">Figure 16-4</span>   Sample output from the <span class="bold1">CBDemo</span> program</span></div><div class="calibre18"> </div>
</div>
<div class="calibre1"><span><img alt="image" src="images/01010.jpg" class="calibre359"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/01011.jpg" class="calibre948"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/01012.jpg" class="calibre949"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>The main point of interest in this program is the item event handler, <span class="bold1">itemStateChanged( )</span>. It performs two functions. First, it reports whether the check box has been selected or cleared. Second, it displays all selected check boxes. It begins by obtaining a reference to the check box that generated the <span class="bold1">ItemEvent</span>, as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01013.jpg" class="calibre950"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>The cast to <span class="bold1">JCheckBox</span> is necessary because <span class="bold1">getItem( )</span> returns a reference of type <span class="bold1">Object</span>. Next, <span class="bold1">itemStateChanged( )</span> calls <span class="bold1">isSelected( )</span> on <span class="bold1">cb</span> to determine the current state of the check box. If <span class="bold1">isSelected( )</span> returns true, it means that the user selected the check box. Otherwise, the check box was cleared. It then sets the <span class="bold1">jlabChanged</span> label to reflect what happened.</span></div>
<div class="calibre23"><span>Finally, <span class="bold1">itemStateChanged( )</span> checks the selected state of each check box, building a string that contains the names of those that are selected. It displays this string in the <span class="bold1">jlabSelected</span> label.</span></div>
<div id="filepos1363420" class="calibre1"><span class="calibre10"><span><span class="bold1">Work with JList</span></span></span></div>
<div class="calibre12"><span>The last component that we will examine is <span class="bold1">JList</span>. This is Swing’s basic list class. It supports the selection of one or more items from a list. Although often the list consists of strings, it is possible to create a list of just about any object that can be displayed. <span class="bold1">JList</span> is so widely used in Java that it is highly unlikely that you have not seen one before.</span></div>
<div class="calibre23"><span>In the past, the items in a <span class="bold1">JList</span> were represented as <span class="bold1">Object</span> references. However, beginning with JDK 7, <span class="bold1">JList</span> was made generic, and it is now declared like this:</span></div>
<div class="calibre27"><span>class JList&lt;E&gt;</span></div>
<div class="calibre27"><span>Here, <span class="bold1">E</span> represents the type of the items in the list. As a result, <span class="bold1">JList</span> is now type-safe.</span></div>
<div class="calibre23"><span><span class="bold1">JList</span> provides several constructors. The one used here is</span></div>
<div class="calibre27"><span>JList(E[ ] <span class="italic">items</span>)</span></div>
<div class="calibre27"><span>This creates a <span class="bold1">JList</span> that contains the items in the array specified by <span class="italic">items</span>.</span></div>
<div class="calibre23"><span>Although a <span class="bold1">JList</span> will work properly by itself, most of the time you will wrap a <span class="bold1">JList</span> inside a <span class="bold1">JScrollPane</span>, which is a container that automatically provides scrolling for its contents. Here is the constructor that we will use:</span></div>
<div class="calibre27"><span>JScrollPane(Component <span class="italic">comp</span>)</span></div>
<div class="calibre27"><span>Here, <span class="italic">comp</span> specifies the component to be scrolled, which in this case will be a <span class="bold1">JList</span>. When you wrap a <span class="bold1">JList</span> in a <span class="bold1">JScrollPane</span>, long lists will automatically be scrollable. This simplifies GUI design. It also makes it easy to change the number of entries in a list without having to change the size of the <span class="bold1">JList</span> component.</span></div>
<div class="calibre23"><span>A <span class="bold1">JList</span> generates a <span class="bold1">ListSelectionEvent</span> when the user makes or changes a selection. This event is also generated when the user deselects an item. It is handled by implementing <span class="bold1">ListSelectionListener</span>, which is packaged in <span class="bold1">javax.swing.event</span>. This listener specifies only one method, called <span class="bold1">valueChanged( )</span>, which is shown here:</span></div>
<div class="calibre27"><span>void valueChanged(ListSelectionEvent <span class="italic">le</span>)</span></div>
<div class="calibre27"><span>Here, <span class="italic">le</span> is a reference to the object that generated the event. Although <span class="bold1">ListSelectionEvent</span> does provide some methods of its own, often you will interrogate the <span class="bold1">JList</span> object itself to determine what has occurred. <span class="bold1">ListSelectionEvent</span> is also packaged in <span class="bold1">javax.swing.event</span>.</span></div>
<div class="calibre23"><span>By default, a <span class="bold1">JList</span> allows the user to select multiple ranges of items within the list, but you can change this behavior by calling <span class="bold1">setSelectionMode( )</span>, which is defined by <span class="bold1">JList</span>. It is shown here:</span></div>
<div class="calibre27"><span>void setSelectionMode(int <span class="italic">mode</span>)</span></div>
<div class="calibre27"><span>Here, <span class="italic">mode</span> specifies the selection mode. It must be one of these values defined by the <span class="bold1">ListSelectionModel</span> interface (which is packaged in <span class="bold1">javax.swing</span>):</span></div>
<div class="calibre27"><span>SINGLE_SELECTION</span></div>
<div class="calibre27"><span>SINGLE_INTERVAL_SELECTION</span></div>
<div class="calibre27"><span>MULTIPLE_INTERVAL_SELECTION</span></div>
<div class="calibre27"><span>The default, multiple-interval selection lets the user select multiple ranges of items within a list. With single-interval selection, the user can select one range of items. With single selection, the user can select only a single item. Of course, a single item can be selected in the other two modes, too. It’s just that they also allow a range to be selected.</span></div>
<div class="calibre23"><span>You can obtain the index of the first item selected, which will also be the index of the only selected item when using single-selection mode, by calling <span class="bold1">getSelectedIndex( )</span>, shown here:</span></div>
<div class="calibre27"><span>int getSelectedIndex( )</span></div>
<div class="calibre27"><span>Indexing begins at zero. So, if the first item is selected, this method will return 0. If no item is selected, –1 is returned.</span></div>
<div class="calibre23"><span>You can obtain an array containing all selected items by calling <span class="bold1">getSelectedIndices( )</span>, shown next:</span></div>
<div class="calibre27"><span>int[ ] getSelectedIndices( )</span></div>
<div class="calibre27"><span>In the returned array, the indices are ordered from smallest to largest. If a zero-length array is returned, it means that no items are selected.</span></div>
<div class="calibre23"><span>The following program demonstrates a simple <span class="bold1">JList</span>, which holds a list of names. Each time a name is selected in the list, a <span class="bold1">ListSelectionEvent</span> is generated, which is handled by the <span class="bold1">valueChanged( )</span> method defined by <span class="bold1">ListSelectionListener</span>. It responds by obtaining the index of the selected item and displaying the corresponding name. Sample output is shown in <a href="#filepos1369455">Figure 16-5</a>.</span></div>
<div class="calibre28">
<div id="filepos1369455" class="calibre29"><span><img alt="image" src="images/01014.jpg" class="calibre951"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00057.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span><span class="bold1">Figure 16-5</span>   Output from the <span class="bold1">ListDemo</span> program</span></div><div class="calibre18"> </div>
</div>
<div class="calibre1"><span><img alt="image" src="images/01015.jpg" class="calibre952"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/01016.jpg" class="calibre953"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/01017.jpg" class="calibre954"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Let’s look closely at this program. First, notice the <span class="bold1">names</span> array near the top of the program. It is initialized to a list of strings that contain various names. Inside <span class="bold1">ListDemo( )</span>, a <span class="bold1">JList</span> called <span class="bold1">jlst</span> is constructed using the <span class="bold1">names</span> array. As mentioned, when the array constructor is used (as it is in this case), a <span class="bold1">JList</span> instance is automatically created that contains the contents of the array. Thus, the list will contain the names in <span class="bold1">names</span>.</span></div>
<div class="calibre23"><span>Next, the selection mode is set to single selection. This means that only one item in this list can be selected at any one time. Then, <span class="bold1">jlst</span> is wrapped inside a <span class="bold1">JScrollPane</span>, and the preferred size of the scroll pane is set to 120 by 90. This makes for a compact, but easy-to-use scroll pane. In Swing, the <span class="bold1">setPreferredSize( )</span> method sets the ideal size of a component. Be aware that some layout managers are free to ignore this request, but most often the preferred size determines the size of the component.</span></div>
<div class="calibre23"><span>A list selection event occurs whenever the user selects an item or changes the item selected. Inside the <span class="bold1">valueChanged( )</span> event handler, the index of the item selected is obtained by calling <span class="bold1">getSelectedIndex( )</span>. Because the list has been set to single-selection mode, this is also the index of the only item selected. This index is then used to index the <span class="bold1">names</span> array to obtain the selected name. Notice that this index value is tested against –1. Recall that this is the value returned if no item has been selected. This will be the case when the selection event handler is called if the user has deselected an item. Remember: A selection event is generated when the user selects or deselects an item.</span></div>
<div class="calibre18"> </div><table cellspacing="0" cellpadding="0" class="calibre37">
<colgroup class="calibre38">
<col class="calibre72"/>
<col class="calibre73"/>
</colgroup>
<tr class="calibre41">
<td valign="top" id="filepos1372428" class="calibre74"><span class="calibre10"><span class="bold1">Try This 16-1</span> </span></td>
<td valign="top" class="calibre75"><span class="calibre10">A Swing-Based File Comparison Utility</span></td>
</tr></table><div class="calibre43"> </div>
<div class="calibre1"><span><img alt="image" src="images/01018.jpg" class="calibre955"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Although you know only a small amount about Swing, you can still put it to use to create a practical application. In <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_017.html#filepos865854">Try This 10-1</a>, you created a console-based file comparison utility. This project creates a Swing-based version of the program. As you will see, giving this application a Swing-based user interface substantially improves its appearance and makes it easier to use. Here is how the Swing version looks:</span></div>
<div class="calibre29"><span><img alt="image" src="images/01019.jpg" class="calibre956"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Because Swing streamlines the creation of GUI-based programs, you might be surprised by how easy it is to create this program.</span></div>
<div class="calibre19"><span>  <span class="bold1">1.</span>  Begin by creating a file called <span class="bold1">SwingFC.java</span> and then enter the following comment and <span class="bold1">import</span> statements:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/01020.jpg" class="calibre957"/></span></div>
<div class="calibre47"><span>  <span class="bold1">2.</span>  Next, begin the <span class="bold1">SwingFC</span> class, as shown here:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/01021.jpg" class="calibre958"/></span></div>
<div class="calibre47"><span>        The names of the files to compare are entered into the text fields defined by <span class="bold1">jtfFirst</span> and <span class="bold1">jtfSecond</span>. To compare the files, the user presses the <span class="bold1">jbtnComp</span> button. Prompting messages are displayed in <span class="bold1">jlabFirst</span> and <span class="bold1">jlabSecond</span>. The results of the comparison, or any error messages, are displayed in <span class="bold1">jlabResult</span>.</span></div>
<div class="calibre47"><span>  <span class="bold1">3.</span>  Code the <span class="bold1">SwingFC</span> constructor like this:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/01022.jpg" class="calibre826"/></span></div>
<div class="calibre47"><span>        Most of the code in this constructor should be familiar to you. However, notice one thing: an action listener is added only to the push button <span class="bold1">jbtnCompare</span>. Action listeners are not added to the text fields. Here’s why: the contents of the text fields are needed only when the Compare button is pushed. At no other time are their contents required. Thus, there is no reason to respond to any text field events. As you begin to write more Swing programs, you will find that this is often the case when using a text field.</span></div>
<div class="calibre47"><span>  <span class="bold1">4.</span>  Begin creating the <span class="bold1">actionPerformed( )</span> event handler, as shown next. This method is called when the Compare button is pressed.</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/01023.jpg" class="calibre223"/></span></div>
<div class="calibre47"><span>        The method begins by confirming that the user has entered a file name into each of the text fields. If this is not the case, the missing file name is reported and the handler returns.</span></div>
<div class="calibre47"><span>  <span class="bold1">5.</span>  Now, finish <span class="bold1">actionPerformed( )</span> by adding the code that actually opens the files and then compares them.</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/01024.jpg" class="calibre959"/></span></div>
<div class="calibre47"><span>  <span class="bold1">6.</span>  Finish <span class="bold1">SwingFC</span> by adding the following <span class="bold1">main( )</span> method.</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/01025.jpg" class="calibre960"/></span></div>
<div class="calibre47"><span>  <span class="bold1">7.</span>  The entire Swing-based file comparison program is shown here:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/01026.jpg" class="calibre961"/></span></div>
<div class="calibre47"><span>        <img alt="image" src="images/01027.jpg" class="calibre962"/></span></div>
<div class="calibre47"><span>        <img alt="image" src="images/01028.jpg" class="calibre99"/></span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos1378710" class="calibre9"><span class="calibre10"><span><span class="bold1">Use Anonymous Inner Classes or Lambda Expressions to Handle Events</span></span></span></div>
<div class="calibre12"><span>Up to this point, the programs in this chapter have used a simple, straightforward approach to handling events in which the main class of the application has implemented the listener interface itself and all events are sent to an instance of that class. While this is perfectly acceptable, it is not the only way to handle events. For example, you could use separate listener classes. Thus, different classes could handle different events and these classes would be separate from the main class of the application. However, two other approaches offer powerful alternatives. First, you can implement listeners through the use of <span class="italic">anonymous inner classes</span>. Second, in some cases, you can use a lambda expression to handle an event. Let’s look at each approach.</span></div>
<div class="calibre23"><span>Anonymous inner classes are inner classes that don’t have a name. Instead, an instance of the class is simply generated “on the fly” as needed. Anonymous inner classes make implementing some types of event handlers much easier. For example, given a <span class="bold1">JButton</span> called <span class="bold1">jbtn</span>, you could implement an action listener for it like this:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01029.jpg" class="calibre963"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, an anonymous inner class is created that implements the <span class="bold1">ActionListener</span> interface. Pay special attention to the syntax. The body of the inner class begins after the <span class="bold1">{</span> that follows <span class="bold1">new ActionListener( )</span>. Also notice that the call to <span class="bold1">addActionListener( )</span> ends with a <span class="bold1">)</span> and a <span class="bold1">;</span> just like normal. The same basic syntax and approach is used to create an anonymous inner class for any event handler. Of course, for different events, you specify different event listeners and implement different methods.</span></div>
<div class="calibre23"><span>One advantage to using an anonymous inner class is that the component that invokes the class’ methods is already known. For instance, in the preceding example, there is no need to call <span class="bold1">getActionCommand( )</span> to determine what component generated the event, because this implementation of <span class="bold1">actionPerformed( )</span> will only be called by events generated by <span class="bold1">jbtn</span>. You will see anonymous inner classes at work in the Swing applet shown in the following section.</span></div>
<div class="calibre23"><span>In the case of an event whose listener defines a functional interface, you can handle the event by use of a lambda expression. For example, action events can be handled with a lambda expression because <span class="bold1">ActionListener</span> defines only one abstract method, <span class="bold1">actionPerformed( )</span>. Using a lambda expression to implement <span class="bold1">ActionListener</span> provides a compact alternative to explicitly declaring an anonymous inner class. For example, again assuming a <span class="bold1">JButton</span> called <span class="bold1">jbtn</span>, you could implement the action listener like this:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01030.jpg" class="calibre964"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>As was the case with the anonymous inner class approach, the object that generates the event is known. In this case, the lambda expression applies only to the <span class="bold1">jbtn</span> button.</span></div>
<div class="calibre23"><span>Of course, in cases in which an event can be handled by use of a single expression, it is not necessary to use a block lambda. For example, here is an action event handler for the Up button in the <span class="bold1">ButtonDemo</span> program shown earlier. It requires only an expression lambda.</span></div>
<div class="calibre1"><span><img alt="image" src="images/01031.jpg" class="calibre780"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Notice how much shorter this code is compared with the original approach. It is also shorter than it would be if you explicitly used an anonymous inner class.</span></div>
<div class="calibre23"><span>In general, you can use a lambda expression to handle an event when its listener defines a functional interface. For example, <span class="bold1">ItemListener</span> is also a functional interface. Of course, whether you use the traditional approach, an anonymous inner class, or a lambda expression will be determined by the precise nature of your application. To gain experience with each, try converting the event handlers in the foregoing examples to lambda expressions or anonymous inner classes.</span></div>
<div id="filepos1383688" class="calibre1"><span class="calibre10"><span><span class="bold1">Create a Swing Applet</span></span></span></div>
<div class="calibre12"><span>The preceding example programs have been Swing-based applications. The second type of program that commonly uses Swing is the applet. Swing-based applets are similar to AWT-based applets described in <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_022.html#filepos1225806">Chapter 15</a>, but with an important difference: A Swing applet extends <span class="bold1">JApplet</span> rather than <span class="bold1">Applet</span>. <span class="bold1">JApplet</span> is derived from <span class="bold1">Applet</span>. Thus, <span class="bold1">JApplet</span> includes all of the functionality found in <span class="bold1">Applet</span> and adds support for Swing. <span class="bold1">JApplet</span> is a top-level Swing container. Therefore, it includes the various panes described earlier. As a result, all components are added to <span class="bold1">JApplet</span>’s content pane in the same way that components are added to <span class="bold1">JFrame</span>’s content pane.</span></div>
<div class="calibre23"><span>Swing applets use the same four life-cycle methods described in <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_022.html#filepos1225806">Chapter 15</a>: <span class="bold1">init( )</span>, <span class="bold1">start( )</span>, <span class="bold1">stop( )</span>, and <span class="bold1">destroy( )</span>. Of course, you need to override only those methods that are needed by your applet. In general, painting is accomplished differently in Swing than it is in the AWT. Thus, a Swing applet will not usually override the <span class="bold1">paint( )</span> method.</span></div>
<div class="calibre23"><span>One other point: All interaction with components in a Swing applet must take place on the event-dispatching thread, as described in the preceding section. This threading issue applies to all Swing programs.</span></div>
<div class="calibre23"><span>Here is an example of a Swing applet. It provides the same functionality as the push-button example shown earlier in this chapter, but it does so in applet form. It also uses anonymous inner classes to implement the action event handlers. <a href="#filepos1385811">Figure 16-6</a> shows the program when executed by <span class="bold1">appletviewer</span>.</span></div>
<div class="calibre28">
<div id="filepos1385811" class="calibre29"><span><img alt="image" src="images/01032.jpg" class="calibre965"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00057.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span><span class="bold1">Figure 16-6</span>   Output from the example Swing applet</span></div><div class="calibre18"> </div>
</div>
<div class="calibre1"><span><img alt="image" src="images/01033.jpg" class="calibre130"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/01034.jpg" class="calibre641"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>There are several important things to notice about this applet. First, <span class="bold1">MySwingApplet</span> extends <span class="bold1">JApplet</span>. As explained, all Swing-based applets extend <span class="bold1">JApplet</span> rather than <span class="bold1">Applet</span>. Second, the <span class="bold1">init( )</span> method initializes the Swing components on the event-dispatching thread by setting up a call to <span class="bold1">makeGUI( )</span>. Notice that this is accomplished through the use of <span class="bold1">invokeAndWait( )</span> rather than <span class="bold1">invokeLater( )</span>. Applets must use <span class="bold1">invokeAndWait( )</span> because the <span class="bold1">init( )</span> method must not return until the entire initialization process has been completed. In essence, the <span class="bold1">start( )</span> method cannot be called until after initialization, which means that the GUI must be fully constructed.</span></div>
<div class="calibre23"><span>Inside <span class="bold1">makeGUI( )</span>, the two buttons and label are created, and the action listeners are added to the buttons. Notice that anonymous inner classes are used to implement the action event handlers. You can use these as a model for implementing other event handlers. One of the primary advantages is that the object that causes the event is known because it is the object on which the anonymous inner class is instantiated. Therefore, it is not necessary to obtain the action command to determine which button generated the event. (Using a lambda expression would also provide the same advantage.) Finally, the components are added to the content pane. Although this example is quite simple, this same general approach can be used when building any Swing GUI that will be used by an applet.</span></div>
<div id="filepos1388171" class="calibre44"><span class="calibre10"><span><img alt="image" src="images/00059.jpg" class="calibre104"/>   <span class="bold1"><span class="italic">Chapter 16 Self Test</span></span></span></span></div><div class="calibre11"> </div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1388452" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1591354">1</a>.</span>  In general, AWT components are heavyweight and Swing components are ____________.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1388702" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1591609">2</a>.</span>  Can the look and feel of a Swing component be changed? If so, what feature enables this?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1388959" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1592040">3</a>.</span>  What is the most commonly used top-level container for an application?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1389198" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1592389">4</a>.</span>  Top-level containers have several panes. To what pane are components added?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1389442" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1592742">5</a>.</span>  Show how to construct a label that contains the message "Select an entry from the list".</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1389713" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1593169">6</a>.</span>  All interaction with GUI components must take place on what thread?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1389949" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1593526">7</a>.</span>  What is the default action command associated with a <span class="bold1">JButton</span>? How can the action command be changed?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1390225" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1594026">8</a>.</span>  What event is generated when a push button is pressed?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1390448" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1594364">9</a>.</span>  Show how to create a text field that has 32 columns.</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1390653" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1594725">10</a>.</span>  Can a <span class="bold1">JTextField</span> have its action command set? If so, how?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1390872" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1595084">11</a>.</span>  What Swing component creates a check box? What event is generated when a check box is selected or deselected?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1391136" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1595559">12</a>.   JList</span> displays a list of items from which the user can select. True or False?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1391376" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1595892">13</a>.</span>  What event is generated when the user selects or deselects an item in a <span class="bold1">JList</span>?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1391616" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1596254">14</a>.</span>  What method sets the selection mode of a <span class="bold1">JList</span>? What method obtains the index of the first selected item?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1391883" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1596742">15</a>.</span>  To create a Swing-based applet, what class must you inherit?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1392098" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1597068">16</a>.</span>  Usually, Swing-based applets use <span class="bold1">invokeAndWait( )</span> to create the initial GUI. True or False?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1392351" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1597422">17</a>.</span>  Add a check box to the file comparer developed in <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_022.html#filepos1253965">Try This 15-1</a> that has the following text: Show position of mismatch. When this box is checked, have the program display the location of the first point in the files at which a mismatch occurs.</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1392776" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1598320">18</a>.</span>  Change the <span class="bold1">ListDemo</span> program so that it allows multiple items in the list to be selected.</span></div>
<div class="calibre47"><span><span class="bold1">19.</span>  Bonus challenge: Convert the Help class developed in <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_011.html#filepos421161">Try This 4-1</a> into a Swing-based GUI program. Display the keywords (<span class="bold1">for</span>, <span class="bold1">while</span>, <span class="bold1">switch</span>, and so on) in a <span class="bold1">JList</span>. When the user selects one, display the keyword’s syntax. To display multiple lines of text within a label, you can use HTML. When doing so, you must begin the text with the sequence <span class="bold1">&lt;html&gt;</span>. When this is done, the text is automatically formatted as described by the markup. In addition to other benefits, using HTML enables you to create labels that span two or more lines. For example, this creates a label that displays two lines of text, with the string "Top" over the string "Bottom".</span></div>
<div class="calibre31"><blockquote class="calibre66"><span><img alt="image" src="images/01035.jpg" class="calibre82"/></span></blockquote></div>
<div class="calibre21"><span>        No answer is shown for this exercise. You have reached the point where you are ready to apply your Java skills on your own!</span></div>  <div class="mbppagebreak" id="calibre_pb_23"></div>
</body></html>
