<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Java&amp;#8482;: A Beginner&amp;#8217;s Guide Sixth Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="filepos693174" class="calibre29"><span><img alt="image" src="images/00003.jpg" class="calibre30"/></span></div><div class="calibre11"> </div>
<div class="calibre31"><span class="calibre2"><span><big class="calibre3"><big class="calibre4"><big class="calibre5"><big class="calibre6"><big class="calibre32"><big class="calibre4">Chapter 8</big></big></big></big></big></big></span></span></div>
<div class="calibre9"><span class="calibre2"><span>Packages and Interfaces</span></span></div><div class="calibre33"> </div>
<div class="calibre1"><span class="calibre10"><span><span class="bold1">Key Skills &amp; Concepts</span></span></span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Use packages</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Understand how packages affect access</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Apply the <span class="bold1">protected</span> access modifier</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Import packages</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Know Java’s standard packages</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Understand interface fundamentals</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Implement an interface</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Apply interface references</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Understand interface variables</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Extend interfaces</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Create default and static interface methods</span></div>
<div class="calibre1"><span><img alt="image" src="images/00004.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre12"><span><span><span class="calibre2">T</span></span>his chapter examines two of Java’s most innovative features: packages and interfaces. <span class="italic">Packages</span> are groups of related classes. Packages help organize your code and provide another layer of encapsulation. An <span class="italic">interface</span> defines a set of methods that will be implemented by a class. Thus, an interface gives you a way to specify what a class will do, but not how it will do it. Packages and interfaces give you greater control over the organization of your program.</span></div>
<div id="filepos696575" class="calibre1"><span class="calibre10"><span><span class="bold1">Packages</span></span></span></div>
<div class="calibre12"><span>In programming, it is often helpful to group related pieces of a program together. In Java, this is accomplished by using a package. A package serves two purposes. First, it provides a mechanism by which related pieces of a program can be organized as a unit. Classes defined within a package must be accessed through their package name. Thus, a package provides a way to name a collection of classes. Second, a package participates in Java’s access control mechanism. Classes defined within a package can be made private to that package and not accessible by code outside the package. Thus, the package provides a means by which classes can be encapsulated. Let’s examine each feature a bit more closely.</span></div>
<div class="calibre23"><span>In general, when you name a class, you are allocating a name from the <span class="italic">namespace</span>. A namespace defines a declarative region. In Java, no two classes can use the same name from the same namespace. Thus, within a given namespace, each class name must be unique. The examples shown in the preceding chapters have all used the default (global) namespace. While this is fine for short sample programs, it becomes a problem as programs grow and the default namespace becomes crowded. In large programs, finding unique names for each class can be difficult. Furthermore, you must avoid name collisions with code created by other programmers working on the same project, and with Java’s library. The solution to these problems is the package because it gives you a way to partition the namespace. When a class is defined within a package, the name of that package is attached to each class, thus avoiding name collisions with other classes that have the same name, but are in other packages.</span></div>
<div class="calibre23"><span>Since a package usually contains related classes, Java defines special access rights to code within a package. In a package, you can define code that is accessible by other code within the same package but not by code outside the package. This enables you to create self-contained groups of related classes that keep their operation private.</span></div>
<div id="filepos698952" class="calibre1"><span class="calibre10"><span><span class="bold1">Defining a Package</span></span></span></div>
<div class="calibre12"><span>All classes in Java belong to some package. When no <span class="bold1">package</span> statement is specified, the default (global) package is used. Furthermore, the default package has no name, which makes the default package transparent. This is why you haven’t had to worry about packages before now. While the default package is fine for short, sample programs, it is inadequate for real applications. Most of the time, you will define one or more packages for your code.</span></div>
<div class="calibre23"><span>To create a package, put a <span class="bold1">package</span> command at the top of a Java source file. The classes declared within that file will then belong to the specified package. Since a package defines a namespace, the names of the classes that you put into the file become part of that package’s namespace.</span></div>
<div class="calibre23"><span>This is the general form of the <span class="bold1">package</span> statement:</span></div>
<div class="calibre27"><span>package <span class="italic">pkg</span>;</span></div>
<div class="calibre27"><span>Here, <span class="italic">pkg</span> is the name of the package. For example, the following statement creates a package called <span class="bold1">mypack</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00533.jpg" class="calibre551"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Java uses the file system to manage packages, with each package stored in its own directory. For example, the <span class="bold1">.class</span> files for any classes you declare to be part of <span class="bold1">mypack</span> must be stored in a directory called <span class="bold1">mypack</span>.</span></div>
<div class="calibre23"><span>Like the rest of Java, package names are case sensitive. This means that the directory in which a package is stored must be precisely the same as the package name. If you have trouble trying the examples in this chapter, remember to check your package and directory names carefully. Lowercase is often used for package names.</span></div>
<div class="calibre23"><span>More than one file can include the same <span class="bold1">package</span> statement. The <span class="bold1">package</span> statement simply specifies to which package the classes defined in a file belong. It does not exclude other classes in other files from being part of that same package. Most real-world packages are spread across many files.</span></div>
<div class="calibre23"><span>You can create a hierarchy of packages. To do so, simply separate each package name from the one above it by use of a period. The general form of a multileveled package statement is shown here:</span></div>
<div class="calibre27"><span>package <span class="italic">pack1.pack2.pack3…packN</span>;</span></div>
<div class="calibre27"><span>Of course, you must create directories that support the package hierarchy that you create. For example,</span></div>
<div class="calibre1"><span><img alt="image" src="images/00534.jpg" class="calibre552"/></span></div><div class="calibre11"> </div>
<div class="calibre27"><span>must be stored in …/alpha/beta/gamma, where … specifies the path to the specified directories.</span></div>
<div id="filepos702439" class="calibre1"><span class="calibre10"><span><span class="bold1">Finding Packages and CLASSPATH</span></span></span></div>
<div class="calibre12"><span>As just explained, packages are mirrored by directories. This raises an important question: How does the Java run-time system know where to look for packages that you create? The answer has three parts. First, by default, the Java run-time system uses the current working directory as its starting point. Thus, if your package is in a subdirectory of the current directory, it will be found. Second, you can specify a directory path or paths by setting the <span class="bold1">CLASSPATH</span> environmental variable. Third, you can use the <span class="bold1">-classpath</span> option with <span class="bold1">java</span> and <span class="bold1">javac</span> to specify the path to your classes.</span></div>
<div class="calibre23"><span>For example, assuming the following package specification:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00535.jpg" class="calibre553"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>In order for a program to find <span class="bold1">mypack</span>, one of three things must be true: The program can be executed from a directory immediately above <span class="bold1">mypack</span>, or <span class="bold1">CLASSPATH</span> must be set to include the path to <span class="bold1">mypack</span>, or the <span class="bold1">-classpath</span> option must specify the path to <span class="bold1">mypack</span> when the program is run via <span class="bold1">java</span>.</span></div>
<div class="calibre23"><span>The easiest way to try the examples shown in this book is to simply create the package directories below your current development directory, put the <span class="bold1">.class</span> files into the appropriate directories, and then execute the programs from the development directory. This is the approach used by the following examples.</span></div>
<div class="calibre23"><span>One last point: To avoid problems, it is best to keep all <span class="bold1">.java</span> and <span class="bold1">.class</span> files associated with a package in that package’s directory. Also, compile each file from the directory above the package directory.</span></div>
<div id="filepos704612" class="calibre1"><span class="calibre10"><span><span class="bold1">A Short Package Example</span></span></span></div>
<div class="calibre12"><span>Keeping the preceding discussion in mind, try this short package example. It creates a simple book database that is contained within a package called <span class="bold1">bookpack</span>.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00536.jpg" class="calibre554"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Call this file <span class="bold1">BookDemo.java</span> and put it in a directory called <span class="bold1">bookpack</span>.</span></div>
<div class="calibre23"><span>Next, compile the file. You can do this by specifying</span></div>
<div class="calibre1"><span><img alt="image" src="images/00537.jpg" class="calibre555"/></span></div><div class="calibre11"> </div>
<div class="calibre27"><span>from the directory directly above <span class="bold1">bookpack</span>. Then try executing the class, using the following command line:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00538.jpg" class="calibre556"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Remember, you will need to be in the directory above <span class="bold1">bookpack</span> when you execute this command. (Or, use one of the other two options described in the preceding section to specify the path to <span class="bold1">bookpack</span>.)</span></div>
<div class="calibre23"><span>As explained, <span class="bold1">BookDemo</span> and <span class="bold1">Book</span> are now part of the package <span class="bold1">bookpack</span>. This means that <span class="bold1">BookDemo</span> cannot be executed by itself. That is, you cannot use this command line:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00539.jpg" class="calibre557"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Instead, <span class="bold1">BookDemo</span> must be qualified with its package name.</span></div>
<div id="filepos706626" class="calibre1"><span class="calibre10"><span><span class="bold1">Packages and Member Access</span></span></span></div>
<div class="calibre12"><span>The preceding chapters have introduced the fundamentals of access control, including the <span class="bold1">private</span> and <span class="bold1">public</span> modifiers, but they have not told the entire story. The reason for this is that packages also participate in Java’s access control mechanism, and a complete discussion had to wait until packages were covered.</span></div>
<div class="calibre23"><span>The visibility of an element is determined by its access specification—<span class="bold1">private</span>, <span class="bold1">public</span>, <span class="bold1">protected</span>, or default—and the package in which it resides. Thus, the visibility of an element is determined by its visibility within a class and its visibility within a package. This multilayered approach to access control supports a rich assortment of access privileges. <a href="#filepos707758">Table 8-1</a> summarizes the various access levels. Let’s examine each access option individually.</span></div>
<div class="calibre28">
<div id="filepos707758" class="calibre44"><span><img alt="image" src="images/00540.jpg" class="calibre223"/></span></div>
<div class="calibre9"><span><img alt="image" src="images/00057.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span><span class="bold1">Table 8-1   Class Member Access</span></span></div><div class="calibre18"> </div>
</div>
<div class="calibre23"><span>If a member of a class has no explicit access modifier, then it is visible within its package but not outside its package. Therefore, you will use the default access specification for elements that you want to keep private to a package but public within that package.</span></div>
<div class="calibre23"><span>Members explicitly declared <span class="bold1">public</span> are visible everywhere, including different classes and different packages. There is no restriction on their use or access. A <span class="bold1">private</span> member is accessible only to the other members of its class. A <span class="bold1">private</span> member is unaffected by its membership in a package. A member specified as <span class="bold1">protected</span> is accessible within its package and to all subclasses, including subclasses in other packages.</span></div>
<div class="calibre23"><span><a href="#filepos707758">Table 8-1</a> applies only to members of classes. A top-level class has only two possible access levels: default and public. When a class is declared as <span class="bold1">public</span>, it is accessible by any other code. If a class has default access, it can be accessed only by other code within its same package. Also, a class that is declared <span class="bold1">public</span> must reside in a file by the same name.</span></div>
<div id="filepos709499" class="calibre1"><span class="calibre10"><span><span class="bold1">A Package Access Example</span></span></span></div>
<div class="calibre12"><span>In the <span class="bold1">package</span> example shown earlier, both <span class="bold1">Book</span> and <span class="bold1">BookDemo</span> were in the same package, so there was no problem with <span class="bold1">BookDemo</span> using <span class="bold1">Book</span> because the default access privilege grants all members of the same package access. However, if <span class="bold1">Book</span> were in one package and <span class="bold1">BookDemo</span> were in another, the situation would be different. In this case, access to <span class="bold1">Book</span> would be denied. To make <span class="bold1">Book</span> available to other packages, you must make three changes. First, <span class="bold1">Book</span> needs to be declared <span class="bold1">public</span>. This makes <span class="bold1">Book</span> visible outside of <span class="bold1">bookpack</span>. Second, its constructor must be made <span class="bold1">public</span>, and finally, its <span class="bold1">show( )</span> method needs to be <span class="bold1">public</span>. This allows them to be visible outside of <span class="bold1">bookpack</span>, too. Thus, to make <span class="bold1">Book</span> usable by other packages, it must be recoded as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00541.jpg" class="calibre558"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>To use <span class="bold1">Book</span> from another package, either you must use the <span class="bold1">import</span> statement described in the next section, or you must fully qualify its name to include its full package specification. For example, here is a class called <span class="bold1">UseBook</span>, which is contained in the <span class="bold1">bookpackext</span> package. It fully qualifies <span class="bold1">Book</span> in order to use it.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00542.jpg" class="calibre559"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Notice how every use of <span class="bold1">Book</span> is preceded with the <span class="bold1">bookpack</span> qualifier. Without this specification, <span class="bold1">Book</span> would not be found when you tried to compile <span class="bold1">UseBook</span>.</span></div>
<div id="filepos711516" class="calibre1"><span class="calibre10"><span><span class="bold1">Understanding Protected Members</span></span></span></div>
<div class="calibre12"><span>Newcomers to Java are sometimes confused by the meaning and use of <span class="bold1">protected</span>. As explained, the <span class="bold1">protected</span> modifier creates a member that is accessible within its package and to subclasses in other packages. Thus, a <span class="bold1">protected</span> member is available for all subclasses to use but is still protected from arbitrary access by code outside its package.</span></div>
<div class="calibre23"><span>To better understand the effects of <span class="bold1">protected</span>, let’s work through an example. First, change the <span class="bold1">Book</span> class so that its instance variables are <span class="bold1">protected</span>, as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00543.jpg" class="calibre560"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Next, create a subclass of <span class="bold1">Book</span>, called <span class="bold1">ExtBook</span>, and a class called <span class="bold1">ProtectDemo</span> that uses <span class="bold1">ExtBook</span>. <span class="bold1">ExtBook</span> adds a field that stores the name of the publisher and several accessor methods. Both of these classes will be in their own package called <span class="bold1">bookpackext</span>. They are shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00544.jpg" class="calibre561"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Look first at the code inside <span class="bold1">ExtBook</span>. Because <span class="bold1">ExtBook</span> extends <span class="bold1">Book</span>, it has access to the <span class="bold1">protected</span> members of <span class="bold1">Book</span>, even though <span class="bold1">ExtBook</span> is in a different package. Thus, it can access <span class="bold1">title</span>, <span class="bold1">author</span>, and <span class="bold1">pubDate</span> directly, as it does in the accessor methods it creates for those variables. However, in <span class="bold1">ProtectDemo</span>, access to these variables is denied because <span class="bold1">ProtectDemo</span> is not a subclass of <span class="bold1">Book</span>. For example, if you remove the comment symbol from the following line, the program will not compile.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00545.jpg" class="calibre480"/></span></div><div class="calibre11"> </div>
<div id="filepos713788" class="calibre1"><span class="calibre10"><span><span class="bold1">Importing Packages</span></span></span></div>
<div class="calibre12"><span>When you use a class from another package, you can fully qualify the name of the class with the name of its package, as the preceding examples have done. However, such an approach could easily become tiresome and awkward, especially if the classes you are qualifying are deeply nested in a package hierarchy. Since Java was invented by programmers for programmers—and programmers don’t like tedious constructs—it should come as no surprise that a more convenient method exists for using the contents of packages: the <span class="bold1">import</span> statement. Using <span class="bold1">import</span> you can bring one or more members of a package into view. This allows you to use those members directly, without explicit package qualification.</span></div>
<div class="calibre35"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   I know that C++ also includes an access specifier called</span> protected. <span class="bold1">Is it similar to Java’s?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   Similar, but not the same. In C++, <span class="bold1">protected</span> creates a member that can be accessed by subclasses but is otherwise private. In Java, <span class="bold1">protected</span> creates a member that can be accessed by any code within its package but only by subclasses outside of its package. You need to be careful of this difference when porting code between C++ and Java.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre23"><span>Here is the general form of the <span class="bold1">import</span> statement:</span></div>
<div class="calibre27"><span>import <span class="italic">pkg.classname</span>;</span></div>
<div class="calibre27"><span>Here, <span class="italic">pkg</span> is the name of the package, which can include its full path, and <span class="italic">classname</span> is the name of the class being imported. If you want to import the entire contents of a package, use an asterisk (<span class="bold1">*</span>) for the class name. Here are examples of both forms:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00546.jpg" class="calibre94"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>In the first case, the <span class="bold1">MyClass</span> class is imported from <span class="bold1">mypack</span>. In the second, all of the classes in <span class="bold1">mypack</span> are imported. In a Java source file, <span class="bold1">import</span> statements occur immediately following the <span class="bold1">package</span> statement (if it exists) and before any class definitions.</span></div>
<div class="calibre23"><span>You can use <span class="bold1">import</span> to bring the <span class="bold1">bookpack</span> package into view so that the <span class="bold1">Book</span> class can be used without qualification. To do so, simply add this <span class="bold1">import</span> statement to the top of any file that uses <span class="bold1">Book</span>.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00547.jpg" class="calibre562"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>For example, here is the <span class="bold1">UseBook</span> class recoded to use <span class="bold1">import</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00548.jpg" class="calibre563"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Notice that you no longer need to qualify <span class="bold1">Book</span> with its package name.</span></div>
<div id="filepos717749" class="calibre1"><span class="calibre10"><span><span class="bold1">Java’s Class Library Is Contained in Packages</span></span></span></div>
<div class="calibre12"><span>As explained earlier in this book, Java defines a large number of standard classes that are available to all programs. This class library is often referred to as the Java API (Application Programming Interface). The Java API is stored in packages. At the top of the package hierarchy is <span class="bold1">java</span>. Descending from <span class="bold1">java</span> are several subpackages. Here are a few examples:</span></div>
<div class="calibre11"> </div><table cellpadding="0" cellspacing="0" border="0" class="calibre37">
<tr class="calibre41">
<td valign="top" class="calibre83"><span class="bold1">Subpackage</span></td>
<td valign="top" class="calibre83"><span class="bold1">Description</span></td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">java.lang</td>
<td valign="top" class="calibre42">Contains a large number of general-purpose classes</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">java.io</td>
<td valign="top" class="calibre42">Contains I/O classes</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">java.net</td>
<td valign="top" class="calibre42">Contains classes that support networking</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">java.applet</td>
<td valign="top" class="calibre42">Contains classes for creating applets</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">java.awt</td>
<td valign="top" class="calibre42">Contains classes that support the Abstract Window Toolkit</td>
</tr>
</table><div class="calibre43"> </div>
<div class="calibre23"><span>Since the beginning of this book, you have been using <span class="bold1">java.lang</span>. It contains, among several others, the <span class="bold1">System</span> class, which you have been using when performing output using <span class="bold1">println( )</span>. The <span class="bold1">java.lang</span> package is unique because it is imported automatically into every Java program. This is why you did not have to import <span class="bold1">java.lang</span> in the preceding sample programs. However, you must explicitly import the other packages. We will be examining several packages in subsequent chapters.</span></div>
<div id="filepos720287" class="calibre1"><span class="calibre10"><span><span class="bold1">Interfaces</span></span></span></div>
<div class="calibre12"><span>In object-oriented programming, it is sometimes helpful to define what a class must do but not how it will do it. You have already seen an example of this: the abstract method. An abstract method defines the signature for a method but provides no implementation. A subclass must provide its own implementation of each abstract method defined by its superclass. Thus, an abstract method specifies the <span class="italic">interface</span> to the method but not the <span class="italic">implementation</span>. While abstract classes and methods are useful, it is possible to take this concept a step further. In Java, you can fully separate a class’ interface from its implementation by using the keyword <span class="bold1">interface</span>.</span></div>
<div class="calibre23"><span>An <span class="bold1">interface</span> is syntactically similar to an abstract class, in that you can specify one or more methods that have no body. Those methods must be implemented by a class in order for their actions to be defined. Thus, an interface specifies what must be done, but not how to do it. Once an interface is defined, any number of classes can implement it. Also, one class can implement any number of interfaces.</span></div>
<div class="calibre23"><span>To implement an interface, a class must provide bodies (implementations) for the methods described by the interface. Each class is free to determine the details of its own implementation. Two classes might implement the same interface in different ways, but each class still supports the same set of methods. Thus, code that has knowledge of the interface can use objects of either class since the interface to those objects is the same. By providing the <span class="bold1">interface</span> keyword, Java allows you to fully utilize the “one interface, multiple methods” aspect of polymorphism.</span></div>
<div class="calibre23"><span>Before continuing an important point needs to be made. JDK 8 added a feature to <span class="bold1">interface</span> that makes a significant change to its capabilities. Prior to JDK 8, an interface could not define any implementation whatsoever. Thus, prior to JDK 8, an interface could define only what, but not how, as just described. JDK 8 changes this. Today, it is possible to add a <span class="italic">default implementation</span> to an interface method. Thus, it is now possible for <span class="bold1">interface</span> to specify some behavior. However, default methods constitute what is, in essence, a special-use feature, and the original intent behind <span class="bold1">interface</span> still remains. Therefore, as a general rule, you will still often create and use interfaces in which no default methods exist. For this reason, we will begin by discussing the interface in its traditional form. The default method is described at the end of this chapter.</span></div>
<div class="calibre23"><span>Here is a simplified general form of a traditional interface:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00549.jpg" class="calibre564"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, <span class="italic">access</span> is either <span class="bold1">public</span> or not used. When no access modifier is included, then default access results, and the interface is available only to other members of its package. When it is declared as <span class="bold1">public</span>, the interface can be used by any other code. (When an <span class="bold1">interface</span> is declared <span class="bold1">public</span>, it must be in a file of the same name.) <span class="italic">name</span> is the name of the interface and can be any valid identifier.</span></div>
<div class="calibre23"><span>In the traditional form of an interface, methods are declared using only their return type and signature. They are, essentially, abstract methods. Thus, each class that includes such an <span class="bold1">interface</span> must implement all of its methods. In an interface, methods are implicitly <span class="bold1">public</span>.</span></div>
<div class="calibre23"><span>Variables declared in an <span class="bold1">interface</span> are not instance variables. Instead, they are implicitly <span class="bold1">public</span>, <span class="bold1">final</span>, and <span class="bold1">static</span> and must be initialized. Thus, they are essentially constants. Here is an example of an <span class="bold1">interface</span> definition. It specifies the interface to a class that generates a series of numbers.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00550.jpg" class="calibre565"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>This interface is declared <span class="bold1">public</span> so that it can be implemented by code in any package.</span></div>
<div id="filepos725104" class="calibre1"><span class="calibre10"><span><span class="bold1">Implementing Interfaces</span></span></span></div>
<div class="calibre12"><span>Once an <span class="bold1">interface</span> has been defined, one or more classes can implement that interface. To implement an interface, include the <span class="bold1">implements</span> clause in a class definition and then create the methods required by the interface. The general form of a class that includes the <span class="bold1">implements</span> clause looks like this:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00551.jpg" class="calibre566"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>To implement more than one interface, the interfaces are separated with a comma. Of course, the <span class="bold1">extends</span> clause is optional.</span></div>
<div class="calibre23"><span>The methods that implement an interface must be declared <span class="bold1">public</span>. Also, the type signature of the implementing method must match exactly the type signature specified in the <span class="bold1">interface</span> definition.</span></div>
<div class="calibre23"><span>Here is an example that implements the <span class="bold1">Series</span> interface shown earlier. It creates a class called <span class="bold1">ByTwos</span>, which generates a series of numbers, each two greater than the previous one.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00552.jpg" class="calibre567"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Notice that the methods <span class="bold1">getNext( )</span>, <span class="bold1">reset( )</span>, and <span class="bold1">setStart( )</span> are declared using the <span class="bold1">public</span> access specifier. This is necessary. Whenever you implement a method defined by an interface, it must be implemented as <span class="bold1">public</span> because all members of an interface are implicitly <span class="bold1">public</span>.</span></div>
<div class="calibre23"><span>Here is a class that demonstrates <span class="bold1">ByTwos</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00553.jpg" class="calibre568"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>The output from this program is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00554.jpg" class="calibre569"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>It is both permissible and common for classes that implement interfaces to define additional members of their own. For example, the following version of <span class="bold1">ByTwos</span> adds the method <span class="bold1">getPrevious( )</span>, which returns the previous value:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00555.jpg" class="calibre570"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Notice that the addition of <span class="bold1">getPrevious( )</span> required a change to the implementations of the methods defined by <span class="bold1">Series</span>. However, since the interface to those methods stays the same, the change is seamless and does not break preexisting code. This is one of the advantages of interfaces.</span></div>
<div class="calibre23"><span>As explained, any number of classes can implement an <span class="bold1">interface</span>. For example, here is a class called <span class="bold1">ByThrees</span> that generates a series that consists of multiples of three:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00556.jpg" class="calibre571"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>One more point: If a class includes an interface but does not fully implement the methods defined by that interface, then that class must be declared as <span class="bold1">abstract</span>. No objects of such a class can be created, but it can be used as an abstract superclass, allowing subclasses to provide the complete implementation.</span></div>
<div id="filepos729095" class="calibre1"><span class="calibre10"><span><span class="bold1">Using Interface References</span></span></span></div>
<div class="calibre12"><span>You might be somewhat surprised to learn that you can declare a reference variable of an interface type. In other words, you can create an interface reference variable. Such a variable can refer to any object that implements its interface. When you call a method on an object through an interface reference, it is the version of the method implemented by the object that is executed. This process is similar to using a superclass reference to access a subclass object, as described in <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_014.html#filepos626773">Chapter 7</a>.</span></div>
<div class="calibre23"><span>The following example illustrates this process. It uses the same interface reference variable to call methods on objects of both <span class="bold1">ByTwos</span> and <span class="bold1">ByThrees</span>.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00557.jpg" class="calibre572"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00558.jpg" class="calibre573"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>In <span class="bold1">main( )</span>, <span class="bold1">ob</span> is declared to be a reference to a <span class="bold1">Series</span> interface. This means that it can be used to store references to any object that implements <span class="bold1">Series</span>. In this case, it is used to refer to <span class="bold1">twoOb</span> and <span class="bold1">threeOb</span>, which are objects of type <span class="bold1">ByTwos</span> and <span class="bold1">ByThrees</span>, respectively, which both implement <span class="bold1">Series</span>. An interface reference variable has knowledge only of the methods declared by its <span class="bold1">interface</span> declaration. Thus, <span class="bold1">ob</span> could not be used to access any other variables or methods that might be supported by the object.</span></div>
<div class="calibre18"> </div><table cellspacing="0" cellpadding="0" class="calibre37">
<colgroup class="calibre38">
<col class="calibre72"/>
<col class="calibre73"/>
</colgroup>
<tr class="calibre41">
<td valign="top" id="filepos731136" class="calibre74"><span class="calibre10"><span class="bold1">Try This 8-1</span> </span></td>
<td valign="top" class="calibre75"><span class="calibre10">Creating a Queue Interface</span></td>
</tr></table><div class="calibre43"> </div>
<div class="calibre1"><span><img alt="image" src="images/00559.jpg" class="calibre574"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>To see the power of interfaces in action, we will look at a practical example. In earlier chapters, you developed a class called <span class="bold1">Queue</span> that implemented a simple fixed-size queue for characters. However, there are many ways to implement a queue. For example, the queue can be of a fixed size or it can be “growable.” The queue can be linear, in which case it can be used up, or it can be circular, in which case elements can be put in as long as elements are being taken off. The queue can also be held in an array, a linked list, a binary tree, and so on. No matter how the queue is implemented, the interface to the queue remains the same, and the methods <span class="bold1">put( )</span> and <span class="bold1">get( )</span> define the interface to the queue independently of the details of the implementation. Because the interface to a queue is separate from its implementation, it is easy to define a queue interface, leaving it to each implementation to define the specifics.</span></div>
<div class="calibre23"><span>In this project, you will create an interface for a character queue and three implementations. All three implementations will use an array to store the characters. One queue will be the fixed-size, linear queue developed earlier. Another will be a circular queue. In a circular queue, when the end of the underlying array is encountered, the get and put indices automatically loop back to the start. Thus, any number of items can be stored in a circular queue as long as items are also being taken out. The final implementation creates a dynamic queue, which grows as necessary when its size is exceeded.</span></div>
<div class="calibre19"><span>  <span class="bold1">1.</span>  Create a file called <span class="bold1">ICharQ.java</span> and put into that file the following interface definition:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00560.jpg" class="calibre575"/></span></div>
<div class="calibre47"><span>        As you can see, this interface is very simple, consisting of only two methods. Each class that implements <span class="bold1">ICharQ</span> will need to implement these methods.</span></div>
<div class="calibre47"><span>  <span class="bold1">2.</span>  Create a file called <span class="bold1">IQDemo.java</span>.</span></div>
<div class="calibre47"><span>  <span class="bold1">3.</span>  Begin creating <span class="bold1">IQDemo.java</span> by adding the <span class="bold1">FixedQueue</span> class shown here:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00561.jpg" class="calibre576"/></span></div>
<div class="calibre47"><span>        This implementation of <span class="bold1">ICharQ</span> is adapted from the <span class="bold1">Queue</span> class shown in <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_012.html#filepos452160">Chapter 5</a> and should already be familiar to you.</span></div>
<div class="calibre47"><span>  <span class="bold1">4.</span>  To <span class="bold1">IQDemo.java</span> add the <span class="bold1">CircularQueue</span> class shown here. It implements a circular queue for characters.</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00562.jpg" class="calibre577"/></span></div>
<div class="calibre47"><span>        The circular queue works by reusing space in the array that is freed when elements are retrieved. Thus, it can store an unlimited number of elements as long as elements are also being removed. While conceptually simple—just reset the appropriate index to zero when the end of the array is reached—the boundary conditions are a bit confusing at first. In a circular queue, the queue is full not when the end of the underlying array is reached, but rather when storing an item would cause an unretrieved item to be overwritten. Thus, <span class="bold1">put( )</span> must check several conditions in order to determine if the queue is full. As the comments suggest, the queue is full when either <span class="bold1">putloc</span> is one less than <span class="bold1">getloc</span>, or if <span class="bold1">putloc</span> is at the end of the array and <span class="bold1">getloc</span> is at the beginning. As before, the queue is empty when <span class="bold1">getloc</span> and <span class="bold1">putloc</span> are equal. To make these checks easier, the underlying array is created one size larger than the queue size.</span></div>
<div class="calibre47"><span>  <span class="bold1">5.</span>  Put into <span class="bold1">IQDemo.java</span> the <span class="bold1">DynQueue</span> class shown next. It implements a “growable” queue that expands its size when space is exhausted.</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00563.jpg" class="calibre578"/></span></div>
<div class="calibre47"><span>        In this queue implementation, when the queue is full, an attempt to store another element causes a new underlying array to be allocated that is twice as large as the original, the current contents of the queue are copied into this array, and a reference to the new array is stored in <span class="bold1">q</span>.</span></div>
<div class="calibre47"><span>  <span class="bold1">6.</span>  To demonstrate the three <span class="bold1">ICharQ</span> implementations, enter the following class into <span class="bold1">IQDemo.java</span>. It uses an <span class="bold1">ICharQ</span> reference to access all three queues.</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00564.jpg" class="calibre579"/></span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00565.jpg" class="calibre580"/></span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00566.jpg" class="calibre581"/></span></div>
<div class="calibre47"><span>  <span class="bold1">7.</span>  The output from this program is shown here:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00567.jpg" class="calibre582"/></span></div>
<div class="calibre47"><span>  <span class="bold1">8.</span>  Here are some things to try on your own. Create a circular version of <span class="bold1">DynQueue</span>. Add a <span class="bold1">reset( )</span> method to <span class="bold1">ICharQ</span>, which resets the queue. Create a <span class="bold1">static</span> method that copies the contents of one type of queue into another.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos739244" class="calibre9"><span class="calibre10"><span><span class="bold1">Variables in Interfaces</span></span></span></div>
<div class="calibre12"><span>As mentioned, variables can be declared in an interface, but they are implicitly <span class="bold1">public</span>, <span class="bold1">static</span>, and <span class="bold1">final</span>. At first glance, you might think that there would be very limited use for such variables, but the opposite is true. Large programs typically make use of several constant values that describe such things as array size, various limits, special values, and the like. Since a large program is typically held in a number of separate source files, there needs to be a convenient way to make these constants available to each file. In Java, interface variables offer one solution.</span></div>
<div class="calibre23"><span>To define a set of shared constants, create an <span class="bold1">interface</span> that contains only these constants, without any methods. Each file that needs access to the constants simply “implements” the interface. This brings the constants into view. Here is an example:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00568.jpg" class="calibre583"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span class="calibre10"><span><span class="bold1"><span class="italic">NOTE</span></span></span></span></div>
<div class="calibre9"><span><img alt="image" src="images/00006.jpg" class="calibre45"/></span></div>
<div class="calibre9"><span>The technique of using an <span class="bold1">interface</span> to define shared constants is controversial. It is described here for completeness.</span></div><div class="calibre11"> </div>
<div id="filepos740964" class="calibre1"><span class="calibre10"><span><span class="bold1">Interfaces Can Be Extended</span></span></span></div>
<div class="calibre12"><span>One interface can inherit another by use of the keyword <span class="bold1">extends</span>. The syntax is the same as for inheriting classes. When a class implements an interface that inherits another interface, it must provide implementations for all methods required by the interface inheritance chain. Following is an example:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00569.jpg" class="calibre584"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>As an experiment, you might try removing the implementation for <span class="bold1">meth1( )</span> in <span class="bold1">MyClass</span>. This will cause a compile-time error. As stated earlier, any class that implements an interface must implement all methods required by that interface, including any that are inherited from other interfaces.</span></div>
<div id="filepos741979" class="calibre1"><span class="calibre10"><span><span class="bold1">Default Interface Methods</span></span></span></div>
<div class="calibre12"><span>As explained earlier, prior to JDK 8, an interface could not define any implementation whatsoever. This meant that for all previous versions of Java, the methods specified by an interface were abstract, containing no body. This is the traditional form of an interface and is the type of interface that the preceding discussions have used. The release of JDK 8 changed this by adding a new capability to <span class="bold1">interface</span> called the <span class="italic">default method</span>. A default method lets you define a default implementation for an interface method. In other words, by use of a default method, it is now possible for an interface method to provide a body, rather than being abstract. During its development, the default method was also referred to as an <span class="italic">extension method</span>, and you will likely see both terms used.</span></div>
<div class="calibre23"><span>A primary motivation for the default method was to provide a means by which interfaces could be expanded without breaking existing code. Recall that there must be implementations for all methods defined by an interface. In the past, if a new method were added to a popular, widely used interface, then the addition of that method would break existing code because no implementation would be found for that method. The default method solves this problem by supplying an implementation that will be used if no other implementation is explicitly provided. Thus, the addition of a default method will not cause preexisting code to break.</span></div>
<div class="calibre23"><span>Another motivation for the default method was the desire to specify methods in an interface that are, essentially, optional, depending on how the interface is used. For example, an interface might define a group of methods that act on a sequence of elements. One of these methods might be called <span class="bold1">remove( )</span>, and its purpose is to remove an element from the sequence. However, if the interface is intended to support both modifiable and non-modifiable sequences, then <span class="bold1">remove( )</span> is essentially optional because it won’t be used by non-modifiable sequences. In the past, a class that implemented a non-modifiable sequence would have had to define an empty implementation of <span class="bold1">remove( )</span>, even though it was not needed. Today, a default implementation for <span class="bold1">remove( )</span> can be specified in the interface that either does nothing or reports an error. Providing this default prevents a class used for non-modifiable sequences from having to define its own, placeholder version of <span class="bold1">remove( )</span>. Thus, by providing a default, the interface makes the implementation of <span class="bold1">remove( )</span> by a class optional.</span></div>
<div class="calibre23"><span>It is important to point out that the addition of default methods does not change a key aspect of <span class="bold1">interface</span>: an interface still cannot have instance variables. Thus, the defining difference between an interface and a class is that a class can maintain state information, but an interface cannot. Furthermore, it is still not possible to create an instance of an interface by itself. It must be implemented by a class. Therefore, even though, beginning with JDK 8, an interface can define default methods, the interface must still be implemented by a class if an instance is to be created.</span></div>
<div class="calibre23"><span>One last point: As a general rule, default methods constitute a special-purpose feature. Interfaces that you create will still be used primarily to specify what and not how. However, the inclusion of the default method gives you added flexibility.</span></div>
<div id="filepos745875" class="calibre1"><span class="calibre10"><span><span class="bold1">Default Method Fundamentals</span></span></span></div>
<div class="calibre12"><span>An interface default method is defined similar to the way a method is defined by a <span class="bold1">class</span>. The primary difference is that the declaration is preceded by the keyword <span class="bold1">default</span>. For example, consider this simple interface:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00570.jpg" class="calibre585"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span><span class="bold1">MyIF</span> declares two methods. The first, <span class="bold1">getUserID( )</span>, is a standard interface method declaration. It defines no implementation whatsoever. The second method is <span class="bold1">getAdminID( )</span>, and it does include a default implementation. In this case, it simply returns 1. Pay special attention to the way <span class="bold1">getAdminID( )</span> is declared. Its declaration is preceded by the <span class="bold1">default</span> modifier. This syntax can be generalized. To define a default method, precede its declaration with <span class="bold1">default</span>.</span></div>
<div class="calibre23"><span>Because <span class="bold1">getAdminID( )</span> includes a default implementation, it is not necessary for an implementing class to override it. In other words, if an implementing class does not provide its own implementation, the default is used. For example, the <span class="bold1">MyIFImp</span> class shown next is perfectly valid:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00571.jpg" class="calibre586"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>The following code creates an instance of <span class="bold1">MyIFImp</span> and uses it to call both <span class="bold1">getUserID( )</span> and <span class="bold1">getAdminID( )</span>.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00572.jpg" class="calibre587"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The output is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00573.jpg" class="calibre588"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>As you can see, the default implementation of <span class="bold1">getAdminID( )</span> was automatically used. It was not necessary for <span class="bold1">MyIFImp</span> to define it. Thus, for <span class="bold1">getAdminID( )</span>, implementation by a class is optional. (Of course, its implementation by a class will be <span class="italic">required</span> if the class needs to return a different ID.)</span></div>
<div class="calibre23"><span>It is both possible and common for an implementing class to define its own implementation of a default method. For example, <span class="bold1">MyIFImp2</span> overrides <span class="bold1">getAdminID( )</span>, as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00574.jpg" class="calibre589"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Now, when <span class="bold1">getAdminID( )</span> is called, a value other than its default is returned.</span></div>
<div id="filepos749021" class="calibre1"><span class="calibre10"><span><span class="bold1">A More Practical Example of a Default Method</span></span></span></div>
<div class="calibre12"><span>Although the preceding shows the mechanics of using default methods, it doesn’t illustrate their usefulness in a more practical setting. To do this, let’s return to the <span class="bold1">Series</span> interface shown earlier in this chapter. For the sake of discussion, assume that <span class="bold1">Series</span> is widely used and many programs rely on it. Further assume that through an analysis of usage patterns, it was discovered that many implementations of <span class="bold1">Series</span> were adding a method that returned an array that contained the next <span class="italic">n</span> elements in the series. Given this situation, you decide to enhance <span class="bold1">Series</span> so that it includes such a method, calling the new method <span class="bold1">getNextArray( )</span> and declaring it as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00575.jpg" class="calibre590"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, <span class="bold1">n</span> specifies the number of elements to retrieve. Prior to default methods, adding this method to <span class="bold1">Series</span> would have broken preexisting code because existing implementations would not have defined the method. However, by providing a default for this new method, it can be added to <span class="bold1">Series</span> without causing harm. Let’s work through the process.</span></div>
<div class="calibre23"><span>In some cases, when a default method is added to an existing interface, its implementation simply reports an error if an attempt is made to use the default. This approach is necessary in the case of default methods for which no implementation can be provided that will work in all cases. These types of default methods define what is, essentially, optional code. However, in some cases, you can define a default method that will work in all cases. This is the situation for <span class="bold1">getNextArray( )</span>. Because <span class="bold1">Series</span> already requires that a class implement <span class="bold1">getNext( )</span>, the default version of <span class="bold1">getNextArray( )</span> can use it. Thus, here is one way to implement the new version of <span class="bold1">Series</span> that includes the default <span class="bold1">getNextArray( )</span> method:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00576.jpg" class="calibre591"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Pay special attention to the way that the default method <span class="bold1">getNextArray( )</span> is implemented. Because <span class="bold1">getNext( )</span> was part of the original specification for <span class="bold1">Series</span>, any class that implements <span class="bold1">Series</span> will provide that method. Thus, it can be used inside <span class="bold1">getNextArray( )</span> to obtain the next <span class="italic">n</span> elements in the series. As a result, any class that implements the enhanced version of <span class="bold1">Series</span> will be able to use <span class="bold1">getNextArray( )</span> as is, and no class is required to override it. Therefore, no preexisting code is broken. Of course, it is still possible for a class to provide its own implementation of <span class="bold1">getNextArray( )</span>, if you choose.</span></div>
<div class="calibre23"><span>As the preceding example shows, the default method provides two major benefits:</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   It gives you a way to gracefully evolve interfaces over time without breaking existing code.</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   It provides optional functionality without requiring that a class provide a placeholder implementation when that functionality is not needed.</span></div>
<div class="calibre27"><span>In the case of <span class="bold1">getNextArray( )</span>, the second point is especially important. If an implementation of <span class="bold1">Series</span> does not require the capability offered by <span class="bold1">getNextArray( )</span>, it need not provide its own placeholder implementation. This allows cleaner code to be created.</span></div>
<div id="filepos753299" class="calibre1"><span class="calibre10"><span><span class="bold1">Multiple Inheritance Issues</span></span></span></div>
<div class="calibre12"><span>As explained earlier in this book, Java does not support the multiple inheritance of classes. Now that an interface can include default methods, you might be wondering if an interface can provide a way around this restriction. The answer is, essentially, no. Recall that there is still a key difference between a class and an interface: a class can maintain state information (through the use of instance variables), but an interface cannot.</span></div>
<div class="calibre23"><span>The preceding notwithstanding, default methods do offer a bit of what one would normally associate with the concept of multiple inheritance. For example, you might have a class that implements two interfaces. If each of these interfaces provides default methods, then some behavior is inherited from both. Thus, to a limited extent, default methods do support multiple inheritance of behavior. As you might guess, in such a situation, it is possible that a name conflict will occur.</span></div>
<div class="calibre23"><span>For example, assume that two interfaces called <span class="bold1">Alpha</span> and <span class="bold1">Beta</span> are implemented by a class called <span class="bold1">MyClass</span>. What happens if both <span class="bold1">Alpha</span> and <span class="bold1">Beta</span> provide a method called <span class="bold1">reset( )</span> for which both declare a default implementation? Is the version by <span class="bold1">Alpha</span> or the version by <span class="bold1">Beta</span> used by <span class="bold1">MyClass</span>? Or, consider a situation in which <span class="bold1">Beta</span> extends <span class="bold1">Alpha</span>. Which version of the default method is used? Or, what if <span class="bold1">MyClass</span> provides its own implementation of the method? To handle these and other similar types of situations, Java defines a set of rules that resolve such conflicts.</span></div>
<div class="calibre23"><span>First, in all cases a class implementation takes priority over an interface default implementation. Thus, if <span class="bold1">MyClass</span> provides an override of the <span class="bold1">reset( )</span> default method, <span class="bold1">MyClass</span>’s version is used. This is the case even if <span class="bold1">MyClass</span> implements both <span class="bold1">Alpha</span> and <span class="bold1">Beta</span>. In this case, both defaults are overridden by <span class="bold1">MyClass</span>’s implementation.</span></div>
<div class="calibre23"><span>Second, in cases in which a class inherits two interfaces that both have the same default method, if the class does not override that method, then an error will result. Continuing with the example, if <span class="bold1">MyClass</span> inherits both <span class="bold1">Alpha</span> and <span class="bold1">Beta</span>, but does not override <span class="bold1">reset( )</span>, then an error will occur.</span></div>
<div class="calibre23"><span>In cases in which one interface inherits another, with both defining a common default method, the inheriting interface’s version of the method takes precedence. Therefore, continuing the example, if <span class="bold1">Beta</span> extends <span class="bold1">Alpha</span>, then <span class="bold1">Beta</span>’s version of <span class="bold1">reset( )</span> will be used.</span></div>
<div class="calibre23"><span>It is possible to refer explicitly to a default implementation by using a new form of <span class="bold1">super</span>. Its general form is shown here:</span></div>
<div class="calibre592"><span><span class="italic">InterfaceName</span>.super.<span class="italic">methodName( )</span></span></div>
<div class="calibre27"><span>For example, if <span class="bold1">Beta</span> wants to refer to <span class="bold1">Alpha</span>’s default for <span class="bold1">reset( )</span>, it can use this statement:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00577.jpg" class="calibre593"/></span></div><div class="calibre11"> </div>
<div id="filepos757105" class="calibre1"><span class="calibre10"><span><span class="bold1">Use static Methods in an Interface</span></span></span></div>
<div class="calibre12"><span>JDK 8 added another new capability to <span class="bold1">interface</span>: the ability to define one or more <span class="bold1">static</span> methods. Like <span class="bold1">static</span> methods in a class, a <span class="bold1">static</span> method defined by an interface can be called independently of any object. Thus, no implementation of the interface is necessary, and no instance of the interface is required in order to call a <span class="bold1">static</span> method. Instead, a <span class="bold1">static</span> method is called by specifying the interface name, followed by a period, followed by the method name. Here is the general form:</span></div>
<div class="calibre592"><span><span class="italic">InterfaceName</span>.<span class="italic">staticMethodName</span></span></div>
<div class="calibre27"><span>Notice that this is similar to the way that a <span class="bold1">static</span> method in a class is called.</span></div>
<div class="calibre23"><span>The following shows an example of a <span class="bold1">static</span> method in an interface by adding one to <span class="bold1">MyIF</span>, shown earlier. The <span class="bold1">static</span> method is <span class="bold1">getUniversalID( )</span>. It returns zero.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00578.jpg" class="calibre594"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The <span class="bold1">getUniversalID( )</span> method can be called, as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00579.jpg" class="calibre324"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>As mentioned, no implementation or instance of <span class="bold1">MyIF</span> is required to call <span class="bold1">getUniversalID( )</span> because it is <span class="bold1">static</span>.</span></div>
<div class="calibre23"><span>One last point: <span class="bold1">static</span> interface methods are not inherited by either an implementing class or a subinterface.</span></div>
<div id="filepos759150" class="calibre1"><span class="calibre10"><span><span class="bold1">Final Thoughts on Packages and Interfaces</span></span></span></div>
<div class="calibre12"><span>Although the examples we’ve included in this book do not make frequent use of packages or interfaces, both of these tools are an important part of the Java programming environment. Virtually all real programs that you write in Java will be contained within packages. A number will probably implement interfaces as well. It is important, therefore, that you be comfortable with their usage.</span></div>
<div id="filepos759753" class="calibre44"><span class="calibre10"><span><img alt="image" src="images/00059.jpg" class="calibre104"/>   <span class="bold1"><span class="italic">Chapter 8 Self Test</span></span></span></span></div><div class="calibre11"> </div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos760033" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1532281">1</a>.</span>  Using the code from <a href="#filepos731136">Try This 8-1</a>, put the <span class="bold1">ICharQ</span> interface and its three implementations into a package called <span class="bold1">qpack</span>. Keeping the queue demonstration class <span class="bold1">IQDemo</span> in the default package, show how to import and use the classes in <span class="bold1">qpack</span>.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos760491" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1533565">2</a>.</span>  What is a namespace? Why is it important that Java allows you to partition the namespace?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos760748" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1534019">3</a>.</span>  Packages are stored in ______________.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos760954" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1534329">4</a>.</span>  Explain the difference between <span class="bold1">protected</span> and default access.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos761189" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1534926">5</a>.</span>  Explain the two ways that the members of a package can be used by other packages.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos761438" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1535382">6</a>.</span>  “One interface, multiple methods” is a key tenet of Java. What feature best exemplifies it?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos761711" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1535836">7</a>.</span>  How many classes can implement an interface? How many interfaces can a class implement?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos761966" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1536310">8</a>.</span>  Can interfaces be extended?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos762161" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1536634">9</a>.</span>  Create an interface for the <span class="bold1">Vehicle</span> class from <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_014.html#filepos626773">Chapter 7</a>. Call the interface <span class="bold1">IVehicle</span>.</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos762440" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1537070">10</a>.</span>  Variables declared in an interface are implicitly <span class="bold1">static</span> and <span class="bold1">final</span>. Can they be shared with other parts of a program?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos762725" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1537607">11</a>.</span>  A package is, in essence, a container for classes. True or False?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos762944" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1537928">12</a>.</span>  What standard Java package is automatically imported into a program?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos763166" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1538263">13</a>.</span>  What keyword is used to declare a default <span class="bold1">interface</span> method?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos763386" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1538594">14</a>.</span>  Beginning with JDK 8, is it possible to define a <span class="bold1">static</span> method in an <span class="bold1">interface</span>?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos763633" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1538941">15</a>.</span>  Assume that the <span class="bold1">ICharQ</span> interface shown in <a href="#filepos731136">Try This 8-1</a> has been in widespread use for several years. Now, you want to add a method to it called <span class="bold1">reset( )</span>, which will be used to reset the queue to its empty, starting condition. Assuming JDK 8 or later, how can this be accomplished without breaking preexisting code?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos764142" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1540095">16</a>.</span>  How is a <span class="bold1">static</span> method in an interface called?</span></div>  <div class="mbppagebreak" id="calibre_pb_15"></div>
</body></html>
