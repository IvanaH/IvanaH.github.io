<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Java&amp;#8482;: A Beginner&amp;#8217;s Guide Sixth Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="filepos994143" class="calibre29"><span><img alt="image" src="images/00003.jpg" class="calibre30"/></span></div><div class="calibre11"> </div>
<div class="calibre31"><span class="calibre2"><span><big class="calibre3"><big class="calibre4"><big class="calibre5"><big class="calibre6"><big class="calibre32"><big class="calibre4">Chapter 12</big></big></big></big></big></big></span></span></div>
<div class="calibre9"><span class="calibre2"><span>Enumerations, Autoboxing, Static Import, and Annotations</span></span></div><div class="calibre33"> </div>
<div class="calibre1"><span class="calibre10"><span><span class="bold1">Key Skills &amp; Concepts</span></span></span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Understand enumeration fundamentals</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Use the class-based features of enumerations</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Apply the <span class="bold1">values( )</span> and <span class="bold1">valueof( )</span> methods to enumerations</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Create enumerations that have constructors, instance variables, and methods</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Employ the <span class="bold1">ordinal( )</span> and <span class="bold1">compareTo( )</span> methods that enumerations inherit from <span class="bold1">Enum</span></span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Use Java’s type wrappers</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Know the basics of autoboxing and auto-unboxing</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Use autoboxing with methods</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Understand how autoboxing works with expressions</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Apply static import</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Gain an overview of annotations</span></div>
<div class="calibre1"><span><img alt="image" src="images/00004.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre12"><span><span><span class="calibre2"><span class="bold1">T</span></span></span>his chapter discusses enumerations, autoboxing, static import, and annotations. Although none of these were part of the original definition of Java, each having been added by JDK 5, they significantly enhanced the power and usability of the language. In the case of enumerations and autoboxing, both addressed what was, at the time, long-standing needs. Static import streamlined the use of static members. Annotations expanded the kinds of information that can be embedded within a source file. Collectively, these features offered a better way to solve common programming problems. Frankly, today, it is difficult to imagine Java without them. They have become that important. Also discussed in this chapter are Java’s type wrappers.</span></div>
<div id="filepos998065" class="calibre1"><span class="calibre10"><span><span class="bold1">Enumerations</span></span></span></div>
<div class="calibre12"><span>In its simplest form, an <span class="italic">enumeration</span> is a list of named constants that define a new data type. An object of an enumeration type can hold only the values that are defined by the list. Thus, an enumeration gives you a way to precisely define a new type of data that has a fixed number of valid values.</span></div>
<div class="calibre23"><span>Enumerations are common in everyday life. For example, an enumeration of the coins used in the United States is penny, nickel, dime, quarter, half-dollar, and dollar. An enumeration of the months in the year consists of the names January through December. An enumeration of the days of the week is Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, and Saturday.</span></div>
<div class="calibre23"><span>From a programming perspective, enumerations are useful whenever you need to define a set of values that represent a collection of items. For example, you might use an enumeration to represent a set of status codes, such as success, waiting, failed, and retrying, which indicate the progress of some action. In the past, such values were defined as <span class="bold1">final</span> variables, but enumerations offer a more structured approach.</span></div>
<div id="filepos999485" class="calibre1"><span class="calibre10"><span><span class="bold1">Enumeration Fundamentals</span></span></span></div>
<div class="calibre12"><span>An enumeration is created using the <span class="bold1">enum</span> keyword. For example, here is a simple enumeration that lists various forms of transportation:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00724.jpg" class="calibre722"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The identifiers <span class="bold1">CAR</span>, <span class="bold1">TRUCK</span>, and so on, are called <span class="italic">enumeration constants</span>. Each is implicitly declared as a public, static member of <span class="bold1">Transport</span>. Furthermore, the enumeration constants’ type is the type of the enumeration in which the constants are declared, which is <span class="bold1">Transport</span> in this case. Thus, in the language of Java, these constants are called <span class="italic">self-typed</span>, where “self” refers to the enclosing enumeration.</span></div>
<div class="calibre23"><span>Once you have defined an enumeration, you can create a variable of that type. However, even though enumerations define a class type, you do not instantiate an <span class="bold1">enum</span> using <span class="bold1">new</span>. Instead, you declare and use an enumeration variable in much the same way that you do one of the primitive types. For example, this declares <span class="bold1">tp</span> as a variable of enumeration type <span class="bold1">Transport</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00725.jpg" class="calibre723"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Because <span class="bold1">tp</span> is of type <span class="bold1">Transport</span>, the only values that it can be assigned are those defined by the enumeration. For example, this assigns <span class="bold1">tp</span> the value <span class="bold1">AIRPLANE</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00726.jpg" class="calibre724"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Notice that the symbol <span class="bold1">AIRPLANE</span> is qualified by <span class="bold1">Transport</span>.</span></div>
<div class="calibre23"><span>Two enumeration constants can be compared for equality by using the <span class="bold1">= =</span> relational operator. For example, this statement compares the value in <span class="bold1">tp</span> with the <span class="bold1">TRAIN</span> constant:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00727.jpg" class="calibre725"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>An enumeration value can also be used to control a <span class="bold1">switch</span> statement. Of course, all of the <span class="bold1">case</span> statements must use constants from the same <span class="bold1">enum</span> as that used by the <span class="bold1">switch</span> expression. For example, this <span class="bold1">switch</span> is perfectly valid:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00728.jpg" class="calibre726"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Notice that in the <span class="bold1">case</span> statements, the names of the enumeration constants are used without being qualified by their enumeration type name. That is, <span class="bold1">TRUCK</span>, not <span class="bold1">Transport.TRUCK</span>, is used. This is because the type of the enumeration in the <span class="bold1">switch</span> expression has already implicitly specified the <span class="bold1">enum</span> type of the <span class="bold1">case</span> constants. There is no need to qualify the constants in the <span class="bold1">case</span> statements with their <span class="bold1">enum</span> type name. In fact, attempting to do so will cause a compilation error.</span></div>
<div class="calibre23"><span>When an enumeration constant is displayed, such as in a <span class="bold1">println( )</span> statement, its name is output. For example, given this statement:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00729.jpg" class="calibre727"/></span></div><div class="calibre11"> </div>
<div class="calibre27"><span>the name <span class="bold1">BOAT</span> is displayed.</span></div>
<div class="calibre23"><span>The following program puts together all of the pieces and demonstrates the <span class="bold1">Transport</span> enumeration:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00730.jpg" class="calibre728"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The output from the program is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00731.jpg" class="calibre729"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Before moving on, it’s necessary to make one stylistic point. The constants in <span class="bold1">Transport</span> use uppercase. (Thus, <span class="bold1">CAR</span>, not <span class="bold1">car</span>, is used.) However, the use of uppercase is not required. In other words, there is no rule that requires enumeration constants to be in uppercase. Because enumerations often replace <span class="bold1">final</span> variables, which have traditionally used uppercase, some programmers believe that uppercasing enumeration constants is also appropriate. There are, of course, other viewpoints and styles. The examples in this book will use uppercase for enumeration constants, for consistency.</span></div>
<div id="filepos1004757" class="calibre1"><span class="calibre10"><span><span class="bold1">Java Enumerations Are Class Types</span></span></span></div>
<div class="calibre12"><span>Although the preceding examples show the mechanics of creating and using an enumeration, they don’t show all of its capabilities. Unlike the way enumerations are implemented in some other languages, <span class="italic">Java implements enumerations as class types</span>. Although you don’t instantiate an <span class="bold1">enum</span> using <span class="bold1">new</span>, it otherwise acts much like other classes. The fact that <span class="bold1">enum</span> defines a class enables the Java enumeration to have powers that enumerations in some other languages do not. For example, you can give it constructors, add instance variables and methods, and even implement interfaces.</span></div>
<div id="filepos1005573" class="calibre1"><span class="calibre10"><span><span class="bold1">The values( ) and valueOf( ) Methods</span></span></span></div>
<div class="calibre12"><span>All enumerations automatically have two predefined methods: <span class="bold1">values( )</span> and <span class="bold1">valueOf( )</span>. Their general forms are shown here:</span></div>
<div class="calibre27"><span>public static <span class="italic">enum-type</span>[ ] values( )</span></div>
<div class="calibre27"><span>public static <span class="italic">enum-type</span> valueOf(String <span class="italic">str</span>)</span></div>
<div class="calibre27"><span>The <span class="bold1">values( )</span> method returns an array that contains a list of the enumeration constants. The <span class="bold1">valueOf( )</span> method returns the enumeration constant whose value corresponds to the string passed in <span class="italic">str</span>. In both cases, <span class="italic">enum</span>-<span class="italic">type</span> is the type of the enumeration. For example, in the case of the <span class="bold1">Transport</span> enumeration shown earlier, the return type of <span class="bold1">Transport.valueOf("TRAIN")</span> is <span class="bold1">Transport</span>. The value returned is <span class="bold1">TRAIN</span>. The following program demonstrates the <span class="bold1">values( )</span> and <span class="bold1">valueOf( )</span> methods:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00732.jpg" class="calibre730"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The output from the program is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00733.jpg" class="calibre731"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Notice that this program uses a for-each style <span class="bold1">for</span> loop to cycle through the array of constants obtained by calling <span class="bold1">values( )</span>. For the sake of illustration, the variable <span class="bold1">allTransports</span> was created and assigned a reference to the enumeration array. However, this step is not necessary because the <span class="bold1">for</span> could have been written as shown here, eliminating the need for the <span class="bold1">allTransports</span> variable:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00734.jpg" class="calibre732"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Now, notice how the value corresponding to the name <span class="bold1">AIRPLANE</span> was obtained by calling <span class="bold1">valueOf( )</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00735.jpg" class="calibre727"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>As explained, <span class="bold1">valueOf( )</span> returns the enumeration value associated with the name of the constant represented as a string.</span></div>
<div id="filepos1008285" class="calibre1"><span class="calibre10"><span><span class="bold1">Constructors, Methods, Instance Variables, and Enumerations</span></span></span></div>
<div class="calibre12"><span>It is important to understand that each enumeration constant is an object of its enumeration type. Thus, an enumeration can define constructors, add methods, and have instance variables. When you define a constructor for an <span class="bold1">enum</span>, the constructor is called when each enumeration constant is created. Each enumeration constant can call any method defined by the enumeration. Each enumeration constant has its own copy of any instance variables defined by the enumeration. The following version of <span class="bold1">Transport</span> illustrates the use of a constructor, an instance variable, and a method. It gives each type of transportation a typical speed.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00736.jpg" class="calibre733"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The output is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00737.jpg" class="calibre734"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>This version of <span class="bold1">Transport</span> adds three things. The first is the instance variable <span class="bold1">speed</span>, which is used to hold the speed of each kind of transport. The second is the <span class="bold1">Transport</span> constructor, which is passed the speed of a transport. The third is the method <span class="bold1">getSpeed( )</span>, which returns the value of <span class="bold1">speed</span>.</span></div>
<div class="calibre23"><span>When the variable <span class="bold1">tp</span> is declared in <span class="bold1">main( )</span>, the constructor for <span class="bold1">Transport</span> is called once for each constant that is specified. Notice how the arguments to the constructor are specified, by putting them inside parentheses, after each constant, as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00738.jpg" class="calibre386"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>These values are passed to the <span class="bold1">s</span> parameter of <span class="bold1">Transport( )</span>, which then assigns this value to <span class="bold1">speed</span>. There is something else to notice about the list of enumeration constants: it is terminated by a semicolon. That is, the last constant, <span class="bold1">BOAT</span>, is followed by a semicolon. When an enumeration contains other members, the enumeration list must end in a semicolon.</span></div>
<div class="calibre23"><span>Because each enumeration constant has its own copy of <span class="bold1">speed</span>, you can obtain the speed of a specified type of transport by calling <span class="bold1">getSpeed( )</span>. For example, in <span class="bold1">main( )</span> the speed of an airplane is obtained by the following call:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00739.jpg" class="calibre735"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The speed of each transport is obtained by cycling through the enumeration using a <span class="bold1">for</span> loop. Because there is a copy of <span class="bold1">speed</span> for each enumeration constant, the value associated with one constant is separate and distinct from the value associated with another constant. This is a powerful concept, which is available only when enumerations are implemented as classes, as Java does.</span></div>
<div class="calibre23"><span>Although the preceding example contains only one constructor, an <span class="bold1">enum</span> can offer two or more overloaded forms, just as can any other class.</span></div>
<div class="calibre35"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   Since enumerations have been added to Java, should I avoid the use of</span> final <span class="bold1">variables? In other words, have enumerations rendered</span> final <span class="bold1">variables obsolete?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   No. Enumerations are appropriate when you are working with lists of items that must be represented by identifiers. A <span class="bold1">final</span> variable is appropriate when you have a constant value, such as an array size, that will be used in many places. Thus, each has its own use. The advantage of enumerations is that <span class="bold1">final</span> variables don’t have to be pressed into service for a job for which they are not ideally suited.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos1013262" class="calibre9"><span class="calibre10"><span><span class="bold1">Two Important Restrictions</span></span></span></div>
<div class="calibre12"><span>There are two restrictions that apply to enumerations. First, an enumeration can’t inherit another class. Second, an <span class="bold1">enum</span> cannot be a superclass. This means that an <span class="bold1">enum</span> can’t be extended. Otherwise, <span class="bold1">enum</span> acts much like any other class type. The key is to remember that each of the enumeration constants is an object of the class in which it is defined.</span></div>
<div id="filepos1013843" class="calibre1"><span class="calibre10"><span><span class="bold1">Enumerations Inherit Enum</span></span></span></div>
<div class="calibre12"><span>Although you can’t inherit a superclass when declaring an <span class="bold1">enum</span>, all enumerations automatically inherit one: <span class="bold1">java.lang.Enum</span>. This class defines several methods that are available for use by all enumerations. Most often, you won’t need to use these methods, but there are two that you may occasionally employ: <span class="bold1">ordinal( )</span> and <span class="bold1">compareTo( )</span>.</span></div>
<div class="calibre23"><span>The <span class="bold1">ordinal( )</span> method obtains a value that indicates an enumeration constant’s position in the list of constants. This is called its <span class="italic">ordinal value</span>. The <span class="bold1">ordinal( )</span> method is shown here:</span></div>
<div class="calibre27"><span>final int ordinal( )</span></div>
<div class="calibre27"><span>It returns the ordinal value of the invoking constant. Ordinal values begin at zero. Thus, in the <span class="bold1">Transport</span> enumeration, <span class="bold1">CAR</span> has an ordinal value of zero, <span class="bold1">TRUCK</span> has an ordinal value of 1, <span class="bold1">AIRPLANE</span> has an ordinal value of 2, and so on.</span></div>
<div class="calibre23"><span>You can compare the ordinal value of two constants of the same enumeration by using the <span class="bold1">compareTo( )</span> method. It has this general form:</span></div>
<div class="calibre27"><span>final int compareTo(<span class="italic">enum-type e</span>)</span></div>
<div class="calibre27"><span>Here, <span class="italic">enum-type</span> is the type of the enumeration and <span class="italic">e</span> is the constant being compared to the invoking constant. Remember, both the invoking constant and <span class="italic">e</span> must be of the same enumeration. If the invoking constant has an ordinal value less than <span class="italic">e</span>’s, then <span class="bold1">compareTo( )</span> returns a negative value. If the two ordinal values are the same, then zero is returned. If the invoking constant has an ordinal value greater than <span class="italic">e</span>’s, then a positive value is returned.</span></div>
<div class="calibre23"><span>The following program demonstrates <span class="bold1">ordinal( )</span> and <span class="bold1">compareTo( )</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00740.jpg" class="calibre736"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The output from the program is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00741.jpg" class="calibre473"/></span></div><div class="calibre11"> </div>
<div class="calibre11"> </div><table cellspacing="0" cellpadding="0" class="calibre37">
<colgroup class="calibre38">
<col class="calibre72"/>
<col class="calibre73"/>
</colgroup>
<tr class="calibre41">
<td valign="top" id="filepos1016682" class="calibre74"><span class="calibre10"><span class="bold1">Try This 12-1</span> </span></td>
<td valign="top" class="calibre75"><span class="calibre10">A Computer-Controlled Traffic Light</span></td>
</tr></table><div class="calibre43"> </div>
<div class="calibre1"><span><img alt="image" src="images/00742.jpg" class="calibre737"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Enumerations are particularly useful when your program needs a set of constants, but the actual values of the constants are arbitrary, as long as all differ. This type of situation comes up quite often when programming. One common instance involves handling the states in which some device can exist. For example, imagine that you are writing a program that controls a traffic light. Your traffic light code must automatically cycle through the light’s three states: green, yellow, and red. It also must enable other code to know the current color of the light and let the color of the light be set to a known initial value. This means that the three states must be represented in some way. Although it would be possible to represent these three states by integer values (for example, the values 1, 2, and 3) or by strings (such as "red", "green", and "yellow"), an enumeration offers a much better approach. Using an enumeration results in code that is more efficient than if strings represented the states and more structured than if integers represented the states.</span></div>
<div class="calibre23"><span>In this project, you will create a simulation of an automated traffic light, as just described. This project not only demonstrates an enumeration in action, it also shows another example of multithreading and synchronization.</span></div>
<div class="calibre19"><span>  <span class="bold1">1</span>.  Create a file called <span class="bold1">TrafficLightDemo.java</span>.</span></div>
<div class="calibre47"><span>  <span class="bold1">2</span>.  Begin by defining an enumeration called <span class="bold1">TrafficLightColor</span> that represents the three states of the light, as shown here:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00743.jpg" class="calibre738"/></span></div>
<div class="calibre47"><span>        Whenever the color of the light is needed, its enumeration value is used.</span></div>
<div class="calibre47"><span>  <span class="bold1">3</span>.  Next, begin defining <span class="bold1">TrafficLightSimulator</span>, as shown next. <span class="bold1">TrafficLightSimulator</span> is the class that encapsulates the traffic light simulation.</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00744.jpg" class="calibre147"/></span></div>
<div class="calibre47"><span>        Notice that <span class="bold1">TrafficLightSimulator</span> implements <span class="bold1">Runnable</span>. This is necessary because a separate thread is used to run each traffic light. This thread will cycle through the colors. Two constructors are created. The first lets you specify the initial light color. The second defaults to red. Both start a new thread to run the light.</span></div>
<div class="calibre47"><span>        Now look at the instance variables. A reference to the traffic light thread is stored in <span class="bold1">thrd</span>. The current traffic light color is stored in <span class="bold1">tlc</span>. The <span class="bold1">stop</span> variable is used to stop the simulation. It is initially set to <span class="bold1">false</span>. The light will run until this variable is set to <span class="bold1">true</span>. The <span class="bold1">changed</span> variable is <span class="bold1">true</span> when the light has changed.</span></div>
<div class="calibre47"><span>  <span class="bold1">4</span>.  Next, add the <span class="bold1">run( )</span> method, shown here, which begins running the traffic light:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00745.jpg" class="calibre739"/></span></div>
<div class="calibre47"><span>        This method cycles the light through the colors. First, it sleeps an appropriate amount of time, based on the current color. Then, it calls <span class="bold1">changeColor( )</span> to change to the next color in the sequence.</span></div>
<div class="calibre47"><span>  <span class="bold1">5</span>.  Now, add the <span class="bold1">changeColor( )</span> method, as shown here:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00746.jpg" class="calibre740"/></span></div>
<div class="calibre47"><span>        The <span class="bold1">switch</span> statement examines the color currently stored in <span class="bold1">tlc</span> and then assigns the next color in the sequence. Notice that this method is synchronized. This is necessary because it calls <span class="bold1">notify( )</span> to signal that a color change has taken place. (Recall that <span class="bold1">notify( )</span> can be called only from a synchronized context.)</span></div>
<div class="calibre47"><span>  <span class="bold1">6</span>.  The next method is <span class="bold1">waitForChange( )</span>, which waits until the color of the light is changed.</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00747.jpg" class="calibre741"/></span></div>
<div class="calibre47"><span>        This method simply calls <span class="bold1">wait( )</span>. This call won’t return until <span class="bold1">changeColor( )</span> executes a call to <span class="bold1">notify( )</span>. Thus, <span class="bold1">waitForChange( )</span> won’t return until the color has changed.</span></div>
<div class="calibre47"><span>  <span class="bold1">7</span>.  Finally, add the methods <span class="bold1">getColor( )</span>, which returns the current light color, and <span class="bold1">cancel( )</span>, which stops the traffic light thread by setting <span class="bold1">stop</span> to <span class="bold1">true</span>. These methods are shown here:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00748.jpg" class="calibre742"/></span></div>
<div class="calibre47"><span><span class="bold1">8</span>. Here is all the code assembled into a complete program that demonstrates the traffic light:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00749.jpg" class="calibre743"/></span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00750.jpg" class="calibre744"/></span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00751.jpg" class="calibre745"/></span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00752.jpg" class="calibre746"/></span></div>
<div class="calibre47"><span>        The following output is produced. As you can see, the traffic light cycles through the colors in order of green, yellow, and red:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00753.jpg" class="calibre747"/></span></div>
<div class="calibre47"><span>        In the program, notice how the use of the enumeration simplifies and adds structure to the code that needs to know the state of the traffic light. Because the light can have only three states (red, green, or yellow), the use of an enumeration ensures that only these values are valid, thus preventing accidental misuse.</span></div>
<div class="calibre47"><span>  <span class="bold1">9</span>.  It is possible to improve the preceding program by taking advantage of the class capabilities of an enumeration. For example, by adding a constructor, instance variable, and method to <span class="bold1">TrafficLightColor</span>, you can substantially improve the preceding programming. This improvement is left as an exercise. See Self Test, question 4.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos1026556" class="calibre9"><span class="calibre10"><span><span class="bold1">Autoboxing</span></span></span></div>
<div class="calibre12"><span>Beginning with JDK 5, Java has included two very helpful features: <span class="italic">autoboxing</span> and <span class="italic">auto-unboxing</span>. Autoboxing/unboxing greatly simplifies and streamlines code that must convert primitive types into objects, and vice versa. Because such situations are found frequently in Java code, the benefits of autoboxing/unboxing affect nearly all Java programmers. As you will see in <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_020.html#filepos1060750">Chapter 13</a>, autoboxing/unboxing also contributes greatly to the usability of generics.</span></div>
<div class="calibre23"><span>Autoboxing/unboxing is directly related to Java’s type wrappers, and to the way that values are moved into and out of an instance of a wrapper. For this reason, we will begin with an overview of the type wrappers and the process of manually boxing and unboxing values.</span></div>
<div id="filepos1027579" class="calibre1"><span class="calibre10"><span><span class="bold1">Type Wrappers</span></span></span></div>
<div class="calibre12"><span>As you know, Java uses primitive types, such as <span class="bold1">int</span> or <span class="bold1">double</span>, to hold the basic data types supported by the language. Primitive types, rather than objects, are used for these quantities for the sake of performance. Using objects for these basic types would add an unacceptable overhead to even the simplest of calculations. Thus, the primitive types are not part of the object hierarchy, and they do not inherit <span class="bold1">Object</span>.</span></div>
<div class="calibre23"><span>Despite the performance benefit offered by the primitive types, there are times when you will need an object representation. For example, you can’t pass a primitive type by reference to a method. Also, many of the standard data structures implemented by Java operate on objects, which means that you can’t use these data structures to store primitive types. To handle these (and other) situations, Java provides <span class="italic">type wrappers</span>, which are classes that encapsulate a primitive type within an object. The type wrapper classes were introduced briefly in <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_017.html#filepos823752">Chapter 10</a>. Here, we will look at them more closely.</span></div>
<div class="calibre23"><span>The type wrappers are <span class="bold1">Double</span>, <span class="bold1">Float</span>, <span class="bold1">Long</span>, <span class="bold1">Integer</span>, <span class="bold1">Short</span>, <span class="bold1">Byte</span>, <span class="bold1">Character</span>, and <span class="bold1">Boolean</span>, which are packaged in <span class="bold1">java.lang</span>. These classes offer a wide array of methods that allow you to fully integrate the primitive types into Java’s object hierarchy.</span></div>
<div class="calibre23"><span>Probably the most commonly used type wrappers are those that represent numeric values. These are <span class="bold1">Byte</span>, <span class="bold1">Short</span>, <span class="bold1">Integer</span>, <span class="bold1">Long</span>, <span class="bold1">Float</span>, and <span class="bold1">Double</span>. All of the numeric type wrappers inherit the abstract class <span class="bold1">Number</span>. <span class="bold1">Number</span> declares methods that return the value of an object in each of the different numeric types. These methods are shown here:</span></div>
<div class="calibre27"><span>byte byteValue( )</span></div>
<div class="calibre27"><span>double doubleValue( )</span></div>
<div class="calibre27"><span>float floatValue( )</span></div>
<div class="calibre27"><span>int intValue( )</span></div>
<div class="calibre27"><span>long longValue( )</span></div>
<div class="calibre27"><span>short shortValue( )</span></div>
<div class="calibre27"><span>For example, <span class="bold1">doubleValue( )</span> returns the value of an object as a <span class="bold1">double</span>, <span class="bold1">floatValue( )</span> returns the value as a <span class="bold1">float</span>, and so on. These methods are implemented by each of the numeric type wrappers.</span></div>
<div class="calibre23"><span>All of the numeric type wrappers define constructors that allow an object to be constructed from a given value, or a string representation of that value. For example, here are the constructors defined for <span class="bold1">Integer</span> and <span class="bold1">Double</span>:</span></div>
<div class="calibre27"><span>Integer(int <span class="italic">num</span>)</span></div>
<div class="calibre27"><span>Integer(String <span class="italic">str</span>) throws NumberFormatException</span></div>
<div class="calibre27"><span>Double(double <span class="italic">num</span>)</span></div>
<div class="calibre27"><span>Double(String <span class="italic">str</span>) throws NumberFormatException</span></div>
<div class="calibre27"><span>If <span class="italic">str</span> does not contain a valid numeric value, then a <span class="bold1">NumberFormatException</span> is thrown.</span></div>
<div class="calibre592"><span>All of the type wrappers override <span class="bold1">toString( )</span>. It returns the human-readable form of the value contained within the wrapper. This allows you to output the value by passing a type wrapper object to <span class="bold1">println( )</span>, for example, without having to convert it into its primitive type.</span></div>
<div class="calibre23"><span>The process of encapsulating a value within an object is called <span class="italic">boxing</span>. Prior to JDK 5, all boxing took place manually, with the programmer explicitly constructing an instance of a wrapper with the desired value. For example, this line manually boxes the value 100 into an <span class="bold1">Integer</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00754.jpg" class="calibre748"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>In this example, a new <span class="bold1">Integer</span> object with the value 100 is explicitly created and a reference to this object is assigned to <span class="bold1">iOb</span>.</span></div>
<div class="calibre23"><span>The process of extracting a value from a type wrapper is called <span class="italic">unboxing</span>. Again, prior to JDK 5, all unboxing also took place manually, with the programmer explicitly calling a method on the wrapper to obtain its value. For example, this manually unboxes the value in <span class="bold1">iOb</span> into an <span class="bold1">int</span>.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00755.jpg" class="calibre749"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, <span class="bold1">intValue( )</span> returns the value encapsulated within <span class="bold1">iOb</span> as an <span class="bold1">int</span>.</span></div>
<div class="calibre23"><span>The following program demonstrates the preceding concepts:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00756.jpg" class="calibre650"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>This program wraps the integer value 100 inside an <span class="bold1">Integer</span> object called <span class="bold1">iOb</span>. The program then obtains this value by calling <span class="bold1">intValue( )</span> and stores the result in <span class="bold1">i</span>. Finally, it displays the values of <span class="bold1">i</span> and <span class="bold1">iOb</span>, both of which are 100.</span></div>
<div class="calibre23"><span>The same general procedure used by the preceding example to manually box and unbox values was required by all versions of Java prior to JDK 5 and may still be found in legacy code. The problem is that it is both tedious and error-prone because it requires the programmer to manually create the appropriate object to wrap a value and to explicitly obtain the proper primitive type when its value is needed. Fortunately, autoboxing/unboxing fundamentally improves on these essential procedures.</span></div>
<div id="filepos1034347" class="calibre1"><span class="calibre10"><span><span class="bold1">Autoboxing Fundamentals</span></span></span></div>
<div class="calibre12"><span>Autoboxing is the process by which a primitive type is automatically encapsulated (boxed) into its equivalent type wrapper whenever an object of that type is needed. There is no need to explicitly construct an object. Auto-unboxing is the process by which the value of a boxed object is automatically extracted (unboxed) from a type wrapper when its value is needed. There is no need to call a method such as <span class="bold1">intValue( )</span> or <span class="bold1">doubleValue( )</span>.</span></div>
<div class="calibre23"><span>The addition of autoboxing and auto-unboxing greatly streamlines the coding of several algorithms, removing the tedium of manually boxing and unboxing values. It also helps prevent errors. With autoboxing it is not necessary to manually construct an object in order to wrap a primitive type. You need only assign that value to a type-wrapper reference. Java automatically constructs the object for you. For example, here is the modern way to construct an <span class="bold1">Integer</span> object that has the value 100:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00757.jpg" class="calibre750"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Notice that the object is not explicitly created through the use of <span class="bold1">new</span>. Java handles this for you, automatically.</span></div>
<div class="calibre23"><span>To unbox an object, simply assign that object reference to a primitive-type variable. For example, to unbox <span class="bold1">iOb</span>, you can use this line:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00758.jpg" class="calibre751"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Java handles the details for you.</span></div>
<div class="calibre23"><span>The following program demonstrates the preceding statements:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00759.jpg" class="calibre280"/></span></div><div class="calibre11"> </div>
<div id="filepos1036594" class="calibre1"><span class="calibre10"><span><span class="bold1">Autoboxing and Methods</span></span></span></div>
<div class="calibre12"><span>In addition to the simple case of assignments, autoboxing automatically occurs whenever a primitive type must be converted into an object, and auto-unboxing takes place whenever an object must be converted into a primitive type. Thus, autoboxing/unboxing might occur when an argument is passed to a method or when a value is returned by a method. For example, consider the following:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00760.jpg" class="calibre752"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>This program displays the following result:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00761.jpg" class="calibre753"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>In the program, notice that <span class="bold1">m( )</span> specifies an <span class="bold1">Integer</span> parameter. Inside <span class="bold1">main( )</span>, <span class="bold1">m( )</span> is passed the <span class="bold1">int</span> value 199. Because <span class="bold1">m( )</span> is expecting an <span class="bold1">Integer</span>, this value is automatically boxed. Next, <span class="bold1">m2( )</span> is called. It returns the <span class="bold1">int</span> value 10. This <span class="bold1">int</span> value is assigned to <span class="bold1">iOb</span> in <span class="bold1">main( )</span>. Because <span class="bold1">iOb</span> is an <span class="bold1">Integer</span>, the value returned by <span class="bold1">m2( )</span> is autoboxed. Next, <span class="bold1">m3( )</span> is called. It returns an <span class="bold1">Integer</span> that is auto-unboxed into an <span class="bold1">int</span>. Finally, <span class="bold1">Math.sqrt( )</span> is called with <span class="bold1">iOb</span> as an argument. In this case, <span class="bold1">iOb</span> is auto-unboxed and its value promoted to <span class="bold1">double</span>, since that is the type expected by <span class="bold1">Math.sqrt( )</span>.</span></div>
<div id="filepos1038381" class="calibre1"><span class="calibre10"><span><span class="bold1">Autoboxing/Unboxing Occurs in Expressions</span></span></span></div>
<div class="calibre12"><span>In general, autoboxing and unboxing take place whenever a conversion into an object or from an object is required. This applies to expressions. Within an expression, a numeric object is automatically unboxed. The outcome of the expression is reboxed, if necessary. For example, consider the following program:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00762.jpg" class="calibre754"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The output is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00763.jpg" class="calibre755"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>In the program, pay special attention to this line:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00764.jpg" class="calibre756"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>This causes the value in <span class="bold1">iOb</span> to be incremented. It works like this: <span class="bold1">iOb</span> is unboxed, the value is incremented, and the result is reboxed.</span></div>
<div class="calibre23"><span>Because of auto-unboxing, you can use integer numeric objects, such as an <span class="bold1">Integer</span>, to control a <span class="bold1">switch</span> statement. For example, consider this fragment:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00765.jpg" class="calibre757"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>When the <span class="bold1">switch</span> expression is evaluated, <span class="bold1">iOb</span> is unboxed and its <span class="bold1">int</span> value is obtained.</span></div>
<div class="calibre23"><span>As the examples in the program show, because of autoboxing/unboxing, using numeric objects in an expression is both intuitive and easy. With early versions of Java, such code would have involved casts and calls to methods such as <span class="bold1">intValue( )</span>.</span></div>
<div id="filepos1040577" class="calibre1"><span class="calibre10"><span><span class="bold1">A Word of Warning</span></span></span></div>
<div class="calibre12"><span>Because of autoboxing and auto-unboxing, one might be tempted to use objects such as <span class="bold1">Integer</span> or <span class="bold1">Double</span> exclusively, abandoning primitives altogether. For example, with autoboxing/unboxing it is possible to write code like this:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00766.jpg" class="calibre758"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>In this example, objects of type <span class="bold1">Double</span> hold values, which are then averaged and the result assigned to another <span class="bold1">Double</span> object. Although this code is technically correct and does, in fact, work properly, it is a very bad use of autoboxing/unboxing. It is far less efficient than the equivalent code written using the primitive type <span class="bold1">double</span>. The reason is that each autobox and auto-unbox adds overhead that is not present if the primitive type is used.</span></div>
<div class="calibre23"><span>In general, you should restrict your use of the type wrappers to only those cases in which an object representation of a primitive type is required. Autoboxing/unboxing was not added to Java as a “back door” way of eliminating the primitive types.</span></div>
<div id="filepos1042005" class="calibre1"><span class="calibre10"><span><span class="bold1">Static Import</span></span></span></div>
<div class="calibre12"><span>Java supports an expanded use of the <span class="bold1">import</span> keyword. By following <span class="bold1">import</span> with the keyword <span class="bold1">static</span>, an <span class="bold1">import</span> statement can be used to import the static members of a class or interface. This is called <span class="italic">static import</span>. When using static import, it is possible to refer to static members directly by their names, without having to qualify them with the name of their class. This simplifies and shortens the syntax required to use a static member.</span></div>
<div class="calibre23"><span>To understand the usefulness of static import, let’s begin with an example that <span class="italic">does not</span> use it. The following program computes the solutions to a quadratic equation, which has this form:</span></div>
<div class="calibre29"><span><img alt="image" src="images/00767.jpg" class="calibre759"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The program uses two static methods from Java’s built-in math class <span class="bold1">Math</span>, which is part of <span class="bold1">java.lang</span>. The first is <span class="bold1">Math.pow( )</span>, which returns a value raised to a specified power. The second is <span class="bold1">Math.sqrt( )</span>, which returns the square root of its argument.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00768.jpg" class="calibre760"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Because <span class="bold1">pow( )</span> and <span class="bold1">sqrt( )</span> are static methods, they must be called through the use of their class’ name, <span class="bold1">Math</span>. This results in a somewhat unwieldy expression:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00769.jpg" class="calibre82"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Furthermore, having to specify the class name each time <span class="bold1">pow( )</span> or <span class="bold1">sqrt( )</span> (or any of Java’s other math methods, such as <span class="bold1">sin( )</span>, <span class="bold1">cos( )</span>, and <span class="bold1">tan( )</span>) are used can become tedious.</span></div>
<div class="calibre23"><span>You can eliminate the tedium of specifying the class name through the use of static import, as shown in the following version of the preceding program:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00770.jpg" class="calibre761"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>In this version, the names <span class="bold1">sqrt</span> and <span class="bold1">pow</span> are brought into view by these static import statements:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00771.jpg" class="calibre762"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>After these statements, it is no longer necessary to qualify <span class="bold1">sqrt( )</span> or <span class="bold1">pow( )</span> with its class name. Therefore, the expression can more conveniently be specified, as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00772.jpg" class="calibre763"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>As you can see, this form is considerably shorter and easier to read.</span></div>
<div class="calibre23"><span>There are two general forms of the <span class="bold1">import static</span> statement. The first, which is used by the preceding example, brings into view a single name. Its general form is shown here:</span></div>
<div class="calibre27"><span>import static <span class="italic">pkg.type-name.static-member-name</span>;</span></div>
<div class="calibre27"><span>Here, <span class="italic">type-name</span> is the name of a class or interface that contains the desired static member. Its full package name is specified by <span class="italic">pkg</span>. The name of the member is specified by <span class="italic">static-member-name</span>.</span></div>
<div class="calibre23"><span>The second form of static import imports all static members. Its general form is shown here:</span></div>
<div class="calibre27"><span>import static <span class="italic">pkg</span>.<span class="italic">type-name</span>.*;</span></div>
<div class="calibre27"><span>If you will be using many static methods or fields defined by a class, then this form lets you bring them into view without having to specify each individually. Therefore, the preceding program could have used this single <span class="bold1">import</span> statement to bring both <span class="bold1">pow( )</span> and <span class="bold1">sqrt( )</span> (and <span class="italic">all other</span> static members of <span class="bold1">Math</span>) into view:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00773.jpg" class="calibre748"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Of course, static import is not limited just to the <span class="bold1">Math</span> class or just to methods. For example, this brings the static field <span class="bold1">System.out</span> into view:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00774.jpg" class="calibre727"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>After this statement, you can output to the console without having to qualify <span class="bold1">out</span> with <span class="bold1">System</span>, as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00775.jpg" class="calibre252"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Whether importing <span class="bold1">System.out</span> as just shown is a good idea is subject to debate. Although it does shorten the statement, it is no longer instantly clear to anyone reading the program that the <span class="bold1">out</span> being referred to is <span class="bold1">System.out</span>.</span></div>
<div class="calibre23"><span>As convenient as static import can be, it is important not to abuse it. Remember, one reason that Java organizes its libraries into packages is to avoid namespace collisions. When you import static members, you are bringing those members into the global namespace. Thus, you are increasing the potential for namespace conflicts and the inadvertent hiding of other names. If you are using a static member once or twice in the program, it’s best not to import it. Also, some static names, such as <span class="bold1">System.out</span>, are so recognizable that you might not want to import them. Static import is designed for those situations in which you are using a static member repeatedly, such as when performing a series of mathematical computations. In essence, you should use, but not abuse, this feature.</span></div>
<div class="calibre35"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   Using static import, can I import the static members of classes that I create?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   Yes, you can use static import to import the static members of classes and interfaces you create. Doing so is especially convenient when you define several static members that are used frequently throughout a large program. For example, if a class defines a number of <span class="bold1">static final</span> constants that define various limits, then using static import to bring them into view will save you a lot of tedious typing.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos1049925" class="calibre9"><span class="calibre10"><span><span class="bold1">Annotations (Metadata)</span></span></span></div>
<div class="calibre12"><span>Java provides a feature that enables you to embed supplemental information into a source file. This information, called an <span class="italic">annotation</span>, does not change the actions of a program. However, this information can be used by various tools, during both development and deployment. For example, an annotation might be processed by a source-code generator, by the compiler, or by a deployment tool. The term <span class="italic">metadata</span> is also used to refer to this feature, but the term annotation is the most descriptive, and more commonly used.</span></div>
<div class="calibre23"><span>Annotation is a large and sophisticated topic, and it is far beyond the scope of this book to cover it in detail. However, an overview is given here so that you will be familiar with the concept.</span></div>
<div class="calibre44"><span class="calibre10"><span><span class="bold1"><span class="italic">NOTE</span></span></span></span></div>
<div class="calibre9"><span><img alt="image" src="images/00006.jpg" class="calibre45"/></span></div>
<div class="calibre9"><span>A detailed discussion of metadata and annotations can be found in my book <span class="italic">Java: The Complete Reference, Ninth Edition</span> (Oracle Press/McGraw-Hill Professional, 2014).</span></div><div class="calibre11"> </div>
<div class="calibre23"><span>An annotation is created through a mechanism based on the <span class="bold1">interface</span>. Here is a simple example:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00776.jpg" class="calibre764"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>This declares an annotation called <span class="bold1">MyAnno</span>. Notice the <span class="bold1">@</span> that precedes the keyword <span class="bold1">interface</span>. This tells the compiler that an annotation type is being declared. Next, notice the two members <span class="bold1">str( )</span> and <span class="bold1">val( )</span>. All annotations consist solely of method declarations. However, you don’t provide bodies for these methods. Instead, Java implements these methods. Moreover, the methods act much like fields.</span></div>
<div class="calibre23"><span>All annotation types automatically extend the <span class="bold1">Annotation</span> interface. Thus, <span class="bold1">Annotation</span> is a super-interface of all annotations. It is declared within the <span class="bold1">java.lang.annotation</span> package.</span></div>
<div class="calibre23"><span>Originally, annotations were used to annotate only declarations. In this usage, any type of declaration can have an annotation associated with it. For example, classes, methods, fields, parameters, and <span class="bold1">enum</span> constants can be annotated. Even an annotation can be annotated. In such cases, the annotation precedes the rest of the declaration. Beginning with JDK 8, you can also annotate a <span class="italic">type use</span>, such as a cast or a method return type.</span></div>
<div class="calibre23"><span>When you apply an annotation, you give values to its members. For example, here is an example of <span class="bold1">MyAnno</span> being applied to a method:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00777.jpg" class="calibre765"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>This annotation is linked with the method <span class="bold1">myMeth( )</span>. Look closely at the annotation syntax. The name of the annotation, preceded by an @, is followed by a parenthesized list of member initializations. To give a member a value, that member’s name is assigned a value. Therefore, in the example, the string "Annotation Example" is assigned to the <span class="bold1">str</span> member of <span class="bold1">MyAnno</span>. Notice that no parentheses follow <span class="bold1">str</span> in this assignment. When an annotation member is given a value, only its name is used. Thus, annotation members look like fields in this context.</span></div>
<div class="calibre23"><span>Annotations that don’t have parameters are called <span class="italic">marker annotations</span>. These are specified without passing any arguments and without using parentheses. Their sole purpose is to mark an item with some attribute.</span></div>
<div class="calibre23"><span>Java defines many built-in annotations. Most are specialized, but nine are general purpose. Four are imported from <span class="bold1">java.lang.annotation</span>: @<span class="bold1">Retention</span>, @<span class="bold1">Documented</span>, @<span class="bold1">Target</span>, and @<span class="bold1">Inherited</span>. Five, @<span class="bold1">Override</span>, @<span class="bold1">Deprecated</span>, @<span class="bold1">SafeVarargs</span>, @<span class="bold1">FunctionalInterface</span>, and @<span class="bold1">SuppressWarnings</span>, are included in <span class="bold1">java.lang</span>. These are shown in <a href="#filepos1054917">Table 12-1</a>.</span></div>
<div class="calibre28">
<div id="filepos1054917" class="calibre44"><span><img alt="image" src="images/00778.jpg" class="calibre495"/></span></div>
<div class="calibre9"><span><img alt="image" src="images/00057.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span><span class="bold1">Table 12-1</span>   The General Purpose Built-in Annotations</span></div><div class="calibre18"> </div>
</div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1"><span class="italic">NOTE</span></span></span></span></div>
<div class="calibre9"><span><img alt="image" src="images/00006.jpg" class="calibre45"/></span></div>
<div class="calibre9"><span>To <span class="bold1">java.lang.annotation</span>, JDK 8 adds the annotations <span class="bold1">@Repeatable</span> and <span class="bold1">@Native</span>. <span class="bold1">@Repeatable</span> supports repeatable annotations, which are annotations that can be applied more than once to a single item. <span class="bold1">@Native</span> is used to annotate a constant field accessed by executable (i.e., native) code. Both are special-use annotations that are beyond the scope of this book.</span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Here is an example that uses @<span class="bold1">Deprecated</span> to mark the <span class="bold1">MyClass</span> class and the <span class="bold1">getMsg( )</span> method. When you try to compile this program, warnings will report the use of these deprecated elements.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00779.jpg" class="calibre766"/></span></div><div class="calibre11"> </div>
<div id="filepos1056508" class="calibre44"><span class="calibre10"><span><img alt="image" src="images/00059.jpg" class="calibre104"/>   <span class="bold1"><span class="italic">Chapter 12 Self Test</span></span></span></span></div><div class="calibre11"> </div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1056789" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1559449">1</a></span>.  Enumeration constants are said to be <span class="italic">self-typed</span>. What does this mean?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1057034" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1560003">2</a></span>.  What class do all enumerations automatically inherit?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1057256" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1560391">3</a></span>.  Given the following enumeration, write a program that uses <span class="bold1">values( )</span> to show a list of the constants and their ordinal values.</span></div>
<div class="calibre31"><blockquote class="calibre66"><span><img alt="image" src="images/00780.jpg" class="calibre767"/></span></blockquote></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1057715" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1561120">4</a></span>.  The traffic light simulation developed in <a href="#filepos1016682">Try This 12-1</a> can be improved with a few simple changes that take advantage of an enumeration’s class features. In the version shown, the duration of each color was controlled by the <span class="bold1">TrafficLightSimulator</span> class by hard-coding these values into the <span class="bold1">run( )</span> method. Change this so that the duration of each color is stored by the constants in the <span class="bold1">TrafficLightColor</span> enumeration. To do this, you will need to add a constructor, a private instance variable, and a method called <span class="bold1">getDelay( )</span>. After making these changes, what improvements do you see? On your own, can you think of other improvements? (Hint: Try using ordinal values to switch light colors rather than relying on a <span class="bold1">switch</span> statement.)</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1058686" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1563137">5</a></span>.  Define boxing and unboxing. How does autoboxing/unboxing affect these actions?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1058933" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1563887">6</a></span>.  Change the following fragment so that it uses autoboxing.</span></div>
<div class="calibre31"><blockquote class="calibre66"><span><img alt="image" src="images/00781.jpg" class="calibre311"/></span></blockquote></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1059316" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1564539">7</a></span>.  In your own words, what does static import do?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1059531" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1565049">8</a></span>.  What does this statement do?</span></div>
<div class="calibre31"><blockquote class="calibre66"><span><img alt="image" src="images/00782.jpg" class="calibre768"/></span></blockquote></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1059885" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1565612">9</a></span>.  Is static import designed for special-case situations, or is it good practice to bring all static members of all classes into view?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1060169" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1566137">10</a></span>.  An annotation is syntactically based on a/an ________________.</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1060386" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1566460">11</a></span>.  What is a marker annotation?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1060569" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1566796">12</a></span>.  An annotation can be applied only to methods. True or False?</span></div>  <div class="mbppagebreak" id="calibre_pb_19"></div>
</body></html>
