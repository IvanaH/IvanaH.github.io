<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Java&amp;#8482;: A Beginner&amp;#8217;s Guide Sixth Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="filepos1394297" class="calibre29"><span><img alt="image" src="images/00003.jpg" class="calibre30"/></span></div><div class="calibre11"> </div>
<div class="calibre31"><span class="calibre2"><span><big class="calibre3"><big class="calibre4"><big class="calibre5"><big class="calibre6"><big class="calibre32"><big class="calibre4">Chapter 17</big></big></big></big></big></big></span></span></div>
<div class="calibre9"><span class="calibre2"><span>Introducing JavaFX</span></span></div><div class="calibre33"> </div>
<div class="calibre1"><span class="calibre10"><span><span class="bold1">Key Skills &amp; Concepts</span></span></span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Understand JavaFX’s concepts of a stage, a scene, a node, and a scene graph</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Know the JavaFX life-cycle methods</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Know the general form of a JavaFX application</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Understand how to launch a JavaFX application</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Create a <span class="bold1">Label</span></span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Use <span class="bold1">Button</span></span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Handle events</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Use <span class="bold1">CheckBox</span></span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Work with <span class="bold1">ListView</span></span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Create a <span class="bold1">TextField</span></span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Add effects</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Apply transforms</span></div>
<div class="calibre1"><span><img alt="image" src="images/00004.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre12"><span><span><span class="calibre2"><span class="bold1">I</span></span></span>n the fast-paced world of computing, change is constant, and the art and science of programming continue to evolve and advance. It should not then be surprising that Java’s GUI frameworks have also participated in this process. Recall that Java’s original GUI framework was the AWT. It was soon followed by Swing, which offered a far superior approach. Although Swing has been very successful, it can be difficult to create the “visual sparkle” that many of today’s applications demand. Furthermore, the conceptual basis that underpins the design of GUI frameworks has advanced. To better handle the demands of the modern GUI and advances in GUI design, a new approach was needed. The result is JavaFX, Java’s next-generation GUI framework. This chapter provides an introduction to this powerful new system.</span></div>
<div class="calibre23"><span>It is important to mention that the development of JavaFX occurred in two main phases. The original JavaFX was based on a scripting language called <span class="italic">JavaFX Script</span>. However, JavaFX Script has been discontinued. Beginning with the release of JavaFX 2.0, JavaFX has been programmed in Java itself and provides a comprehensive API. JavaFX has been bundled with Java since JDK 7, update 4. The latest version of JavaFX is JavaFX 8, which is included with JDK 8. (The version number is 8 to align with the JDK version. Thus, the numbers 3 through 7 were skipped.) Because, at the time of this writing, JavaFX 8 represents the latest version of JavaFX, it is the version of JavaFX discussed here. Furthermore, when the term <span class="italic">JavaFX</span> is used, it refers to JavaFX 8.</span></div>
<div class="calibre23"><span>Before we begin, it is useful to answer one question that naturally arises relating to JavaFX: Is JavaFX designed as a replacement for Swing? The answer is, essentially, Yes. However, Swing will be part of Java programming for some time to come. The reason is that there is a large amount of Swing legacy code. Furthermore, there are legions of programmers who know how to program for Swing. Nevertheless, JavaFX has clearly been positioned as the platform of the future. It is expected that over the next few years, JavaFX will supplant Swing for new projects, and many Swing-based applications will migrate to JavaFX. Simply put: JavaFX is something that no Java programmer can afford to ignore.</span></div>
<div class="calibre44"><span class="calibre10"><span><span class="bold1"><span class="italic">NOTE</span></span></span></span></div>
<div class="calibre9"><span><img alt="image" src="images/00006.jpg" class="calibre45"/></span></div>
<div class="calibre9"><span>This chapter assumes that you have an understanding of GUI basics, including event handling, as introduced in <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_022.html#filepos1225806">Chapters 15</a> and <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_023.html#filepos1300493">16</a>.</span></div><div class="calibre11"> </div>
<div id="filepos1400394" class="calibre1"><span class="calibre10"><span><span class="bold1">JavaFX Basic Concepts</span></span></span></div>
<div class="calibre12"><span>Before you can create a JavaFX application, there are several key concepts and features you must understand. Although JavaFX has similarities with Java’s other GUIs, the AWT and Swing, it has substantial differences. For example, like Swing, JavaFX components are lightweight and events are handled in an easy-to-manage, straightforward manner. However, the overall organization of JavaFX and the relationship of its main components differ significantly from either Swing or the AWT. Therefore, a careful reading of the following sections is recommended.</span></div>
<div id="filepos1401142" class="calibre1"><span class="calibre10"><span><span class="bold1">The JavaFX Packages</span></span></span></div>
<div class="calibre12"><span>The JavaFX framework is contained in packages that begin with the <span class="bold1">javafx</span> prefix. At the time of this writing, there are more than 30 JavaFX packages in its API library. Here are four examples: <span class="bold1">javafx.application</span>, <span class="bold1">javafx.stage</span>, <span class="bold1">javafx.scene</span>, and <span class="bold1">javafx.scene.layout</span>. Although we will only use a few JavaFX packages in this chapter, you will want to spend some time browsing their capabilities. JavaFX offers a wide array of functionality.</span></div>
<div id="filepos1401800" class="calibre1"><span class="calibre10"><span><span class="bold1">The Stage and Scene Classes</span></span></span></div>
<div class="calibre12"><span>The central metaphor implemented by JavaFX is the <span class="italic">stage</span>. As in the case of an actual stage play, a stage contains a <span class="italic">scene</span>. Thus, loosely speaking, a stage defines a space and a scene defines what goes in that space. Or, put another way, a stage is a container for scenes and a scene is a container for the items that comprise the scene. As a result, all JavaFX applications have at least one stage and one scene. These elements are encapsulated in the JavaFX API by the <span class="bold1">Stage</span> and <span class="bold1">Scene</span> classes. To create a JavaFX application, you will, at minimum, add at least one <span class="bold1">Scene</span> object to a <span class="bold1">Stage</span>. Let’s look a bit more closely at these two classes.</span></div>
<div class="calibre23"><span><span class="bold1">Stage</span> is a top-level container. All JavaFX applications automatically have access to one <span class="bold1">Stage</span>, called the <span class="italic">primary stage</span>. The primary stage is supplied by the run-time system when a JavaFX application is started. Although you can create other stages, for many applications, the primary stage will be the only one required.</span></div>
<div class="calibre23"><span>As mentioned, <span class="bold1">Scene</span> is a container for the items that comprise the scene. These can consist of controls, such as push buttons and check boxes, text, and graphics. To create a scene, you will add those elements to an instance of <span class="bold1">Scene</span>.</span></div>
<div id="filepos1403424" class="calibre1"><span class="calibre10"><span><span class="bold1">Nodes and Scene Graphs</span></span></span></div>
<div class="calibre12"><span>The individual elements of a scene are called <span class="italic">nodes</span>. For example, a push button control is a node. However, nodes can also consist of groups of nodes. Furthermore, a node can have a child node. In this case, a node with a child is called a <span class="italic">parent node</span> or <span class="italic">branch node</span>. Nodes without children are terminal nodes and are called <span class="italic">leaves</span>. The collection of all nodes in a scene creates what is referred to as a <span class="italic">scene graph</span>, which comprises a <span class="italic">tree</span>.</span></div>
<div class="calibre23"><span>There is one special type of node in the scene graph, called the <span class="italic">root node</span>. This is the top-level node and is the only node in the scene graph that does not have a parent. Thus, with the exception of the root node, all other nodes have parents, and all nodes either directly or indirectly descend from the root node.</span></div>
<div class="calibre23"><span>The base class for all nodes is <span class="bold1">Node</span>. There are several other classes that are, either directly or indirectly, subclasses of <span class="bold1">Node</span>. These include <span class="bold1">Parent</span>, <span class="bold1">Group</span>, <span class="bold1">Region</span>, and <span class="bold1">Control</span>, to name a few.</span></div>
<div id="filepos1404804" class="calibre1"><span class="calibre10"><span><span class="bold1">Layouts</span></span></span></div>
<div class="calibre12"><span>JavaFX provides several layout panes that manage the process of placing elements in a scene. For example, the <span class="bold1">FlowPane</span> class provides a flow layout and the <span class="bold1">GridPane</span> class supports a row/column grid-based layout. Several other layouts, such as <span class="bold1">BorderPane</span> (which is similar to the AWT’s <span class="bold1">BorderLayout</span>), are available. Each inherits <span class="bold1">Node</span>. The layouts are packaged in <span class="bold1">javafx.scene.layout</span>.</span></div>
<div id="filepos1405410" class="calibre1"><span class="calibre10"><span><span class="bold1">The Application Class and the Life-cycle Methods</span></span></span></div>
<div class="calibre12"><span>A JavaFX application must be a subclass of the <span class="bold1">Application</span> class, which is packaged in <span class="bold1">javafx.application</span>. Thus, your application class will extend <span class="bold1">Application</span>. The <span class="bold1">Application</span> class defines three life-cycle methods that your application can override. These are called <span class="bold1">init( )</span>, <span class="bold1">start( )</span>, and <span class="bold1">stop( )</span>, and are shown here, in the order in which they are called:</span></div>
<div class="calibre27"><span>void init( )</span></div>
<div class="calibre27"><span>abstract void start(Stage <span class="italic">primaryStage</span>)</span></div>
<div class="calibre27"><span>void stop( )</span></div>
<div class="calibre27"><span>The <span class="bold1">init( )</span> method is called when the application begins execution. It is used to perform various initializations. As will be explained, it <span class="italic">cannot</span>, however, be used to create a stage or build a scene. If no initializations are required, this method need not be overridden because an empty, default version is provided.</span></div>
<div class="calibre23"><span>The <span class="bold1">start( )</span> method is called after <span class="bold1">init( )</span>. This is where your application begins and it <span class="italic">can</span> be used to construct and set the scene. Notice that it is passed a reference to a <span class="bold1">Stage</span> object. This is the stage provided by the run-time system and is the primary stage. Notice that this method is abstract. Thus, it must be overridden by your application.</span></div>
<div class="calibre23"><span>When your application is terminated, the <span class="bold1">stop( )</span> method is called. It is here that you can handle any cleanup or shutdown chores. In cases in which no such actions are needed, an empty, default version is provided.</span></div>
<div id="filepos1407431" class="calibre1"><span class="calibre10"><span><span class="bold1">Launching a JavaFX Application</span></span></span></div>
<div class="calibre12"><span>To start a free-standing JavaFX application, you must call the <span class="bold1">launch( )</span> method defined by <span class="bold1">Application</span>. It has two forms. Here is the one used in this chapter:</span></div>
<div class="calibre27"><span>public static void launch(String … <span class="italic">args</span>)</span></div>
<div class="calibre27"><span>Here, <span class="italic">args</span> is a possibly empty list of strings that typically specify command-line arguments. When called, <span class="bold1">launch( )</span> causes the application to be constructed, followed by calls to <span class="bold1">init( )</span> and <span class="bold1">start( )</span>. The <span class="bold1">launch( )</span> method will not return until after the application has terminated. This version of <span class="bold1">launch( )</span> starts the subclass of <span class="bold1">Application</span> from which <span class="bold1">launch( )</span> is called. The second form of <span class="bold1">launch( )</span> lets you specify a class other than the enclosing class to start.</span></div>
<div class="calibre23"><span>Before moving on, it is necessary to make an important point: JavaFX applications that have been packaged by using the <span class="bold1">javafxpackager</span> tool (or its equivalent in an IDE) do not need to include a call to <span class="bold1">launch( )</span>. However, its inclusion often simplifies the test/debug cycle, and it lets you use the program without creating a JAR file. Thus, it is included in the programs in this chapter.</span></div>
<div id="filepos1408989" class="calibre1"><span class="calibre10"><span><span class="bold1">A JavaFX Application Skeleton</span></span></span></div>
<div class="calibre12"><span>All JavaFX applications share the same basic skeleton. Therefore, before looking at any more JavaFX features, it will be useful to see what that skeleton looks like. In addition to showing the general form of a JavaFX application, the skeleton also illustrates how to launch the application and demonstrates when the life-cycle methods are called. A message noting when each life-cycle method is called is displayed on the console. The complete skeleton is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01036.jpg" class="calibre966"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Although the skeleton is quite short, it can be compiled and run. It produces an empty window. However, it also produces the following output on the console:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01037.jpg" class="calibre967"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>When you close the window, this message is displayed on the console:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01038.jpg" class="calibre968"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Of course, in a real program, the life-cycle methods would not normally output anything to <span class="bold1">System.out</span>. They do so here simply to illustrate when each method is called. Furthermore, as explained earlier, you will need to override the <span class="bold1">init( )</span> and <span class="bold1">stop( )</span> methods only if your application must perform special startup or shutdown actions. Otherwise, you can use the default implementations of these methods provided by the <span class="bold1">Application</span> class.</span></div>
<div class="calibre23"><span>Let’s examine this program in detail. It begins by importing four packages. The first is <span class="bold1">javafx.application</span>, which contains the <span class="bold1">Application</span> class. The <span class="bold1">Scene</span> class is packaged in <span class="bold1">javafx.scene</span>, and <span class="bold1">Stage</span> is packaged in <span class="bold1">javafx.stage</span>. The <span class="bold1">javafx.scene.layout</span> package provides several layout panes. The one used by the program is <span class="bold1">FlowPane</span>.</span></div>
<div class="calibre23"><span>Next, the application class <span class="bold1">JavaFXSkel</span> is created. Notice that it extends <span class="bold1">Application</span>. As explained, <span class="bold1">Application</span> is the class from which all JavaFX applications are derived. <span class="bold1">JavaFXSkel</span> contains four methods. The first is <span class="bold1">main( )</span>. It is used to launch the application via a call to <span class="bold1">launch( )</span>. Notice that the <span class="bold1">args</span> parameter to <span class="bold1">main( )</span> is passed to the <span class="bold1">launch( )</span> method. Although this is a common approach, you can pass a different set of parameters to <span class="bold1">launch( )</span>, or none at all. One other point: <span class="bold1">launch( )</span> is required by a free-standing application, but not in other cases. When it is not needed, <span class="bold1">main( )</span> is also not needed. However, for reasons already explained, both <span class="bold1">main( )</span> and <span class="bold1">launch( )</span> are included in the programs in this chapter.</span></div>
<div class="calibre23"><span>When the application begins, the <span class="bold1">init( )</span> method is called first by the JavaFX run-time system. For the sake of illustration, it simply displays a message on <span class="bold1">System.out</span>, but it would normally be used to initialize some aspect of the application. Of course, if no initialization is required, it is not necessary to override <span class="bold1">init( )</span> because an empty, default implementation is provided. It is important to emphasize that <span class="bold1">init( )</span> cannot be used to create the stage or scene portions of a GUI. Rather, these items should be constructed and displayed by the <span class="bold1">start( )</span> method.</span></div>
<div class="calibre23"><span>After <span class="bold1">init( )</span> finishes, the <span class="bold1">start( )</span> method executes. It is here that the initial scene is created and set to the primary stage. Let’s look at this method line-by-line. First, notice that <span class="bold1">start( )</span> has a parameter of type <span class="bold1">Stage</span>. When <span class="bold1">start( )</span> is called, this parameter will receive a reference to the primary stage of the application. It is to this stage that you will set a scene for the application.</span></div>
<div class="calibre23"><span>After displaying a message on the console that <span class="bold1">start( )</span> has begun execution, it sets the title of the stage using this call to <span class="bold1">setTitle( )</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01039.jpg" class="calibre969"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Although this step is not necessarily required, it is customary for stand-alone applications. This title becomes the name of the main application window.</span></div>
<div class="calibre23"><span>Next, a root node for a scene is created. The root node is the only node in a scene graph that does not have a parent. In this case, a <span class="bold1">FlowPane</span> is used for the root node, but there are several other classes that can be used for the root.</span></div>
<div class="calibre1"><span><img alt="image" src="images/01040.jpg" class="calibre727"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>As mentioned, a <span class="bold1">FlowPane</span> uses a flow layout. This is a layout in which elements are positioned line-by-line, with lines wrapping as needed. (Thus, it works much like the <span class="bold1">FlowLayout</span> class used by the AWT and Swing.) In this case, a horizontal flow is used, but it is possible to specify a vertical flow. Although not needed by this skeletal application, it is also possible to specify other layout properties, such as a vertical and horizontal gap between elements, and an alignment.</span></div>
<div class="calibre23"><span>The following line uses the root node to construct a <span class="bold1">Scene</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01041.jpg" class="calibre970"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span><span class="bold1">Scene</span> provides several versions of its constructor. The one used here creates a scene that has the specified root with the specified width and height. It is shown here:</span></div>
<div class="calibre27"><span>Scene(Parent <span class="italic">rootnode</span>, double <span class="italic">width</span>, double <span class="italic">height</span>)</span></div>
<div class="calibre27"><span>Notice that the type of <span class="italic">rootnode</span> is <span class="bold1">Parent</span>. It is a subclass of <span class="bold1">Node</span> and encapsulates nodes that can have children. Also notice that the width and the height are <span class="bold1">double</span> values. This lets you pass fractional values, if needed. In the skeleton, the root is <span class="bold1">rootNode</span>, the width is 300, and the height is 200.</span></div>
<div class="calibre23"><span>The next line in the program sets <span class="bold1">myScene</span> as the scene for <span class="bold1">myStage</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01042.jpg" class="calibre926"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, <span class="bold1">setScene( )</span> is a method defined by <span class="bold1">Stage</span> that sets the scene to that specified by its argument.</span></div>
<div class="calibre23"><span>In cases in which you don’t make further use of the scene, you can combine the previous two steps, as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01043.jpg" class="calibre971"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Because of its compactness, this form will be used by most of the subsequent examples.</span></div>
<div class="calibre23"><span>The last line in <span class="bold1">start( )</span> displays the stage and its scene:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01044.jpg" class="calibre972"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>In essence, <span class="bold1">show( )</span> shows the window that was created by the stage and scene.</span></div>
<div class="calibre23"><span>When you close the application, its window is removed from the screen and the <span class="bold1">stop( )</span> method is called by the JavaFX run-time system. In this case, <span class="bold1">stop( )</span> simply displays a message on the console, illustrating when it is called. However, <span class="bold1">stop( )</span> would not normally display anything. Furthermore, if your application does not need to handle any shutdown actions, there is no reason to override <span class="bold1">stop( )</span> because an empty, default implementation is provided.</span></div>
<div id="filepos1418080" class="calibre1"><span class="calibre10"><span><span class="bold1">Compiling and Running a JavaFX Program</span></span></span></div>
<div class="calibre12"><span>One important advantage of JavaFX is that the same program can be run in a variety of different execution environments. For example, you can run a JavaFX program as a stand-alone desktop application, inside a web browser, or as a Web Start application. However, different ancillary files may be needed in some cases, such as an HTML file or a Java Network Launch Protocol (JNLP) file.</span></div>
<div class="calibre23"><span>In general, a JavaFX program is compiled like any other Java program. However, depending on the target execution environment, some additional steps may be required. For this reason, often the easiest way to compile a JavaFX application is to use an Integrated Development Environment (IDE) that fully supports JavaFX programming. If you just want to compile and test the JavaFX applications shown in this chapter, you can easily do so using the command-line tools. Just compile and run the application in the normal way, using <span class="bold1">javac</span> and <span class="bold1">java</span>. This creates a stand-alone application that runs on the desktop.</span></div>
<div id="filepos1419363" class="calibre1"><span class="calibre10"><span><span class="bold1">The Application Thread</span></span></span></div>
<div class="calibre12"><span>In the preceding discussion, it was mentioned that you cannot use the <span class="bold1">init( )</span> method to construct a stage or scene. You also cannot create these items inside the application’s constructor. The reason is that a stage or scene must be constructed on the <span class="italic">application thread</span>. However, the application’s constructor and the <span class="bold1">init( )</span> method are called on the main thread, also called the <span class="italic">launcher thread</span>. Thus, they can’t be used to construct a stage or scene. Instead, you must use the <span class="bold1">start( )</span> method, as the skeleton demonstrates, to create the initial GUI because <span class="bold1">start( )</span> is called on the application thread.</span></div>
<div class="calibre23"><span>Furthermore, any changes to the GUI currently displayed must be made from the application thread. Fortunately, in JavaFX, events are sent to your program on the application thread. Therefore, event handlers can be used to interact with the GUI. The <span class="bold1">stop( )</span> method is also called on the application thread.</span></div>
<div id="filepos1420606" class="calibre1"><span class="calibre10"><span><span class="bold1">A Simple JavaFX Control: Label</span></span></span></div>
<div class="calibre12"><span>The primary ingredient in most user interfaces is the control because a control enables the user to interact with the application. As you would expect, JavaFX supplies a rich assortment of controls. The simplest control is the label because it just displays a message or an image. Although quite easy to use, the label is a good way to introduce the techniques needed to begin building a scene graph.</span></div>
<div class="calibre23"><span>The JavaFX label is an instance of the <span class="bold1">Label</span> class, which is packaged in <span class="bold1">javafx.scene.control</span>. Label inherits <span class="bold1">Labeled</span> and <span class="bold1">Control</span>, among other classes. The <span class="bold1">Labeled</span> class defines several features that are common to all labeled elements (that is, those that can contain text), and <span class="bold1">Control</span> defines features related to all controls.</span></div>
<div class="calibre23"><span>The <span class="bold1">Label</span> constructor that we will use is shown here:</span></div>
<div class="calibre27"><span>Label(String <span class="italic">str</span>)</span></div>
<div class="calibre27"><span>The string that is displayed is specified by <span class="italic">str</span>.</span></div>
<div class="calibre23"><span>Once you have created a label (or any other control) it must be added to the scene’s content, which means adding it to the scene graph. To do this, you will first call <span class="bold1">getChildren( )</span> on the root node of the scene graph. It returns a list of the child nodes in the form of an <span class="bold1">ObservableList&lt;Node&gt;</span>. <span class="bold1">ObservableList</span> is packaged in <span class="bold1">javafx.collections</span>, and it inherits <span class="bold1">java.util.List</span>, which is part of Java’s Collections Framework. <span class="bold1">List</span> defines a collection that represents a list of objects. Although a discussion of <span class="bold1">List</span> and the Collections Framework is beyond the scope of this book, it is easy to use <span class="bold1">ObservableList</span> to add child nodes. Simply call <span class="bold1">add( )</span> on the list of child nodes returned by <span class="bold1">getChildren( )</span>, passing in a reference to the node to add, which in this case is a label.</span></div>
<div class="calibre23"><span>The following program puts the preceding discussion into action by creating a simple JavaFX application that displays a label:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01045.jpg" class="calibre973"/></span></div><div class="calibre11"> </div>
<div class="calibre29"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   You have explained how to add a node to the scene graph. Is there a way to remove one?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   Yes, to remove a control from the scene graph, call <span class="bold1">remove( )</span> on the <span class="bold1">ObservableList</span>. For example,</span></div>
<div class="calibre1"><span><img alt="image" src="images/01046.jpg" class="calibre974"/></span></div>
<div class="calibre1"><span>removes <span class="bold1">myLabel</span> from the scene. In general, <span class="bold1">ObservableList</span> supports a wide range of list-management methods. Here are two examples. You can determine if the list is empty by calling <span class="bold1">isEmpty( )</span>. You can obtain the number of nodes in the list by calling <span class="bold1">size( )</span>. You will want to explore <span class="bold1">ObservableList</span> on your own as you advance in your study of JavaFX.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre23"><span>This program produces the following window:</span></div>
<div class="calibre29"><span><img alt="image" src="images/01047.jpg" class="calibre975"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>In the program, pay special attention to this line:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01048.jpg" class="calibre976"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>It adds the label to the list of children for which <span class="bold1">rootNode</span> is the parent. Although this line could be separated into its individual pieces if necessary, you will often see it as shown here.</span></div>
<div class="calibre23"><span>Before moving on, it is useful to point out that <span class="bold1">ObservableList</span> provides a method called <span class="bold1">addAll( )</span> that can be used to add two or more children to the scene graph in a single call. You will see an example of this shortly.</span></div>
<div id="filepos1425828" class="calibre1"><span class="calibre10"><span><span class="bold1">Using Buttons and Events</span></span></span></div>
<div class="calibre12"><span>Although the program in the preceding section presents a simple example of using a JavaFX control and constructing a scene graph, it does not show how to handle events. Event handling is important because most GUI controls generate events that are handled by your program. For example, buttons, check boxes, and lists all generate events when they are used. In many ways, event handling in JavaFX is similar to event handling in Swing as shown in the preceding chapter, but it’s more streamlined. One commonly used control is the button. This makes button events one of the most frequently handled. Therefore, a button is a good way to introduce event handling in JavaFX. For this reason, the fundamentals of event handling and the button are described together.</span></div>
<div id="filepos1426787" class="calibre1"><span class="calibre10"><span><span class="bold1">Event Basics</span></span></span></div>
<div class="calibre12"><span>The base class for JavaFX events is the <span class="bold1">Event</span> class, which is packaged in <span class="bold1">javafx.event</span>. <span class="bold1">Event</span> inherits <span class="bold1">java.util.EventObject</span>, which means that JavaFX events share the same basic functionality as other Java events. Several subclasses of <span class="bold1">Event</span> are defined. The one that we will use here is <span class="bold1">ActionEvent</span>. It encapsulates action events generated by a button.</span></div>
<div class="calibre23"><span>In general, JavaFX uses what is, in essence, the delegation event model approach to event handling. To handle an event, you must first register the handler that acts as a listener for the event. When the event occurs, the listener is called. It must then respond to the event and return. In this regard, JavaFX events are managed much like Swing events.</span></div>
<div class="calibre23"><span>Events are handled by implementing the <span class="bold1">EventHandler</span> interface, which is also in <span class="bold1">javafx.event</span>. It is a generic interface with the following form:</span></div>
<div class="calibre27"><span>Interface EventHandler&lt;T extends Event&gt;</span></div>
<div class="calibre27"><span>Here, <span class="bold1">T</span> specifies the type of event that the handler will handle. It defines one method, called <span class="bold1">handle( )</span>, which receives the event object as a parameter. It is shown here:</span></div>
<div class="calibre27"><span>void handle(T <span class="italic">eventObj</span>)</span></div>
<div class="calibre27"><span>In this case, <span class="italic">eventObj</span> is the event that was generated. Typically, event handlers are implemented through anonymous inner classes or lambda expressions, but you can use stand-alone classes for this purpose if it is more appropriate to your application (for example, if one event handler will handle events from more than one source).</span></div>
<div id="filepos1428877" class="calibre1"><span class="calibre10"><span><span class="bold1">Introducing the Button Control</span></span></span></div>
<div class="calibre12"><span>In JavaFX, the push button control is provided by the <span class="bold1">Button</span> class, which is in <span class="bold1">javafx.scene.control</span>. <span class="bold1">Button</span> inherits a fairly long list of base classes that include <span class="bold1">ButtonBase</span>, <span class="bold1">Labeled</span>, <span class="bold1">Region</span>, <span class="bold1">Control</span>, <span class="bold1">Parent</span>, and <span class="bold1">Node</span>. If you examine the API documentation for <span class="bold1">Button</span>, you will see that much of its functionality comes from its base classes. Furthermore, it supports a wide array of options. However, here we will use its default form. Buttons can contain text, graphics, or both. In this example, we will use text-based buttons.</span></div>
<div class="calibre23"><span>The <span class="bold1">Button</span> constructor we will use is shown here:</span></div>
<div class="calibre27"><span>Button(String <span class="italic">str</span>)</span></div>
<div class="calibre27"><span>In this case, <span class="italic">str</span> is the message that is displayed in the button.</span></div>
<div class="calibre23"><span>When a button is pressed, an <span class="bold1">ActionEvent</span> is generated. <span class="bold1">ActionEvent</span> is packaged in <span class="bold1">javafx.event</span>. You can register a listener for this event by calling <span class="bold1">setOnAction( )</span> on the button. It has this general form:</span></div>
<div class="calibre27"><span>final void setOnAction(EventHandler&lt;ActionEvent&gt; <span class="italic">handler</span>)</span></div>
<div class="calibre27"><span>Here, <span class="italic">handler</span> is the handler being registered. As mentioned, often you will use an anonymous inner class or lambda expression for the handler. The <span class="bold1">setOnAction( )</span> method sets the property <span class="bold1">onAction</span>, which stores a reference to the handler. As with all other Java event handling, your handler must respond to the event as fast as possible and then return. If your handler consumes too much time, it will noticeably slow down the application. For lengthy operations, you must use a separate thread of execution.</span></div>
<div id="filepos1431063" class="calibre1"><span class="calibre10"><span><span class="bold1">Demonstrating Event Handling and the Button</span></span></span></div>
<div class="calibre12"><span>The following program demonstrates event handling and the <span class="bold1">Button</span> control. It uses two buttons and a label. The buttons are called Up and Down. Each time a button is pressed, the content of the label is set to display which button was pressed. Thus, it functions similarly to the <span class="bold1">JButton</span> example in the preceding chapter. You might find it interesting to compare the code for each.</span></div>
<div class="calibre1"><span><img alt="image" src="images/01049.jpg" class="calibre977"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/01050.jpg" class="calibre785"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Sample output from this program is shown here:</span></div>
<div class="calibre29"><span><img alt="image" src="images/01051.jpg" class="calibre978"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Let’s examine a few key portions of this program. First, notice how buttons are created by these two lines:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01052.jpg" class="calibre979"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>This creates two text-based buttons. The first displays the string Up; the second displays Down.</span></div>
<div class="calibre23"><span>Next, an action event handler is set for each of these buttons. The sequence for the Up button is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01053.jpg" class="calibre980"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>As explained, buttons respond to events of type <span class="bold1">ActionEvent</span>. To register a handler for these events, the <span class="bold1">setOnAction( )</span> method is called on the button. It uses an anonymous inner class to implement the <span class="bold1">EventHandler</span> interface. (Recall that <span class="bold1">EventHandler</span> defines only the <span class="bold1">handle( )</span> method.) Inside <span class="bold1">handle( )</span>, the text in the <span class="bold1">response</span> label is set to reflect the fact that the Up button was pressed. Notice that this is done by calling the <span class="bold1">setText( )</span> method on the label. Events are handled by the Down button in the same way.</span></div>
<div class="calibre23"><span>After the event handlers have been set, the <span class="bold1">response</span> label and the buttons <span class="bold1">btnUp</span> and <span class="bold1">btnDown</span> are added to the scene graph by using a call to <span class="bold1">addAll( )</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01054.jpg" class="calibre82"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The <span class="bold1">addAll( )</span> method adds a list of nodes to the invoking parent node. Of course, these nodes could have been added by three separate calls to <span class="bold1">add( )</span>, but the <span class="bold1">addAll( )</span> method is more convenient to use in this situation.</span></div>
<div class="calibre23"><span>There are two other things of interest in this program that relate to the way the controls are displayed in the window. First, when the root node is created, this statement is used:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01055.jpg" class="calibre768"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, the <span class="bold1">FlowPane</span> constructor is passed two values. These specify the horizontal and vertical gap that will be left around elements in the scene. If these gaps are not specified, then two elements (such as two buttons) would be positioned in such a way that no space was between them. Thus, the controls would run together, creating a very unappealing user interface. Specifying gaps prevents this.</span></div>
<div class="calibre23"><span>The second point of interest is the following line, which sets the alignment of the elements in the <span class="bold1">FlowPane</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01056.jpg" class="calibre119"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, the alignment of the elements is centered. This is done by calling <span class="bold1">setAlignment( )</span> on the <span class="bold1">FlowPane</span>. The value <span class="bold1">Pos.CENTER</span> specifies that both a vertical and horizontal center will be used. Other alignments are possible. <span class="bold1">Pos</span> is an enumeration that specifies alignment constants. It is packaged in <span class="bold1">javafx.geometry</span>.</span></div>
<div class="calibre23"><span>Before moving on, one more point needs to be made. The preceding program used anonymous inner classes to handle button events. However, because the <span class="bold1">EventHandler</span> interface defines only one abstract method, <span class="bold1">handle( )</span>, a lambda expression could have passed to <span class="bold1">setOnAction( )</span>, instead. For example, here is the handler for the Up button, rewritten to use a lambda:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01057.jpg" class="calibre649"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Notice that the lambda expression is more compact than the anonymous inner class. (You will use lambda expressions when you modify this example as part of exercise 10 in the Self Test.)</span></div>
<div id="filepos1436753" class="calibre1"><span class="calibre10"><span><span class="bold1">Three More JavaFX Controls</span></span></span></div>
<div class="calibre12"><span>JavaFX defines a rich set of controls, which are packaged in <span class="bold1">javafx.scene.control</span>. You have already seen two of them: <span class="bold1">Label</span> and <span class="bold1">Button</span>. Here, we will look at three more: <span class="bold1">CheckBox</span>, <span class="bold1">ListView</span>, and <span class="bold1">TextField</span>. As their names imply, they support a check box, a list control, and a text field. Combined, these provide a representative sampling of the JavaFX controls. They also help demonstrate several common techniques. Once you understand the basics, you will be able to explore the other controls on your own.</span></div>
<div class="calibre23"><span>The controls described here provide functionality similar to that of the Swing controls presented by the preceding Swing chapter. As you work through this section, you might find it interesting to compare the way these controls are implemented by the two frameworks.</span></div>
<div id="filepos1437833" class="calibre1"><span class="calibre10"><span><span class="bold1">CheckBox</span></span></span></div>
<div class="calibre12"><span>In JavaFX, the check box is encapsulated by the <span class="bold1">CheckBox</span> class. Its immediate superclass is <span class="bold1">ButtonBase</span>. Thus it is a special type of button. Although you are no doubt familiar with check boxes because they are widely used controls, the JavaFX check box is a bit more sophisticated than you may at first think. This is because <span class="bold1">CheckBox</span> supports three states. The first two are checked or unchecked, as you would expect, and this is the default behavior. The third state is <span class="italic">indeterminate</span> (also called <span class="italic">undefined</span>). This state is typically used to indicate that the state of the check box has not been set or that it is not relevant to a specific situation. To use the indeterminate state, you will need to explicitly enable it. This procedure is demonstrated in <a href="#filepos1441861">Try This 17-1</a>. Here, we will examine the <span class="bold1">CheckBox</span>’s traditional operation.</span></div>
<div class="calibre23"><span>Here is the <span class="bold1">CheckBox</span> constructor that we will use:</span></div>
<div class="calibre27"><span>CheckBox(String <span class="italic">str</span>)</span></div>
<div class="calibre27"><span>It creates a check box that has the text specified by <span class="italic">str</span> as a label. As with other buttons, a <span class="bold1">CheckBox</span> generates an action event when it is selected.</span></div>
<div class="calibre23"><span>The following program demonstrates check boxes. It displays four check boxes that represent different types of computers. They are labeled Smartphone, Tablet, Notebook, and Desktop. Each time a check-box state changes, an action event is generated. It is handled by displaying the new state (selected or cleared) and by displaying a list of all selected boxes.</span></div>
<div class="calibre1"><span><img alt="image" src="images/01058.jpg" class="calibre981"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/01059.jpg" class="calibre953"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/01060.jpg" class="calibre982"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/01061.jpg" class="calibre983"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Sample output is shown here:</span></div>
<div class="calibre29"><span><img alt="image" src="images/01062.jpg" class="calibre984"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>The operation of this program is straightforward. Each time a check box is changed, an <span class="bold1">ActionEvent</span> is generated. The handlers for these events first report whether the check box was selected or cleared. To do this, they call the <span class="bold1">isSelected( )</span> method on the event source. It returns <span class="bold1">true</span> if the check box was just selected, and <span class="bold1">false</span> if it was just cleared. Next, the <span class="bold1">showAll( )</span> method is called, which displays all selected check boxes.</span></div>
<div class="calibre23"><span>There is one other point of interest in the program. Notice that it uses a vertical flow pane for the layout, as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01063.jpg" class="calibre780"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>By default, <span class="bold1">FlowPane</span> flows horizontally. A vertical flow is created by passing the value <span class="bold1">Orientation.VERTICAL</span> as the first argument to the <span class="bold1">FlowPane</span> constructor.</span></div>
<div class="calibre18"> </div><table cellspacing="0" cellpadding="0" class="calibre37">
<colgroup class="calibre38">
<col class="calibre72"/>
<col class="calibre73"/>
</colgroup>
<tr class="calibre41">
<td valign="top" id="filepos1441861" class="calibre74"><span class="calibre10"><span class="bold1">Try This 17-1</span> </span></td>
<td valign="top" class="calibre75"><span class="calibre10">Use the CheckBox Indeterminate State</span></td>
</tr></table><div class="calibre43"> </div>
<div class="calibre1"><span><img alt="image" src="images/01064.jpg" class="calibre985"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>As explained, by default, <span class="bold1">CheckBox</span> implements two states: checked and unchecked. However, <span class="bold1">CheckBox</span> also supports a third, indeterminate state, which can be used to indicate that the state of the box has not yet been set or that an option is not applicable to a situation. The indeterminate state for a check box must be explicitly enabled. It is not provided by default. Also, the event handler for the check box must also handle the indeterminate state. The project illustrates the process. It does so by adding support for the indeterminate state to the <span class="bold1">Smartphone</span> check box in <span class="bold1">CheckboxDemo</span> program, just shown.</span></div>
<div class="calibre19"><span>  <span class="bold1">1.</span>  To enable the indeterminate state in a check box, call <span class="bold1">setAllowIndeterminate( )</span>, shown here:</span></div>
<div class="calibre47"><span>        final void setAllowIndeterminate(boolean <span class="italic">enable</span>)</span></div>
<div class="calibre47"><span>        If <span class="italic">enable</span> is <span class="bold1">true</span>, the indeterminate state is enabled. Otherwise, it is disabled. When the indeterminate state is enabled, the user can select between checked, unchecked, and indeterminate. Therefore, to enable the indeterminate state on the <span class="bold1">Smartphone</span> check box, add this line:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/01065.jpg" class="calibre768"/></span></div>
<div class="calibre47"><span>  <span class="bold1">2.</span>  To determine if a check box is in the indeterminate state, call <span class="bold1">isIndeterminate( )</span>, shown here:</span></div>
<div class="calibre47"><span>        final boolean isIndeterminate( )</span></div>
<div class="calibre47"><span>        It returns <span class="bold1">true</span> if the check box state is indeterminate and <span class="bold1">false</span> otherwise. The event handler for the check box will need to test for the indeterminate state. To do so, add it to the <span class="bold1">Smartphone</span> event handler, as shown here:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/01066.jpg" class="calibre986"/></span></div>
<div class="calibre47"><span>  <span class="bold1">3.</span>  After making these changes, compile and run the program. Now, you can set the state of the <span class="bold1">Smartphone</span> check box to indeterminate, as shown here:</span></div>
<div class="calibre29"><span><img alt="image" src="images/01067.jpg" class="calibre984"/></span></div><div class="calibre11"> </div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos1445643" class="calibre9"><span class="calibre10"><span><span class="bold1">ListView</span></span></span></div>
<div class="calibre12"><span>Another commonly used control is the list view, which in JavaFX is encapsulated by <span class="bold1">ListView</span>. A <span class="bold1">ListView</span> can display a list of entries from which you can select one or more. One very useful feature of <span class="bold1">ListView</span> is that scrollbars are automatically added when the number of items in the list exceeds the number that can be displayed within the control’s dimensions. Because of its ability to make efficient use of limited screen space, <span class="bold1">ListView</span> is a popular alternative to other types of selection controls.</span></div>
<div class="calibre23"><span><span class="bold1">ListView</span> is a generic class that is declared like this:</span></div>
<div class="calibre27"><span>class ListView&lt;T&gt;</span></div>
<div class="calibre27"><span>Here, <span class="bold1">T</span> specifies the type of entries stored in the list view. Often, these are entries of type <span class="bold1">String</span>, but other types are also allowed.</span></div>
<div class="calibre23"><span>Here is the <span class="bold1">ListView</span> constructor that we will use:</span></div>
<div class="calibre27"><span>ListView(ObservableList&lt;T&gt; <span class="italic">list</span>)</span></div>
<div class="calibre27"><span>The list of items to be displayed is specified by <span class="italic">list</span>. It is an object of type <span class="bold1">ObservableList</span>. As explained earlier, <span class="bold1">ObservableList</span> supports a list of objects. By default, a <span class="bold1">ListView</span> allows only one item in the list to be selected at any one time. You can allow multiple selections by changing the selection mode, but we will use the default, single-selection mode.</span></div>
<div class="calibre23"><span>Probably the easiest way to create an <span class="bold1">ObservableList</span> for use in a <span class="bold1">ListView</span> is to use the factory method <span class="bold1">observableArrayList( )</span>, which is a <span class="bold1">static</span> method defined by the <span class="bold1">FXCollections</span> class (which is packaged in <span class="bold1">javafx.collections</span>). The version we will use is shown here:</span></div>
<div class="calibre27"><span>static &lt;E&gt; ObservableList&lt;E&gt; observableArrayList(E … <span class="italic">elements</span>)</span></div>
<div class="calibre27"><span>In this case, <span class="bold1">E</span> specifies the type of elements, which are passed via <span class="italic">elements</span>.</span></div>
<div class="calibre23"><span>Although <span class="bold1">ListView</span> provides a default size, sometimes you will want to set the preferred height and/or width to best match your needs. One way to do this is to call the <span class="bold1">setPrefHeight( )</span> and <span class="bold1">setPrefWidth( )</span> methods, shown here:</span></div>
<div class="calibre27"><span>final void setPrefHeight(double <span class="italic">height</span>)</span></div>
<div class="calibre27"><span>final void setPrefWidth(double <span class="italic">width</span>)</span></div>
<div class="calibre27"><span>Alternatively, you can use a single call to set both dimensions at the same time by use of <span class="bold1">setPrefSize( )</span>, shown here:</span></div>
<div class="calibre27"><span>void setPrefSize(double <span class="italic">width</span>, double <span class="italic">height</span>)</span></div>
<div class="calibre592"><span>There are two basic ways in which you can use a <span class="bold1">ListView</span>. First, you can ignore events generated by the list and simply obtain the selection in the list when your program needs it. Second, you can monitor the list for changes by registering a change listener. This lets you respond each time the user changes a selection in the list. This is the approach used here.</span></div>
<div class="calibre23"><span>A change listener is supported by the <span class="bold1">ChangeListener</span> interface, which is packaged in <span class="bold1">javafx.beans.value</span>. The <span class="bold1">ChangeListener</span> interface defines only one method, called <span class="bold1">changed( )</span>. It is shown here:</span></div>
<div class="calibre27"><span>void changed(ObservableValue&lt;? extends T&gt; <span class="italic">changed</span>, T <span class="italic">oldVal</span>, T <span class="italic">newVal</span>)</span></div>
<div class="calibre27"><span>In this case, <span class="italic">changed</span> is the instance of <span class="bold1">ObservableValue&lt;T&gt;</span> which encapsulates an object that can be watched for changes. The <span class="italic">oldVal</span> and <span class="italic">newVal</span> parameters pass the previous value and the new value, respectively. Thus, in this case, <span class="italic">newVal</span> holds a reference to the list item that has just been selected.</span></div>
<div class="calibre23"><span>To listen for change events, you must first obtain the selection model used by the <span class="bold1">ListView</span>. This is done by calling <span class="bold1">getSelectionModel( )</span> on the list. It is shown here:</span></div>
<div class="calibre27"><span>final MultipleSelectionModel&lt;T&gt; getSelectionModel( )</span></div>
<div class="calibre27"><span>It returns a reference to the model. <span class="bold1">MulitpleSelectionModel</span> is a class that defines the model used for multiple selections, and it inherits <span class="bold1">SelectionModel</span>. However, multiple selections are allowed in a <span class="bold1">ListView</span> only if multiple-selection mode is turned on.</span></div>
<div class="calibre23"><span>Using the model returned by <span class="bold1">getSelectionModel( )</span>, you will obtain a reference to the selected item property that defines what takes place when an element in the list is selected. This is done by calling <span class="bold1">selectedItemProperty( )</span>, shown next:</span></div>
<div class="calibre27"><span>final ReadOnlyObjectProperty&lt;T&gt; selectedItemProperty( )</span></div>
<div class="calibre27"><span>You will add the change listener to this property by using the <span class="bold1">addListener( )</span> method on the returned property. The <span class="bold1">addListener( )</span> method is shown here:</span></div>
<div class="calibre27"><span>void addListener(ChangeListener&lt;? super T&gt; <span class="italic">listener</span>)</span></div>
<div class="calibre27"><span>In this case, <span class="bold1">T</span> specifies the type of the property.</span></div>
<div class="calibre23"><span>The following example puts the preceding discussion into action. It creates a list view that displays a list of computer types, allowing the user to select one. When one is chosen, the selection is displayed.</span></div>
<div class="calibre1"><span><img alt="image" src="images/01068.jpg" class="calibre328"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/01069.jpg" class="calibre987"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Sample output is shown here.</span></div>
<div class="calibre29"><span><img alt="image" src="images/01070.jpg" class="calibre988"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Notice that a vertical scroll bar has been included so that the list can be scrolled to see all of its entries. As mentioned, when the contents of a <span class="bold1">ListView</span> exceed its size, a scroll bar is automatically added. This makes <span class="bold1">ListView</span> a very convenient control.</span></div>
<div class="calibre23"><span>In the program, pay special attention to how the <span class="bold1">ListView</span> is constructed. First, an <span class="bold1">ObservableList</span> is created by this line:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01071.jpg" class="calibre989"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>It uses the <span class="bold1">observableArrayList( )</span> method to create a list of strings. Then, the <span class="bold1">ObservableList</span> is used to initialize a <span class="bold1">ListView</span>, as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01072.jpg" class="calibre780"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The program then sets the preferred width and height of the control.</span></div>
<div class="calibre23"><span>Now, notice how the selection model is obtained for <span class="bold1">lvComputers</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01073.jpg" class="calibre276"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>As explained, <span class="bold1">ListView</span> uses <span class="bold1">MultipleSelectionModel</span>, even when only a single selection is allowed. The <span class="bold1">selectedItemProperty( )</span> method is then called on the model and a change listener is registered, as shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/01074.jpg" class="calibre990"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>As a point of interest, the same basic mechanism used to listen for and handle change events can be applied to any control that generates change events.</span></div>
<div class="calibre35"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   How do I enable multiple selections in a ListView?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   When using a <span class="bold1">ListView</span>, if you want to allow more than one item to be selected, you must explicitly request it. To do so, you must set the selection mode by calling <span class="bold1">setSelectionMode( )</span> on the <span class="bold1">ListView</span> model. It is shown here:</span></div>
<div class="calibre1"><span>final void setSelectionMode(SelectionMode <span class="italic">mode</span>)</span></div>
<div class="calibre1"><span>In this case, <span class="italic">mode</span> must be either <span class="bold1">SelectionMode.MULTIPLE</span> or <span class="bold1">SelectionMode.SINGLE</span>. To enable multiple selections, use <span class="bold1">SelectionMode.MULTIPLE</span>.</span></div>
<div class="calibre624"><span>One way to get a list of the selected items is to call <span class="bold1">getSelectedItems( )</span> on the selection model. It is shown here:</span></div>
<div class="calibre1"><span>ObservableList&lt;T&gt; getSelectedItems( )</span></div>
<div class="calibre1"><span>It returns an <span class="bold1">ObservableList</span> of the items. You could then cycle through the returned list using a for-each <span class="bold1">for</span>, for example, to examine the items.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos1456861" class="calibre9"><span class="calibre10"><span><span class="bold1">TextField</span></span></span></div>
<div class="calibre12"><span>Controls such as <span class="bold1">Button</span>, <span class="bold1">CheckBox</span>, and <span class="bold1">ListView</span> are, obviously, quite useful, but they all implement a means of selecting a predetermined option or action. Sometimes, however, you will want the user to enter a string of his or her own choosing. To accommodate this type of input, JavaFX includes several text-based controls. The one we will look at is <span class="bold1">TextField</span>. It allows one line of text to be entered. Thus, it is useful for obtaining names, ID strings, addresses, and the like. Like all JavaFX text controls, <span class="bold1">TextField</span> inherits <span class="bold1">TextInputControl</span>, which defines much of its functionality.</span></div>
<div class="calibre23"><span><span class="bold1">TextField</span> defines two constructors. The first is the default constructor, which creates an empty text field that has the default size. The second lets you specify the initial contents of the field. Here, we will use the default constructor.</span></div>
<div class="calibre23"><span>Although the default size of a <span class="bold1">TextField</span> is sometimes adequate, often you will want to specify its size. This is done by calling <span class="bold1">setPrefColumnCount( )</span>, shown here:</span></div>
<div class="calibre27"><span>final void setPrefColumnCount(int <span class="italic">columns</span>)</span></div>
<div class="calibre27"><span>The <span class="italic">columns</span> value is used by <span class="bold1">TextField</span> to determine its size.</span></div>
<div class="calibre23"><span>You can set the text in a text field by calling <span class="bold1">setText( )</span>. You can obtain the current text by calling <span class="bold1">getText( )</span>. In addition to these fundamental operations, <span class="bold1">TextField</span> supports several other capabilities that you might want to explore, such as cut, paste, and append. You can also select a portion of the text under program control.</span></div>
<div class="calibre23"><span>One especially useful <span class="bold1">TextField</span> option is the ability to set a prompting message inside the text field when the user attempts to use a blank field. To do this, call <span class="bold1">setPromptText( )</span>, shown here:</span></div>
<div class="calibre27"><span>final void setPromptText(String <span class="italic">str</span>)</span></div>
<div class="calibre27"><span>In this case, <span class="italic">str</span> is the string displayed in the text field when no text has been entered. It is displayed using low-intensity (such as a gray tone).</span></div>
<div class="calibre23"><span>When the user presses <small class="calibre16">ENTER</small> while inside a <span class="bold1">TextField</span>, an action event is generated. Although handling this event is often helpful, in some cases, your program will simply obtain the text when it is needed, rather than handling action events. Both approaches are demonstrated by the following program. It creates a text field that requests a name. When the user presses <small class="calibre16">ENTER</small> while the text field has input focus, or presses the Get Name button, the string is obtained and displayed. Notice that a prompting message is also included.</span></div>
<div class="calibre1"><span><img alt="image" src="images/01075.jpg" class="calibre991"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/01076.jpg" class="calibre511"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/01077.jpg" class="calibre591"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Sample output is shown here:</span></div>
<div class="calibre29"><span><img alt="image" src="images/01078.jpg" class="calibre992"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>In the program, notice that lambda expressions are used as event handlers. Each handler consists of a single method call. This makes them perfect candidates for lambda expressions.</span></div>
<div class="calibre35"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   What other text controls does JavaFX support?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   Other text controls include <span class="bold1">TextArea</span>, which supports multiline text, and <span class="bold1">PasswordField</span>, which can be used to input passwords. You might also find <span class="bold1">HTMLEditor</span> helpful.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos1461976" class="calibre9"><span class="calibre10"><span><span class="bold1">Introducing Effects and Transforms</span></span></span></div>
<div class="calibre12"><span>A principal advantage of JavaFX is its ability to alter the precise look of a control (or any node in the scene graph) through the application of an <span class="italic">effect</span> and/or a <span class="italic">transform</span>. Both effects and transforms help give your GUI the sophisticated, modern look that users have come to expect. As you will see, the ease with which effects and/or transforms can be used in JavaFX is one of its strongest features. Although the topic of effects and transforms is quite large, the following introduction will give you an idea of the benefits they provide.</span></div>
<div id="filepos1462734" class="calibre1"><span class="calibre10"><span><span class="bold1">Effects</span></span></span></div>
<div class="calibre12"><span>Effects are supported by the abstract <span class="bold1">Effect</span> class and its concrete subclasses, which are packaged in <span class="bold1">javafx.scene.effect</span>. Using these effects, you can customize the way a node in a scene graph looks. Several built-in effects are provided. Here is a sampling:</span></div>
<div class="calibre11"> </div><table cellspacing="0" cellpadding="3" border="1" class="calibre37">
<colgroup class="calibre38">
<col class="calibre39"/>
<col class="calibre40"/>
</colgroup>
<tr class="calibre41">
<td class="calibre42">Bloom</td>
<td class="calibre42">Increases the brightness of the brighter parts of a node.</td>
</tr>
<tr class="calibre41">
<td class="calibre42">BoxBlur</td>
<td class="calibre42">Blurs a node.</td>
</tr>
<tr class="calibre41">
<td class="calibre42">DropShadow</td>
<td class="calibre42">Displays a shadow that appears behind the node.</td>
</tr>
<tr class="calibre41">
<td class="calibre42">Glow</td>
<td class="calibre42">Produces a glowing effect.</td>
</tr>
<tr class="calibre41">
<td class="calibre42">InnerShadow</td>
<td class="calibre42">Displays a shadow inside a node.</td>
</tr>
<tr class="calibre41">
<td class="calibre42">Lighting</td>
<td class="calibre42">Creates the shadow effects of a light source.</td>
</tr>
<tr class="calibre41">
<td class="calibre42">Reflection</td>
<td class="calibre42">Displays a reflection.</td>
</tr>
</table><div class="calibre43"> </div>
<div class="calibre12"><span>These, and the other effects, are easy to use and are available to any <span class="bold1">Node</span>, including controls. Of course, depending on the control, some effects will be more appropriate than others.</span></div>
<div class="calibre23"><span>To set an effect on a node, call <span class="bold1">setEffect( )</span>, which is defined by <span class="bold1">Node</span>. It is shown here:</span></div>
<div class="calibre27"><span>final void setEffect(Effect <span class="italic">effect</span>)</span></div>
<div class="calibre27"><span>In this case, <span class="italic">effect</span> is the effect that will be applied. To specify no effect, pass <span class="bold1">null</span>. Thus, to add an effect to a node, first create an instance of that effect and then pass it to <span class="bold1">setEffect( )</span>. Once this has been done, the effect will be used whenever the node is rendered (as long as the effect is supported by the environment). To demonstrate the power of effects, we will use two of them: <span class="bold1">Reflection</span> and <span class="bold1">BoxBlur</span>. However, the process of adding an effect is essentially the same no matter what effect you choose.</span></div>
<div class="calibre23"><span><span class="bold1">BoxBlur</span> blurs the node on which it is used. It is called <span class="bold1">BoxBlur</span> because it uses a blurring technique based on adjusting pixels within a rectangular region. The amount of blurring is under your control. To use a blur effect, you must first create a <span class="bold1">BoxBlur</span> instance. <span class="bold1">BoxBlur</span> supplies two constructors. Here is the constructor that we will use:</span></div>
<div class="calibre27"><span>BoxBlur(double <span class="italic">width</span>, double <span class="italic">height</span>, int <span class="italic">iterations</span>)</span></div>
<div class="calibre27"><span>Here, <span class="italic">width</span> and <span class="italic">height</span> specify the size of box into which a pixel will be blurred. These values must be between 0 and 255, inclusive. Typically, these values are at the lower end of this range. The number of times that the blur effect is applied is specified by <span class="italic">iterations</span>, which must be between 0 and 3, inclusive. A default constructor is also supported, which sets the width and height to 5.0 and the iterations to 1.</span></div>
<div class="calibre23"><span>After a <span class="bold1">BoxBlur</span> instance has been created, the width and height of the box can be changed by using <span class="bold1">setWidth( )</span> and <span class="bold1">setHeight( )</span>, shown here:</span></div>
<div class="calibre27"><span>final void setWidth(double <span class="italic">width</span>)</span></div>
<div class="calibre27"><span>final void setHeight(double <span class="italic">height</span>)</span></div>
<div class="calibre27"><span>The number of iterations can be changed by calling <span class="bold1">setIterations( )</span>:</span></div>
<div class="calibre27"><span>final void setIterations(int <span class="italic">iterations</span>)</span></div>
<div class="calibre27"><span>By using these methods, you can change the blur effect during the execution of your program.</span></div>
<div class="calibre23"><span><span class="bold1">Reflection</span> produces an effect that simulates a reflection of the node on which it is called. It is particularly useful on text, such as that contained in a label. <span class="bold1">Reflection</span> gives you significant control over how the reflection will look. For example, you can set the opacity of both the top and the bottom of the reflection. You can also set the space between the image and its reflection, and the amount reflected. These can set by the following <span class="bold1">Reflection</span> constructor:</span></div>
<div class="calibre27"><span>Reflection(double <span class="italic">offset</span>, double <span class="italic">fraction</span>, double <span class="italic">topOpacity</span>, double <span class="italic">bottomOpacity</span>)</span></div>
<div class="calibre27"><span>Here, <span class="italic">offset</span> specifies the distance between the bottom of the image and its reflection. The amount of the reflection that is shown is specified as a fraction, specified by <span class="italic">fraction</span>. It must be between 0 and 1.0. The top and bottom opacity is specified by <span class="italic">topOpacity</span> and <span class="italic">bottomOpacity</span>. Both must be between 0 and 1.0. A default constructor is also supplied, which sets the offset to 0, the amount to 0.75, the top opacity to 0.5, and the bottom opacity to 0.</span></div>
<div class="calibre23"><span>The offset, amount shown, and opacities can also be changed during program execution. For example, the opacities are set using <span class="bold1">setTopOpacity( )</span> and <span class="bold1">setBottomOpacity( )</span>, shown here:</span></div>
<div class="calibre27"><span>final void setTopOpacity(double <span class="italic">opacity</span>)</span></div>
<div class="calibre27"><span>final void setBottomOpacity(double <span class="italic">opacity</span>)</span></div>
<div class="calibre27"><span>The offset is changed by calling <span class="bold1">setTopOffset( )</span>:</span></div>
<div class="calibre27"><span>final void setTopOffset(double <span class="italic">offset</span>)</span></div>
<div class="calibre27"><span>The amount of the reflection displayed can be set by calling <span class="bold1">setFraction( )</span>:</span></div>
<div class="calibre27"><span>final void setFraction(double <span class="italic">amount</span>)</span></div>
<div class="calibre27"><span>These methods let you adjust the reflection during program execution.</span></div>
<div id="filepos1469990" class="calibre1"><span class="calibre10"><span><span class="bold1">Transforms</span></span></span></div>
<div class="calibre12"><span>Transforms are supported by the abstract <span class="bold1">Transform</span> class, which is packaged in <span class="bold1">javafx.scene.transform</span>. Four of its subclasses are <span class="bold1">Rotate</span>, <span class="bold1">Scale</span>, <span class="bold1">Shear</span>, and <span class="bold1">Translate</span>. Each does what its name suggests. (Another subclass is <span class="bold1">Affine</span>, but typically you will use one or more of the preceding transform classes.) It is possible to perform more than one transform on a node. For example, you could rotate and scale it. Transforms are supported by the <span class="bold1">Node</span> class as described next.</span></div>
<div class="calibre23"><span>One way to add a transform to a node is to add it to the list of transforms maintained by the node. This list is obtained by calling <span class="bold1">getTransforms( )</span>, which is defined by <span class="bold1">Node</span>. It is shown here:</span></div>
<div class="calibre27"><span>final ObservableList&lt;Transform&gt; getTransforms( )</span></div>
<div class="calibre27"><span>It returns a reference to the list of transforms. To add a transform, simply add it to this list by calling <span class="bold1">add( )</span>. You can clear the list by calling <span class="bold1">clear( )</span>. You can use <span class="bold1">remove( )</span> to remove a specific element.</span></div>
<div class="calibre23"><span>In some cases, you can specify a transform directly by setting one of <span class="bold1">Node</span>’s properties. For example, you can set the rotation angle of a node, with the pivot point being at the center of the node, by calling <span class="bold1">setRotate( )</span>, passing in the desired angle. You can set a scale by using <span class="bold1">setScaleX( )</span> and <span class="bold1">setScaleY( )</span>, and you can translate a node by using <span class="bold1">setTranslateX( )</span> and <span class="bold1">setTranslateY( )</span>. (<span class="italic">Z</span> axis transforms may also be supported by the platform.) However, using the transforms list offers the greatest flexibility, and that is the approach demonstrated here.</span></div>
<div class="calibre23"><span>To demonstrate the use of transforms, we will use the <span class="bold1">Rotate</span> and <span class="bold1">Scale</span> classes. (The other transforms are used in the same general way.) <span class="bold1">Rotate</span> rotates a node through a specified angle around a specified point. These values can be set when a <span class="bold1">Rotate</span> instance is created. For example, here is one <span class="bold1">Rotate</span> constructor:</span></div>
<div class="calibre27"><span>Rotate(double <span class="italic">angle</span>, double <span class="italic">x</span>, double <span class="italic">y</span>)</span></div>
<div class="calibre27"><span>In this case, <span class="italic">angle</span> specifies the number of degrees to rotate. The center of rotation, called the <span class="italic">pivot point</span>, is specified by <span class="italic">x</span> and <span class="italic">y</span>.</span></div>
<div class="calibre23"><span>It is also possible to use the default constructor and set the rotation values after a <span class="bold1">Rotate</span> object has been created, which is what the demonstration program shown in the next section will do. This is done by using the <span class="bold1">setAngle( )</span>, <span class="bold1">setPivotX( )</span>, and <span class="bold1">setPivotY( )</span> methods, shown here:</span></div>
<div class="calibre27"><span>final void setAngle(double <span class="italic">angle</span>)</span></div>
<div class="calibre27"><span>final void setPivotX(double <span class="italic">x</span>)</span></div>
<div class="calibre27"><span>final void setPivotY(double <span class="italic">y</span>)</span></div>
<div class="calibre27"><span>As before, <span class="italic">angle</span> specifies the number of degrees to rotate and the center of rotation is specified by <span class="italic">x</span> and <span class="italic">y</span>. Using these methods, you can rotate a node during program execution. This can create a very dramatic effect.</span></div>
<div class="calibre23"><span><span class="bold1">Scale</span> scales a node as specified by a scale factor. Thus, it changes a node’s size. <span class="bold1">Scale</span> defines several constructors. Here is the one that we will use:</span></div>
<div class="calibre27"><span>Scale(double <span class="italic">widthFactor</span>, double <span class="italic">heightFactor</span>)</span></div>
<div class="calibre27"><span>In this case, <span class="italic">widthFactor</span> specifies the scaling factor applied to the node’s width, and <span class="italic">heightFactor</span> specifies the scaling factor applied to the node’s height. These factors can be changed after a <span class="bold1">Scale</span> instance has been created by using <span class="bold1">setX( )</span> and <span class="bold1">setY( )</span>, shown here:</span></div>
<div class="calibre27"><span>final void setX(double <span class="italic">widthFactor</span>)</span></div>
<div class="calibre27"><span>final void setY(double <span class="italic">heightFactor</span>)</span></div>
<div class="calibre27"><span>As before, <span class="italic">widthFactor</span> specifies the scaling factor applied to the node’s width, and <span class="italic">heightFactor</span> specifies the scaling factor applied to the node’s height. You might use these methods to change the size of a control during program execution, possibly to draw attention to it.</span></div>
<div id="filepos1475170" class="calibre1"><span class="calibre10"><span><span class="bold1">Demonstrating Effects and Transforms</span></span></span></div>
<div class="calibre12"><span>The following program demonstrates the use of effects and transforms. It does so by creating three buttons and a label. The buttons are called Rotate, Scale, and Blur. Each time one of these buttons is pressed, the corresponding effect or transform is applied to the button. Specifically, each time you press Rotate, the button is rotated by 15 degrees. Each time you press Scale, the button size is changed. Each time you press Blur, the button is progressively blurred. The label illustrates the reflection effect. When you examine the program, you will see how easy it is to customize the look of your GUI. You might find it interesting to experiment with it, trying different transforms or effects, or trying the effects on different types of nodes other than buttons.</span></div>
<div class="calibre1"><span><img alt="image" src="images/01079.jpg" class="calibre993"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/01080.jpg" class="calibre994"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/01081.jpg" class="calibre982"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Sample output is shown here:</span></div>
<div class="calibre29"><span><img alt="image" src="images/01082.jpg" class="calibre995"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Before leaving the topic of effects and transforms, it is useful to mention that several of them are particularly pleasing when used on a <span class="bold1">Text</span> node. <span class="bold1">Text</span> is a class packaged in <span class="bold1">javafx.scene.text</span>. It creates a node that consists of text. Because it is a node, the text can be easily manipulated as a unit and various effects and transforms can be applied.</span></div>
<div id="filepos1477238" class="calibre1"><span class="calibre10"><span><span class="bold1">What Next?</span></span></span></div>
<div class="calibre12"><span>Congratulations! If you have read and worked through the preceding 17 chapters, then you can call yourself a Java programmer. Of course, there are still many, many things to learn about Java, its libraries, and its subsystems, but you now have a solid foundation upon which you can build your knowledge and expertise.</span></div>
<div class="calibre23"><span>Here are a few of the topics that you will want to learn more about:</span></div>
<div class="calibre24"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   JavaFX and Swing—both are an important part of today’s Java programming environment.</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Event handling.</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Java’s networking classes.</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Java’s utility classes, especially its Collections Framework, which simplifies a number of common programming tasks.</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   The Concurrent API, which offers detailed control over high-performance multithreaded applications.</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Java Beans, which supports the creation of software components in Java.</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Native methods.</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Servlets. If you will be writing high-powered web applications, then you will want to learn about servlets. Servlets are to the server what applets are to the browser.</span></div>
<div class="calibre592"><span>To continue your study of Java, I recommend my book <span class="italic">Java: The Complete Reference, Ninth Edition</span> (Oracle Press/McGraw-Hill Professional, 2014). In it, you will find comprehensive coverage of the Java language, its key libraries, and many more example programs.</span></div>
<div id="filepos1480164" class="calibre44"><span class="calibre10"><span><img alt="image" src="images/00059.jpg" class="calibre104"/>   <span class="bold1"><span class="italic">Chapter 17 Self Test</span></span></span></span></div><div class="calibre11"> </div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1480445" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1599193">1</a>.</span>  What is the top-level package name of the JavaFX framework?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1480673" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1599531">2</a>.</span>  Two concepts central to JavaFX are a stage and a scene. What classes encapsulate them?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1480928" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1599912">3</a>.</span>  A scene graph is composed of ________.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1481135" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1600221">4</a>.</span>  The base class for all nodes is ________.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1481345" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1600539">5</a>.</span>  What class will all JavaFX applications extend?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1481561" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1600870">6</a>.</span>  What are the three JavaFX life-cycle methods?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1481775" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1601232">7</a>.</span>  In what life-cycle method can you construct an application’s stage?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1482018" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1601587">8</a>.</span>  The <span class="bold1">launch( )</span> method is called to start a free-standing JavaFX application. True or False?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1482284" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1601954">9</a>.</span>  What are the names of the JavaFX classes that support a label and a button?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1482512" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1602309">10</a>.</span>  One way to terminate a free-standing JavaFX application is to call <span class="bold1">Platform.exit( )</span>. <span class="bold1">Platform</span> is packaged in <span class="bold1">javafx.Application</span>. When called, <span class="bold1">exit( )</span> immediately terminates the program. With this in mind, change the <span class="bold1">JavaFXEventDemo</span> program shown in this chapter so that it has two buttons called Run and Exit. If Run is pressed, have the program display that choice in a label. If Exit is pressed, have the application terminate. Use lambda expressions for the event handlers.</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1483178" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1603290">11</a>.</span>  What <span class="bold1">JavaFX</span> control implements a check box?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1483383" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1603607">12</a>.   ListView</span> is a control that displays a directory list of files on the local file system. True or False?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1483648" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1604041">13</a>.</span>  Convert the Swing-based file comparison program in <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_023.html#filepos1372428">Try This 16-1</a> so it uses JavaFX instead. In the process, make use of another of JavaFX’s features: its ability to fire an action event on a button under program control. This is done by calling <span class="bold1">fire( )</span> on the button instance. For example, assuming a <span class="bold1">Button</span> called <span class="bold1">myButtton</span>, the following will fire an action event on it: <span class="bold1">myButton.fire( )</span>. Use this fact when implementing the event handlers for the text fields that hold the names of the files to compare. If the user presses <small class="calibre16">ENTER</small> when in either of these fields, simply fire an action event on the Compare button. The event-handling code for the Compare button will then handle the file comparison.</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos1484580" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1605446">14</a>.</span>  Modify the <span class="bold1">EffectsAndTransformsDemo</span> program so the Rotate button is also blurred. Use a blur width and height of 5 and an iteration count of 2.</span></div>
<div class="calibre47"><span><span class="bold1">15.</span>  On your own, experiment with other effects and transforms. For example, try the <span class="bold1">Glow</span> effect and the <span class="bold1">Translate</span> transform.</span></div>
<div class="calibre47"><span><span class="bold1">16.</span>  Continue to advance in your knowledge of Java. A good way to start is by examining Java’s core packages, such as <span class="bold1">java.lang</span>, <span class="bold1">java.util</span>, and <span class="bold1">java.net</span>. Write sample programs that demonstrate their various classes and interfaces. In general, the best way to become a great Java programmer is to write lots of code.</span></div>  <div class="mbppagebreak" id="calibre_pb_24"></div>
</body></html>
