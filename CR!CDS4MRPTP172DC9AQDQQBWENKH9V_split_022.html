<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Java&amp;#8482;: A Beginner&amp;#8217;s Guide Sixth Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="filepos1225806" class="calibre29"><span><img alt="image" src="images/00003.jpg" class="calibre30"/></span></div><div class="calibre11"> </div>
<div class="calibre31"><span class="calibre2"><span><big class="calibre3"><big class="calibre4"><big class="calibre5"><big class="calibre6"><big class="calibre32"><big class="calibre4">Chapter 15</big></big></big></big></big></big></span></span></div>
<div class="calibre9"><span class="calibre2"><span>Applets, Events, and Miscellaneous Topics</span></span></div><div class="calibre33"> </div>
<div class="calibre1"><span class="calibre10"><span><span class="bold1">Key Skills &amp; Concepts</span></span></span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Understand applet basics</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Know the applet architecture</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Create an applet skeleton</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Initialize and terminate applets</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Repaint applets</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Output to the status window</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Pass parameters to an applet</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Know the <span class="bold1">Applet</span> class</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Understand the delegation event model</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Use the delegation event model</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Know the remaining Java keywords</span></div>
<div class="calibre1"><span><img alt="image" src="images/00004.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre12"><span><span class="bold1"><span><span class="calibre2">T</span></span></span>eaching the elements of the Java language is the primary goal of this book, and in this regard, we are nearly finished. The preceding 14 chapters have focused on the features of Java defined by the language, such as its keywords, syntax, block structure, type conversion rules, and so on. At this point, you have enough knowledge to write sophisticated, useful Java programs. However, there are two fundamental parts of Java programming that are not defined by keywords, but by API classes and specialized techniques. These are applets and events.</span></div>
<div class="calibre23"><span>Be forewarned: The topics of applets and event handling are very large. Full and detailed coverage of either is well beyond the scope of this book. Here, you will learn their fundamentals and see several examples, but we will only scratch the surface. After finishing this chapter, however, you will have a foundation upon which to build your knowledge.</span></div>
<div class="calibre23"><span>This chapter ends with a description of the remaining Java keywords, such as <span class="bold1">instanceof</span> and <span class="bold1">native</span>, that have not been described elsewhere in this book. These keywords are used for more advanced programming, but they are summarized here for completeness.</span></div>
<div id="filepos1230061" class="calibre1"><span class="calibre10"><span><span class="bold1">Applet Basics</span></span></span></div>
<div class="calibre12"><span>Applets differ from the type of programs shown in the preceding chapters. As mentioned in <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_008.html#filepos130552">Chapter 1</a>, applets are small programs that are designed for transmission over the Internet and run within a browser. Because Java’s virtual machine is in charge of executing all Java programs, including applets, applets offer a reasonably secure way to dynamically download and execute programs over the Web.</span></div>
<div class="calibre23"><span>Before we begin, it is necessary to explain two general varieties of applets: those based on the Abstract Window Toolkit (AWT) and those based on Swing. Both the AWT and Swing support the creation of a graphical user interface (GUI). The AWT is the original GUI toolkit and Swing is a lightweight alternative. This chapter describes AWT-based applets. (Swing is introduced in <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_023.html#filepos1300493">Chapter 16</a>.) It is important to understand, however, that Swing-based applets are built upon the same basic architecture as AWT-based applets. Furthermore, Swing is built on top of the AWT. Therefore, the information and techniques presented here describe the foundation of applet programming and most of it applies to both types of applets.</span></div>
<div class="calibre23"><span>Prior to discussing any theory or details, let’s begin by examining a simple applet. It performs one function: It displays the string "Java makes applets easy." inside a window.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00948.jpg" class="calibre899"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>This applet begins with two <span class="bold1">import</span> statements. The first imports the Abstract Window Toolkit classes. AWT-based applets interact with the user through the AWT, not through the console-based I/O classes. The AWT contains support for a limited window-based, graphical user interface. As you might expect, it is quite large and sophisticated. A complete discussion of it would require a book of its own. Fortunately, since we will be creating only very simple applets, we will make only limited use of the AWT. The next <span class="bold1">import</span> statement imports the <span class="bold1">applet</span> package. This package contains the class <span class="bold1">Applet</span>. Every AWT-based applet that you create must be a subclass of <span class="bold1">Applet</span>.</span></div>
<div class="calibre23"><span>The next line in the program declares the class <span class="bold1">SimpleApplet</span>. This class must be declared as <span class="bold1">public</span> because it will be accessed by outside code.</span></div>
<div class="calibre23"><span>Inside <span class="bold1">SimpleApplet</span>, <span class="bold1">paint( )</span> is declared. This method is defined by the AWT <span class="bold1">Component</span> class (which is a superclass of <span class="bold1">Applet</span>) and is overridden by the applet. <span class="bold1">paint( )</span> is called each time the applet must redisplay its output. This can occur for several reasons. For example, the window in which the applet is running can be overwritten by another window and then uncovered. Or the applet window can be minimized and then restored. <span class="bold1">paint( )</span> is also called when the applet begins execution. Whatever the cause, whenever the applet must redraw its output, <span class="bold1">paint( )</span> is called. The <span class="bold1">paint( )</span> method has one parameter of type <span class="bold1">Graphics</span>. This parameter will contain the graphics context, which describes the graphics environment in which the applet is running. This context is used whenever output to the applet is required.</span></div>
<div class="calibre23"><span>Inside <span class="bold1">paint( )</span>, there is a call to <span class="bold1">drawString( )</span>, which is a member of the <span class="bold1">Graphics</span> class. This method outputs a string beginning at the specified X,Y location. It has the following general form:</span></div>
<div class="calibre27"><span>void drawString(String <span class="italic">message</span>, int <span class="italic">x</span>, int <span class="italic">y</span>)</span></div>
<div class="calibre27"><span>Here, <span class="italic">message</span> is the string to be output beginning at <span class="italic">x</span>,<span class="italic">y</span>. In a Java window, the upper-left corner is location 0,0. The call to <span class="bold1">drawString( )</span> in the applet causes the message to be displayed beginning at location 20,20.</span></div>
<div class="calibre23"><span>Notice that the applet does not have a <span class="bold1">main( )</span> method. Unlike the programs shown earlier in this book, applets do not begin execution at <span class="bold1">main( )</span>. In fact, most applets don’t even have a <span class="bold1">main( )</span> method. Instead, an applet begins execution when the name of its class is passed to a browser or other applet-enabled program.</span></div>
<div class="calibre23"><span>After you have entered the source code for <span class="bold1">SimpleApplet</span>, you compile in the same way that you have been compiling programs. However, running <span class="bold1">SimpleApplet</span> involves a different process. There are two ways in which you can run an applet: inside a browser or with a special development tool that displays applets. The tool provided with the standard Java JDK is called <span class="bold1">appletviewer</span>, and we will use it to run the applets developed in this chapter. Of course, you can also run them in your browser, but the <span class="bold1">appletviewer</span> is much easier to use during development.</span></div>
<div class="calibre44"><span class="calibre10"><span><span class="bold1"><span class="italic">NOTE</span></span></span></span></div>
<div class="calibre9"><span><img alt="image" src="images/00006.jpg" class="calibre45"/></span></div>
<div class="calibre9"><span>Beginning with the release of Java 7, update 21, Java applets must be signed to prevent security warnings when run in a browser. In fact, in some cases, the applet may be prevented from running. Applets stored in the local file system, such as you would create when compiling the examples in this book, are especially sensitive to this change. You may need to adjust the security settings in the Java Control Panel to run a local applet in a browser. At the time of this writing, Oracle recommends against the use of local applets, recommending instead that applets be executed through a web server. Furthermore, unsigned local applets may be (probably will be) blocked from execution in the future. In general, for applets that will be distributed via the Internet, such as commercial applications, signing is a virtual necessity. The concepts and techniques required to sign applets (and other types of Java programs) are beyond the scope of this book. However, extensive information is found on Oracle’s website. Finally, as mentioned, the easiest way to try the applet examples is to use <span class="bold1">appletviewer</span>.</span></div><div class="calibre11"> </div>
<div class="calibre23"><span>One way to execute an applet (in either a Web browser or the <span class="bold1">appletviewer</span>) is to write a short HTML text file that contains a tag that loads the applet. At the time of this writing, Oracle recommends using the APPLET tag for this purpose. (The OBJECT tag can also be used, and other deployment strategies are available. Consult the Java documentation for the latest information.) Using the APPLET tag, here is the HTML file that will execute <span class="bold1">SimpleApplet</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00949.jpg" class="calibre900"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The <span class="bold1">width</span> and <span class="bold1">height</span> statements specify the dimensions of the display area used by the applet.</span></div>
<div class="calibre23"><span>To execute <span class="bold1">SimpleApplet</span> with an applet viewer, you will execute this HTML file. For example, if the preceding HTML file is called <span class="bold1">StartApp.html</span>, then the following command line will run <span class="bold1">SimpleApplet</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00950.jpg" class="calibre901"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Although there is nothing wrong with using a stand-alone HTML file to execute an applet, there is an easier way. Simply include a comment near the top of your applet’s source code file that contains the APPLET tag. If you use this method, the <span class="bold1">SimpleApplet</span> source file looks like this:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00951.jpg" class="calibre409"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Now you can execute the applet by passing the name of its source file to <span class="bold1">appletviewer</span>. For example, this command line will now display <span class="bold1">SimpleApplet</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00952.jpg" class="calibre902"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>The window produced by <span class="bold1">SimpleApplet</span>, as displayed by <span class="bold1">appletviewer</span>, is shown in the following illustration:</span></div>
<div class="calibre29"><span><img alt="image" src="images/00953.jpg" class="calibre903"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>When using <span class="bold1">appletviewer</span>, keep in mind that it provides the window frame. Applets run in a browser will not have a visible frame.</span></div>
<div class="calibre23"><span>Let’s review an applet’s key points:</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   All AWT-based applets are subclasses of <span class="bold1">Applet</span>.</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Applets do not need a <span class="bold1">main( )</span> method.</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Applets must be run under an applet viewer or a Java-compatible browser.</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   User I/O is not accomplished with Java’s stream I/O classes. Instead, applets use the interface provided by a GUI framework.</span></div>
<div id="filepos1240892" class="calibre1"><span class="calibre10"><span><span class="bold1">Applet Organization and Essential Elements</span></span></span></div>
<div class="calibre12"><span>Although the preceding applet is completely valid, such a simple applet is of little value. Before you can create useful applets, you need to know more about how applets are organized, what methods they use, and how they interact with the run-time system.</span></div>
<div id="filepos1241355" class="calibre1"><span class="calibre10"><span><span class="bold1">The Applet Architecture</span></span></span></div>
<div class="calibre12"><span>As a general rule, an applet is a GUI-based program. As such, its architecture is different from the console-based programs shown in the first part of this book. If you are familiar with GUI programming, you will be right at home writing applets. If not, then there are a few key concepts you must understand.</span></div>
<div class="calibre23"><span>First, applets are event driven, and an applet resembles a set of interrupt service routines. Here is how the process works. An applet waits until an event occurs. The run-time system notifies the applet about an event by calling an event handler that has been provided by the applet. Once this happens, the applet must take appropriate action and then quickly return control to the system. This is a crucial point. For the most part, your applet should not enter a “mode” of operation in which it maintains control for an extended period. Instead, it must perform specific actions in response to events and then return control to the run-time system. In those situations in which your applet needs to perform a repetitive task on its own (for example, displaying a scrolling message across its window), you must start an additional thread of execution.</span></div>
<div class="calibre23"><span>Second, it is the user who initiates interaction with an applet—not the other way around. In a console-based program, when the program needs input, it will prompt the user and then call some input method. This is not the way it works in an applet. Instead, the user interacts with the applet as he or she wants, when he or she wants. These interactions are sent to the applet as events to which the applet must respond. For example, when the user clicks a mouse inside the applet’s window, a mouse-clicked event is generated. If the user presses a key while the applet’s window has input focus, a keypress event is generated. Applets can contain various controls, such as push buttons and check boxes. When the user interacts with one of these controls, an event is generated.</span></div>
<div class="calibre23"><span>While the architecture of an applet is not as easy to understand as that of a console-based program, Java makes it as simple as possible. If you have written programs for Windows (or another GUI-based operating system), you know how intimidating that environment can be. Fortunately, Java provides a much cleaner approach that is more quickly mastered.</span></div>
<div id="filepos1244091" class="calibre1"><span class="calibre10"><span><span class="bold1">A Complete Applet Skeleton</span></span></span></div>
<div class="calibre12"><span>Although <span class="bold1">SimpleApplet</span> shown earlier is a real applet, it does not contain all of the elements required by most applets. Actually, all but the most trivial applets override a set of methods that provide the basic mechanism by which the browser or applet viewer interfaces to the applet and controls its execution. These life-cycle methods are <span class="bold1">init( )</span>, <span class="bold1">start( )</span>, <span class="bold1">stop( )</span>, and <span class="bold1">destroy( )</span>, and they are defined by <span class="bold1">Applet</span>. A fifth method, <span class="bold1">paint( )</span>, is commonly overridden by AWT-based applets even though it is not a life-cycle method. It is inherited from the AWT <span class="bold1">Component</span> class. Since default implementations for all of these methods are provided, applets do not need to override those methods they do not use. These four life-cycle methods plus <span class="bold1">paint( )</span> can be assembled into the skeleton shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00954.jpg" class="calibre904"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Although this skeleton does not do anything, it can be compiled and run. Thus, it can be used as a starting point for applets that you create.</span></div>
<div class="calibre44"><span class="calibre10"><span><span class="bold1"><span class="italic">NOTE</span></span></span></span></div>
<div class="calibre9"><span><img alt="image" src="images/00006.jpg" class="calibre45"/></span></div>
<div class="calibre9"><span>Overriding <span class="bold1">paint( )</span> applies mostly to AWT-based applets. Swing applets use a different painting mechanism.</span></div><div class="calibre11"> </div>
<div id="filepos1245932" class="calibre1"><span class="calibre10"><span><span class="bold1">Applet Initialization and Termination</span></span></span></div>
<div class="calibre12"><span>It is important to understand the order in which the various methods shown in the skeleton are executed. When an applet begins, the following methods are called in this sequence:</span></div>
<div class="calibre19"><span>  <span class="bold1">1.  init( )</span></span></div>
<div class="calibre47"><span>  <span class="bold1">2.  start( )</span></span></div>
<div class="calibre47"><span>  <span class="bold1">3.  paint( )</span></span></div>
<div class="calibre27"><span>When an applet is terminated, the following sequence of method calls takes place:</span></div>
<div class="calibre19"><span>  <span class="bold1">1.  stop( )</span></span></div>
<div class="calibre47"><span>  <span class="bold1">2.  destroy( )</span></span></div>
<div class="calibre27"><span>Let’s look more closely at these methods.</span></div>
<div class="calibre23"><span>The <span class="bold1">init( )</span> method is the first method to be called. In <span class="bold1">init( )</span> your applet will initialize variables and perform any other startup activities.</span></div>
<div class="calibre23"><span>The <span class="bold1">start( )</span> method is called after <span class="bold1">init( )</span>. It is also called to restart an applet after it has been stopped, such as when the user returns to a previously displayed web page that contains an applet. Thus, <span class="bold1">start( )</span> might be called more than once during the life cycle of an applet.</span></div>
<div class="calibre23"><span>The <span class="bold1">paint( )</span> method is called each time an AWT-based applet’s output must be redrawn and was described earlier.</span></div>
<div class="calibre23"><span>When the page containing your applet is left, the <span class="bold1">stop( )</span> method is called. You will use <span class="bold1">stop( )</span> to suspend any child threads created by the applet and to perform any other activities required to put the applet in a safe, idle state. Remember, a call to <span class="bold1">stop( )</span> does not mean that the applet should be terminated because it might be restarted with a call to <span class="bold1">start( )</span> if the user returns to the page.</span></div>
<div class="calibre23"><span>The <span class="bold1">destroy( )</span> method is called when the applet is no longer needed. It is used to perform any shutdown operations required of the applet.</span></div>
<div id="filepos1248772" class="calibre1"><span class="calibre10"><span><span class="bold1">Requesting Repainting</span></span></span></div>
<div class="calibre12"><span>As a general rule, an AWT-based applet writes to its window only when its <span class="bold1">paint( )</span> method is called by the run-time system. This raises an interesting question: How can the applet itself cause its window to be updated when its information changes? For example, if an applet is displaying a moving banner, what mechanism does the applet use to update the window each time this banner scrolls? Remember that one of the fundamental architectural constraints imposed on an applet is that it must quickly return control to the Java run-time system. It cannot create a loop inside <span class="bold1">paint( )</span> that repeatedly scrolls the banner, for example. This would prevent control from passing back to the run-time system. Given this constraint, it may seem that output to your applet’s window will be difficult at best. Fortunately, this is not the case. Whenever your applet needs to update the information displayed in its window, it simply calls <span class="bold1">repaint( )</span>.</span></div>
<div class="calibre23"><span>The <span class="bold1">repaint( )</span> method is defined by the AWT’s <span class="bold1">Component</span> class. It causes the run-time system to execute a call to your applet’s <span class="bold1">paint( )</span> method. Thus, for another part of your applet to output to its window, simply store the output and then call <span class="bold1">repaint( )</span>. This causes a call to <span class="bold1">paint( )</span>, which can display the stored information. For example, if part of your applet needs to output a string, it can store this string in a <span class="bold1">String</span> variable and then call <span class="bold1">repaint( )</span>. Inside <span class="bold1">paint( )</span>, you will output the string using <span class="bold1">drawString( )</span>.</span></div>
<div class="calibre23"><span>The simplest version of <span class="bold1">repaint( )</span> is shown here:</span></div>
<div class="calibre27"><span>void repaint( )</span></div>
<div class="calibre27"><span>This version causes the entire window to be repainted.</span></div>
<div class="calibre23"><span>Another version of <span class="bold1">repaint( )</span> specifies a region that will be repainted:</span></div>
<div class="calibre27"><span>void repaint(int <span class="italic">left</span>, int <span class="italic">top</span>, int <span class="italic">width</span>, int <span class="italic">height</span>)</span></div>
<div class="calibre35"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   Is it possible for a method other than</span> paint( ) <span class="bold1">or</span> update( ) <span class="bold1">to output to an applet’s window?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   Yes. To do so, you must obtain a graphics context by calling <span class="bold1">getGraphics( )</span> (defined by <span class="bold1">Component</span>) and then use this context to output to the window. However, for most AWT-based applications, it is better and easier to route window output through <span class="bold1">paint( )</span> and to call <span class="bold1">repaint( )</span> when the contents of the window change.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre12"><span>Here, the coordinates of the upper-left corner of the region are specified by <span class="italic">left</span> and <span class="italic">top</span>, and the width and height of the region are passed in <span class="italic">width</span> and <span class="italic">height</span>. These dimensions are specified in pixels. You save time by specifying a region to repaint because window updates are costly in terms of time. If you only need to update a small portion of the window, it is more efficient to repaint only that region.</span></div>
<div class="calibre23"><span>An example that demonstrates <span class="bold1">repaint( )</span> is found in <a href="#filepos1253965">Try This 15-1</a>.</span></div>
<div id="filepos1253045" class="calibre1"><span class="calibre10"><span><span class="bold1">The update( ) Method</span></span></span></div>
<div class="calibre12"><span>There is another method that relates to repainting called <span class="bold1">update( )</span> that your applet may want to override. This method is defined by the <span class="bold1">Component</span> class, and it is called when your applet has requested that a portion of its window be redrawn. The default version of <span class="bold1">update( )</span> simply calls <span class="bold1">paint( )</span>. However, you can override the <span class="bold1">update( )</span> method so that it performs more subtle repainting, but this is an advanced technique that is beyond the scope of this book. Also, overriding <span class="bold1">update( )</span> applies only to AWT-based applets.</span></div>
<div class="calibre18"> </div><table cellspacing="0" cellpadding="0" class="calibre37">
<colgroup class="calibre38">
<col class="calibre72"/>
<col class="calibre73"/>
</colgroup>
<tr class="calibre41">
<td valign="top" id="filepos1253965" class="calibre74"><span class="calibre10"><span class="bold1">Try This 15-1</span> </span></td>
<td valign="top" class="calibre75"><span class="calibre10">A Simple Banner Applet</span></td>
</tr></table><div class="calibre43"> </div>
<div class="calibre1"><span><img alt="image" src="images/00955.jpg" class="calibre421"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>To demonstrate <span class="bold1">repaint( )</span>, a simple banner applet is presented. This applet scrolls a message, from right to left, across the applet’s window. Since the scrolling of the message is a repetitive task, it is performed by a separate thread, created by the applet when it is initialized. Banners are popular Web features, and this project shows how to use a Java applet to create one.</span></div>
<div class="calibre19"><span>  <span class="bold1">1.</span>  Create a file called <span class="bold1">Banner.java</span>.</span></div>
<div class="calibre47"><span>  <span class="bold1">2.</span>  Begin creating the banner applet with the following lines:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00956.jpg" class="calibre905"/></span></div>
<div class="calibre47"><span>        Notice that <span class="bold1">Banner</span> extends <span class="bold1">Applet</span>, as expected, but it also implements <span class="bold1">Runnable</span>. This is necessary since the applet will be creating a second thread of execution that will be used to scroll the banner. The message that will be scrolled in the banner is contained in the <span class="bold1">String</span> variable <span class="bold1">msg</span>. A reference to the thread that runs the applet is stored in <span class="bold1">t</span>. The Boolean variable <span class="bold1">stopFlag</span> is used to stop the applet. Inside <span class="bold1">init( )</span>, the thread reference variable <span class="bold1">t</span> is set to <span class="bold1">null</span>.</span></div>
<div class="calibre47"><span>  <span class="bold1">3.</span>  Add the <span class="bold1">start( )</span> method shown next:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00957.jpg" class="calibre906"/></span></div>
<div class="calibre47"><span>        The run-time system calls <span class="bold1">start( )</span> to start the applet running. Inside <span class="bold1">start( )</span>, a new thread of execution is created and assigned to the <span class="bold1">Thread</span> variable <span class="bold1">t</span>. Then, <span class="bold1">stopFlag</span> is set to <span class="bold1">false</span>. Next, the thread is started by a call to <span class="bold1">t.start( )</span>. Remember that <span class="bold1">t.start( )</span> calls a method defined by <span class="bold1">Thread</span>, which causes <span class="bold1">run( )</span> to begin executing. It does not cause a call to the version of <span class="bold1">start( )</span> defined by <span class="bold1">Applet</span>. These are two separate methods.</span></div>
<div class="calibre47"><span>  <span class="bold1">4.</span>  Add the <span class="bold1">run( )</span> method, as shown here:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00958.jpg" class="calibre907"/></span></div>
<div class="calibre47"><span>        In <span class="bold1">run( )</span>, a call to <span class="bold1">repaint( )</span> is made. This eventually causes the <span class="bold1">paint( )</span> method to be called, and the rotated contents of <span class="bold1">msg</span> are displayed. Between each iteration, <span class="bold1">run( )</span> sleeps for a quarter of a second. The net effect of <span class="bold1">run( )</span> is that the contents of <span class="bold1">msg</span> are scrolled right to left in a constantly moving display. The <span class="bold1">stopFlag</span> variable is checked on each iteration. When it is <span class="bold1">true</span>, the <span class="bold1">run( )</span> method terminates.</span></div>
<div class="calibre47"><span>  <span class="bold1">5.</span>  Add the code for <span class="bold1">stop( )</span> and <span class="bold1">paint( )</span>, as shown here:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00959.jpg" class="calibre908"/></span></div>
<div class="calibre47"><span>        If a browser is displaying the applet when a new page is viewed, the <span class="bold1">stop( )</span> method is called, which sets <span class="bold1">stopFlag</span> to <span class="bold1">true</span>, causing <span class="bold1">run( )</span> to terminate. It also sets <span class="bold1">t</span> to <span class="bold1">null</span>. Thus, there is no longer a reference to the <span class="bold1">Thread</span> object, and it can be recycled the next time the garbage collector runs. This is the mechanism used to stop the thread when its page is no longer in view. When the applet is brought back into view, <span class="bold1">start( )</span> is once again called, which starts a new thread to execute the banner. Inside <span class="bold1">paint( )</span>, the message is rotated and then displayed.</span></div>
<div class="calibre47"><span>  <span class="bold1">6.</span>  The entire banner applet is shown here:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00960.jpg" class="calibre909"/></span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00961.jpg" class="calibre910"/></span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00962.jpg" class="calibre911"/></span></div>
<div class="calibre47"><span>        Sample output is shown here:</span></div>
<div class="calibre29"><span><img alt="image" src="images/00963.jpg" class="calibre912"/></span></div><div class="calibre11"> </div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos1260593" class="calibre9"><span class="calibre10"><span><span class="bold1">Using the Status Window</span></span></span></div>
<div class="calibre12"><span>In addition to displaying information in its window, an applet can also output a message to the status window of the browser or applet viewer on which it is running. To do so, call <span class="bold1">showStatus( )</span>, which is defined by <span class="bold1">Applet</span>, with the string that you want displayed. The general form of <span class="bold1">showStatus( )</span> is shown here:</span></div>
<div class="calibre27"><span>void showStatus(String <span class="italic">msg</span>)</span></div>
<div class="calibre27"><span>Here, <span class="italic">msg</span> is the string to be displayed.</span></div>
<div class="calibre23"><span>The status window is a good place to give the user feedback about what is occurring in the applet, suggest options, or possibly report some types of errors. The status window also makes an excellent debugging aid, because it gives you an easy way to output information about your applet.</span></div>
<div class="calibre23"><span>The following applet demonstrates <span class="bold1">showStatus( )</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00964.jpg" class="calibre609"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Sample output from this program is shown here:</span></div>
<div class="calibre29"><span><img alt="image" src="images/00965.jpg" class="calibre913"/></span></div><div class="calibre11"> </div>
<div id="filepos1262203" class="calibre1"><span class="calibre10"><span><span class="bold1">Passing Parameters to Applets</span></span></span></div>
<div class="calibre12"><span>You can pass parameters to your applet. To do so, use the PARAM attribute of the APPLET tag, specifying the parameter’s name and value. To retrieve a parameter, use the <span class="bold1">getParameter( )</span> method, defined by <span class="bold1">Applet</span>. Its general form is shown here:</span></div>
<div class="calibre27"><span>String getParameter(String <span class="italic">paramName</span>)</span></div>
<div class="calibre27"><span>Here, <span class="italic">paramName</span> is the name of the parameter. It returns the value of the specified parameter in the form of a <span class="bold1">String</span> object. Thus, for numeric and <span class="bold1">boolean</span> values, you will need to convert their string representations into their internal formats. If the specified parameter cannot be found, <span class="bold1">null</span> is returned. Therefore, be sure to confirm that the value returned by <span class="bold1">getParameter( )</span> is valid. Also, check any parameter that is converted into a numeric value, confirming that a valid conversion took place.</span></div>
<div class="calibre23"><span>Here is an example that demonstrates passing parameters:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00966.jpg" class="calibre914"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Sample output from this program is shown here:</span></div>
<div class="calibre29"><span><img alt="image" src="images/00967.jpg" class="calibre915"/></span></div><div class="calibre11"> </div>
<div id="filepos1263891" class="calibre1"><span class="calibre10"><span><span class="bold1">The Applet Class</span></span></span></div>
<div class="calibre12"><span>As mentioned, all AWT-based applets are subclasses of the <span class="bold1">Applet</span> class. <span class="bold1">Applet</span> inherits the following superclasses defined by the AWT: <span class="bold1">Component</span>, <span class="bold1">Container</span>, and <span class="bold1">Panel</span>. Thus, an applet has access to the full functionality of the AWT.</span></div>
<div class="calibre23"><span>In addition to the methods described in the preceding sections, <span class="bold1">Applet</span> contains several others that give you detailed control over the execution of your applet. All of the methods defined by <span class="bold1">Applet</span> are shown in <a href="#filepos1264683">Table 15-1</a>.</span></div>
<div class="calibre28">
<div id="filepos1264683" class="calibre44"><span><img alt="image" src="images/00968.jpg" class="calibre916"/></span></div>
<div class="calibre9"><span><img alt="image" src="images/00969.jpg" class="calibre917"/></span></div><div class="calibre11"> </div>
<div class="calibre9"><span><img alt="image" src="images/00057.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span><span class="bold1">Table 15-1</span>   The Methods Defined by <span class="bold1">Applet</span></span></div><div class="calibre18"> </div>
</div>
<div id="filepos1265235" class="calibre9"><span class="calibre10"><span><span class="bold1">Event Handling</span></span></span></div>
<div class="calibre12"><span>In Java, GUI programs, such as applets, are event driven. Thus, event handling is at the core of successful GUI programming. Most events to which your program will respond are generated by the user. These events are passed to your program in a variety of ways, with the specific method depending upon the actual event. There are several types of events, including those generated by the mouse, the keyboard, and various controls, such as a push button. AWT-based events are supported by the <span class="bold1">java.awt.event</span> package.</span></div>
<div class="calibre23"><span>Before we start, it must be mentioned that it is not possible to fully discuss Java’s event handling mechanism. Event handling is a large topic with many special features and attributes, and a complete discussion is well beyond the scope of this book. However, the overview presented here will help you get started.</span></div>
<div id="filepos1266332" class="calibre1"><span class="calibre10"><span><span class="bold1">The Delegation Event Model</span></span></span></div>
<div class="calibre12"><span>The modern approach to handling events is based on the <span class="italic">delegation event model</span>. The delegation event model defines standard and consistent mechanisms to generate and process events. Its concept is quite simple: a <span class="italic">source</span> generates an event and sends it to one or more <span class="italic">listeners</span>. In this scheme, the listener simply waits until it receives an event. Once received, the listener processes the event and then returns. The advantage of this design is that the logic that processes events is cleanly separated from the user interface logic that generates those events. A user interface element is able to “delegate” the processing of an event to a separate piece of code. In the delegation event model, listeners must register with a source in order to receive an event notification.</span></div>
<div id="filepos1267335" class="calibre1"><span class="calibre10"><span><span class="bold1">Events</span></span></span></div>
<div class="calibre12"><span>In the delegation model, an event is an object that describes a state change in a source. Among other reasons, an event can be generated as a consequence of a person interacting with the elements in a graphical user interface, such as pressing a button, entering a character via the keyboard, selecting an item in a list, and clicking the mouse.</span></div>
<div id="filepos1267852" class="calibre1"><span class="calibre10"><span><span class="bold1">Event Sources</span></span></span></div>
<div class="calibre12"><span>An event source is an object that generates an event. A source must register listeners in order for the listener to receive notifications about a specific type of event. Each type of event has its own registration method. Here is the general form:</span></div>
<div class="calibre27"><span>public void add<span class="italic">Type</span>Listener(<span class="italic">Type</span>Listener <span class="italic">el</span>)</span></div>
<div class="calibre27"><span>Here, <span class="italic">Type</span> is the name of the event, and <span class="italic">el</span> is a reference to the event listener. For example, the method that registers a keyboard event listener is called <span class="bold1">addKeyListener( )</span>. The method that registers a mouse motion listener is called <span class="bold1">addMouseMotionListener( )</span>. When an event occurs, all registered listeners are notified and receive a copy of the event object.</span></div>
<div class="calibre23"><span>A source must also provide a method that allows a listener to unregister an interest in a specific type of event. The general form of such a method is this:</span></div>
<div class="calibre27"><span>public void remove<span class="italic">Type</span>Listener(<span class="italic">Type</span>Listener <span class="italic">el</span>)</span></div>
<div class="calibre27"><span>Here, <span class="italic">Type</span> is the name of the event, and <span class="italic">el</span> is a reference to the event listener. For example, to remove a keyboard listener, you would call <span class="bold1">removeKeyListener( )</span>.</span></div>
<div class="calibre23"><span>The methods that add or remove listeners are provided by the source that generates events. For example, the <span class="bold1">Component</span> class provides methods to add and remove keyboard and mouse event listeners.</span></div>
<div id="filepos1269738" class="calibre1"><span class="calibre10"><span><span class="bold1">Event Listeners</span></span></span></div>
<div class="calibre12"><span>A <span class="italic">listener</span> is an object that is notified when an event occurs. It has two major requirements. First, it must have been registered with one or more sources to receive notifications about specific types of events. Second, it must implement methods to receive and process these notifications.</span></div>
<div class="calibre23"><span>The methods that receive and process AWT events are defined in a set of interfaces, such as those found in <span class="bold1">java.awt.event</span>. For example, the <span class="bold1">MouseMotionListener</span> interface defines methods that receive notifications when the mouse is dragged or moved. Any object may receive and process one or both of these events if it provides an implementation of this interface.</span></div>
<div id="filepos1270667" class="calibre1"><span class="calibre10"><span><span class="bold1">Event Classes</span></span></span></div>
<div class="calibre12"><span>The classes that represent events are at the core of Java’s event handling mechanism. At the root of the Java event class hierarchy is <span class="bold1">EventObject</span>, which is in <span class="bold1">java.util</span>. It is the superclass for all events. The class <span class="bold1">AWTEvent</span>, defined within the <span class="bold1">java.awt</span> package, is a subclass of <span class="bold1">EventObject</span>. It is the superclass (either directly or indirectly) for all AWT-based events used by the delegation event model.</span></div>
<div class="calibre23"><span>The package <span class="bold1">java.awt.event</span> defines several types of events that are generated by various user interface elements. <a href="#filepos1271634">Table 15-2</a> enumerates several commonly used ones and provides a brief description of when they are generated.</span></div>
<div class="calibre28">
<div id="filepos1271634" class="calibre44"><span><img alt="image" src="images/00970.jpg" class="calibre918"/></span></div>
<div class="calibre9"><span><img alt="image" src="images/00057.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span><span class="bold1">Table 15-2</span>   Commonly Used Event Classes in <span class="bold1">java.awt.event</span></span></div><div class="calibre18"> </div>
</div>
<div id="filepos1272067" class="calibre9"><span class="calibre10"><span><span class="bold1">Event Listener Interfaces</span></span></span></div>
<div class="calibre12"><span>Event listeners receive event notifications. Listeners for AWT-based events are created by implementing one or more of the interfaces defined by the <span class="bold1">java.awt.event</span> package. When an event occurs, the event source invokes the appropriate method defined by the listener and provides an event object as its argument. <a href="#filepos1272731">Table 15-3</a> lists several commonly used listener interfaces and provides a brief description of the methods they define.</span></div>
<div class="calibre28">
<div id="filepos1272731" class="calibre44"><span><img alt="image" src="images/00971.jpg" class="calibre919"/></span></div>
<div class="calibre9"><span><img alt="image" src="images/00057.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span><span class="bold1">Table 15-3</span>   Commonly Used Event Listener Interfaces</span></div><div class="calibre18"> </div>
</div>
<div id="filepos1273151" class="calibre9"><span class="calibre10"><span><span class="bold1">Using the Delegation Event Model</span></span></span></div>
<div class="calibre12"><span>Now that you have had an overview of the delegation event model and its various components, it is time to see it in practice. Applet programming using the delegation event model is actually quite easy. Just follow these two steps:</span></div>
<div class="calibre19"><span>  <span class="bold1">1.</span>  Implement the appropriate interface in the listener so that it will receive the type of event desired.</span></div>
<div class="calibre47"><span>  <span class="bold1">2.</span>  Implement code to register and unregister (if necessary) the listener as a recipient for the event notifications.</span></div>
<div class="calibre592"><span>Remember that a source may generate several types of events. Each event must be registered separately. Also, an object may register to receive several types of events, but it must implement all of the interfaces that are required to receive these events.</span></div>
<div class="calibre23"><span>To see how the delegation model works in practice, we will look at an example that handles one of the most commonly used event generators: the mouse. The example will show how to handle the basic mouse and mouse motion events. (Note that it is also possible to handle mouse wheel events, but this is left to you as an exercise.)</span></div>
<div id="filepos1274780" class="calibre1"><span class="calibre10"><span><span class="bold1">Handling Mouse and Mouse Motion Events</span></span></span></div>
<div class="calibre12"><span>To handle mouse and mouse motion events, you must implement the <span class="bold1">MouseListener</span> and the <span class="bold1">MouseMotionListener</span> interfaces. The <span class="bold1">MouseListener</span> interface defines five methods. If a mouse button is clicked, <span class="bold1">mouseClicked( )</span> is invoked. When the mouse enters a component, the <span class="bold1">mouseEntered( )</span> method is called. When it leaves, <span class="bold1">mouseExited( )</span> is called. The <span class="bold1">mousePressed( )</span> and <span class="bold1">mouseReleased( )</span> methods are invoked when a mouse button is pressed and released, respectively. The general forms of these methods are shown here:</span></div>
<div class="calibre27"><span>void mouseClicked(MouseEvent <span class="italic">me</span>)</span></div>
<div class="calibre27"><span>void mouseEntered(MouseEvent <span class="italic">me</span>)</span></div>
<div class="calibre27"><span>void mouseExited(MouseEvent <span class="italic">me</span>)</span></div>
<div class="calibre27"><span>void mousePressed(MouseEvent <span class="italic">me</span>)</span></div>
<div class="calibre27"><span>void mouseReleased(MouseEvent <span class="italic">me</span>)</span></div>
<div class="calibre592"><span>The <span class="bold1">MouseMotionListener</span> interface defines two methods. The <span class="bold1">mouseDragged( )</span> method is called multiple times as the mouse is dragged. The <span class="bold1">mouseMoved( )</span> method is called multiple times as the mouse is moved. Their general forms are shown here:</span></div>
<div class="calibre27"><span>void mouseDragged(MouseEvent <span class="italic">me</span>)</span></div>
<div class="calibre27"><span>void mouseMoved(MouseEvent <span class="italic">me</span>)</span></div>
<div class="calibre592"><span>The <span class="bold1">MouseEvent</span> object passed in <span class="italic">me</span> describes the event. <span class="bold1">MouseEvent</span> defines a number of methods that you can use to get information about what happened. Possibly the most commonly used methods in <span class="bold1">MouseEvent</span> are <span class="bold1">getX( )</span> and <span class="bold1">getY( )</span>. These return the X and Y coordinates of the mouse (relative to the window) when the event occurred. Their forms are shown here:</span></div>
<div class="calibre27"><span>int getX( )</span></div>
<div class="calibre27"><span>int getY( )</span></div>
<div class="calibre27"><span>The next example will use these methods to display the current location of the mouse.</span></div>
<div id="filepos1277359" class="calibre1"><span class="calibre10"><span><span class="bold1">A Simple Mouse Event Applet</span></span></span></div>
<div class="calibre12"><span>The following applet demonstrates handling the basic mouse events. It displays the current coordinates of the mouse in the applet’s status window. Each time a button is pressed, the word "Down" is displayed at the location of the mouse pointer. Each time the button is released, the word "Up" is shown. If a button is clicked, the message "Mouse clicked." is displayed in the upper-left corner of the applet display area.</span></div>
<div class="calibre23"><span>As the mouse enters or exits the applet window, a message is displayed in the upper-left corner of the applet display area. When dragging the mouse, a * is shown, which tracks with the mouse pointer as it is dragged. Notice that the two variables, <span class="bold1">mouseX</span> and <span class="bold1">mouseY</span>, store the location of the mouse when a mouse pressed, released, or dragged event occurs. These coordinates are then used by <span class="bold1">paint( )</span> to display output at the point of these occurrences.</span></div>
<div class="calibre35"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   You state that the</span> getX( ) <span class="bold1">and</span> getY( ) <span class="bold1">methods defined by</span> MouseEvent <span class="bold1">return the window-relative coordinates of the mouse. Are there methods that return its screen-relative (that is, absolute) location?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   Yes. <span class="bold1">MouseEvent</span> defines methods that obtain the X and Y coordinates of the mouse relative to the screen. They are shown here:</span></div>
<div class="calibre1"><span>int getXOnScreen( )</span></div>
<div class="calibre1"><span>int getYOnScreen( )</span></div>
<div class="calibre1"><span>You might find it interesting to experiment with these methods by substituting them for <span class="bold1">getX( )</span> and <span class="bold1">getY( )</span> in the <span class="bold1">MouseEvents</span> applet shown next.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre1"><span><img alt="image" src="images/00972.jpg" class="calibre920"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00973.jpg" class="calibre921"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00974.jpg" class="calibre922"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Sample output from this program is shown here:</span></div>
<div class="calibre29"><span><img alt="image" src="images/00975.jpg" class="calibre923"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Let’s look closely at this example. The <span class="bold1">MouseEvents</span> class extends <span class="bold1">Applet</span> and implements both the <span class="bold1">MouseListener</span> and <span class="bold1">MouseMotionListener</span> interfaces. These two interfaces contain methods that receive and process the various types of mouse events. Notice that the applet is both the source and the listener for these events. This works because <span class="bold1">Component</span>, which supplies the <span class="bold1">addMouseListener( )</span> and <span class="bold1">addMouseMotionListener( )</span> methods, is a superclass of <span class="bold1">Applet</span>. Being both the source and the listener for events is a common situation for applets.</span></div>
<div class="calibre23"><span>Inside <span class="bold1">init( )</span>, the applet registers itself as a listener for mouse events. This is done by using <span class="bold1">addMouseListener( )</span> and <span class="bold1">addMouseMotionListener( )</span>, which are members of <span class="bold1">Component</span>. They are shown here:</span></div>
<div class="calibre27"><span>void addMouseListener(MouseListener <span class="italic">ml</span>)</span></div>
<div class="calibre27"><span>void addMouseMotionListener(MouseMotionListener <span class="italic">mml</span>)</span></div>
<div class="calibre27"><span>Here, <span class="italic">ml</span> is a reference to the object receiving mouse events, and <span class="italic">mml</span> is a reference to the object receiving mouse motion events. In this program, the same object is used for both.</span></div>
<div class="calibre23"><span>The applet then implements all of the methods defined by the <span class="bold1">MouseListener</span> and <span class="bold1">MouseMotionListener</span> interfaces. These are the event handlers for the various mouse events. Each method handles its event and then returns.</span></div>
<div id="filepos1282466" class="calibre1"><span class="calibre10"><span><span class="bold1">More Java Keywords</span></span></span></div>
<div class="calibre12"><span>Before concluding this chapter, a few more Java keywords need to be briefly discussed:</span></div>
<div class="calibre24"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   <span class="bold1">transient</span></span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   <span class="bold1">volatile</span></span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   <span class="bold1">instanceof</span></span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   <span class="bold1">native</span></span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   <span class="bold1">strictfp</span></span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   <span class="bold1">assert</span></span></div>
<div class="calibre27"><span>These keywords are most often used in programs more advanced than those found in this book. However, an overview of each is presented so that you will know their purpose.</span></div>
<div id="filepos1284055" class="calibre1"><span class="calibre10"><span><span class="bold1">The transient and volatile Modifiers</span></span></span></div>
<div class="calibre12"><span>The <span class="bold1">transient</span> and <span class="bold1">volatile</span> keywords are type modifiers that handle somewhat specialized situations. When an instance variable is declared as <span class="bold1">transient</span>, then its value need not persist when an object is stored. Thus, a <span class="bold1">transient</span> field is one that does not affect the persisted state of an object.</span></div>
<div class="calibre23"><span>The <span class="bold1">volatile</span> modifier tells the compiler that a variable can be changed unexpectedly by other parts of your program. One of these situations involves multithreaded programs. In a multithreaded program, sometimes two or more threads will share the same variable. For efficiency considerations, each thread can keep its own, private copy of such a shared variable, possibly in a register of the CPU. The real (or <span class="italic">master</span>) copy of the variable is updated at various times, such as when a <span class="bold1">synchronized</span> method is entered. While this approach works fine, there may be times when it is inappropriate. In some cases, all that really matters is that the master copy of a variable always reflects the current state, and that this current state is used by all threads. To ensure this, declare the variable as <span class="bold1">volatile</span>.</span></div>
<div id="filepos1285489" class="calibre1"><span class="calibre10"><span><span class="bold1">instanceof</span></span></span></div>
<div class="calibre12"><span>Sometimes it is useful to know the type of an object during run time. For example, you might have one thread of execution that generates various types of objects and another thread that processes these objects. In this situation, it might be useful for the processing thread to know the type of each object when it receives it. Another situation in which knowledge of an object’s type at run time is important involves casting. In Java, an invalid cast causes a run-time error. Many invalid casts can be caught at compile time. However, casts involving class hierarchies can produce invalid casts that can only be detected at run time. Because a superclass reference can refer to subclass objects, it is not always possible to know at compile time whether or not a cast involving a superclass reference is valid. The <span class="bold1">instanceof</span> keyword addresses these types of situations. The <span class="bold1">instanceof</span> operator has this general form:</span></div>
<div class="calibre27"><span><span class="italic">objref</span> instanceof <span class="italic">type</span></span></div>
<div class="calibre27"><span>Here, <span class="italic">objref</span> is a reference to an instance of a class, and <span class="italic">type</span> is a class or interface type. If the object referred to by <span class="italic">objref</span> is of the specified type or can be cast into the specified type, then the <span class="bold1">instanceof</span> operator evaluates to <span class="bold1">true</span>. Otherwise, its result is <span class="bold1">false</span>. Thus, <span class="bold1">instanceof</span> is the means by which your program can obtain run-time type information about an object.</span></div>
<div id="filepos1287195" class="calibre1"><span class="calibre10"><span><span class="bold1">strictfp</span></span></span></div>
<div class="calibre12"><span>One of the more esoteric keywords is <span class="bold1">strictfp</span>. When Java 2 was released several years ago, the floating-point computation model was relaxed slightly. Specifically, the new model does not require the truncation of certain intermediate values that occur during a computation. This prevents overflow or underflow in some cases. By modifying a class, method, or interface with <span class="bold1">strictfp</span>, you ensure that floating-point calculations (and thus all truncations) take place precisely as they did in earlier versions of Java. When a class is modified by <span class="bold1">strictfp</span>, all of the methods in the class are also <span class="bold1">strictfp</span> automatically.</span></div>
<div id="filepos1288016" class="calibre1"><span class="calibre10"><span><span class="bold1">assert</span></span></span></div>
<div class="calibre12"><span>The <span class="bold1">assert</span> keyword is used during program development to create an <span class="italic">assertion</span>, which is a condition that is expected to be true during the execution of the program. For example, you might have a method that should always return a positive integer value. You might test this by asserting that the return value is greater than zero using an <span class="bold1">assert</span> statement. At run time, if the condition actually is true, no other action takes place. However, if the condition is false, then an <span class="bold1">AssertionError</span> is thrown. Assertions are often used during testing to verify that some expected condition is actually met. They are not usually used for released code.</span></div>
<div class="calibre23"><span>The <span class="bold1">assert</span> keyword has two forms. The first is shown here:</span></div>
<div class="calibre27"><span>assert <span class="italic">condition</span>;</span></div>
<div class="calibre27"><span>Here, <span class="italic">condition</span> is an expression that must evaluate to a Boolean result. If the result is true, then the assertion is true and no other action takes place. If the condition is false, then the assertion fails and a default <span class="bold1">AssertionError</span> object is thrown. For example,</span></div>
<div class="calibre1"><span><img alt="image" src="images/00976.jpg" class="calibre924"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>If <span class="bold1">n</span> is less than or equal to zero, then an <span class="bold1">AssertionError</span> is thrown. Otherwise, no action takes place.</span></div>
<div class="calibre23"><span>The second form of <span class="bold1">assert</span> is shown here:</span></div>
<div class="calibre27"><span>assert <span class="italic">condition</span> : <span class="italic">expr</span>;</span></div>
<div class="calibre27"><span>In this version, <span class="italic">expr</span> is a value that is passed to the <span class="bold1">AssertionError</span> constructor. This value is converted to its string format and displayed if an assertion fails. Typically, you will specify a string for <span class="italic">expr</span>, but any non-<span class="bold1">void</span> expression is allowed as long as it defines a reasonable string conversion.</span></div>
<div class="calibre23"><span>To enable assertion checking at run time, you must specify the <span class="bold1">-ea</span> option. For example, to enable assertions for <span class="bold1">Sample</span>, execute it using this line:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00977.jpg" class="calibre925"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Assertions are quite useful during development because they streamline the type of error checking that is common during testing. But be careful—you must not rely on an assertion to perform any action actually required by the program. The reason is that normally, released code will be run with assertions disabled and the expression in an assertion will not be evaluated.</span></div>
<div id="filepos1291179" class="calibre1"><span class="calibre10"><span><span class="bold1">Native Methods</span></span></span></div>
<div class="calibre12"><span>Although rare, there may occasionally be times when you will want to call a subroutine that is written in a language other than Java. Typically, such a subroutine will exist as executable code for the CPU and environment in which you are working—that is, native code. For example, you may wish to call a native code subroutine in order to achieve faster execution time. Or you may want to use a specialized, third-party library, such as a statistical package. However, since Java programs are compiled to bytecode, which is then interpreted (or compiled on the fly) by the Java run-time system, it would seem impossible to call a native code subroutine from within your Java program. Fortunately, this conclusion is false. Java provides the <span class="bold1">native</span> keyword, which is used to declare native code methods. Once declared, these methods can be called from inside your Java program just as you call any other Java method.</span></div>
<div class="calibre23"><span>To declare a native method, precede the method with the <span class="bold1">native</span> modifier, but do not define any body for the method. For example:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00978.jpg" class="calibre926"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Once you have declared a native method, you must provide the native method and follow a rather complex series of steps in order to link it with your Java code.</span></div>
<div class="calibre35"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   While we are on the subject of keywords, I have a question about</span> this. <span class="bold1">I have occasionally noticed a form of</span> this <span class="bold1">that takes parentheses. For example</span>,</span></div>
<div class="calibre1"><span><img alt="image" src="images/00979.jpg" class="calibre927"/></span></div>
<div class="calibre1"><span>Can you tell me what this does?</span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   The form of <span class="bold1">this</span> that you refer to enables one constructor to invoke another constructor within the same class. The general form of this use of <span class="bold1">this</span> is shown here:</span></div>
<div class="calibre1"><span>this(<span class="italic">arg-list</span>)</span></div>
<div class="calibre148"><span>When <span class="bold1">this( )</span> is executed, the overloaded constructor that matches the parameter list specified by <span class="italic">arg-list</span> is executed first. Then, if there are any statements inside the original constructor, they are executed. The call to <span class="bold1">this( )</span> must be the first statement within the constructor. Here is a simple example:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00980.jpg" class="calibre928"/></span></div>
<div class="calibre148"><span>In <span class="bold1">MyClass</span>, only the first constructor actually assigns a value to <span class="bold1">a</span> and <span class="bold1">b</span>. The second constructor simply invokes the first. Therefore, when this statement executes:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00981.jpg" class="calibre929"/></span></div>
<div class="calibre1"><span>the call to <span class="bold1">MyClass(8)</span> causes <span class="bold1">this(8, 8)</span> to be executed, which translates into a call to <span class="bold1">MyClass(8, 8)</span>.</span></div>
<div class="calibre624"><span>Invoking overloaded constructors through <span class="bold1">this( )</span> can be useful because it can prevent the unnecessary duplication of code. However, you need to be careful. Constructors that call <span class="bold1">this( )</span> will execute a bit slower than those that contain all of their initialization code in-line. This is because the call and return mechanism used when the second constructor is invoked adds overhead. Remember that object creation affects all users of your class. If your class will be used to create large numbers of objects, then you must carefully balance the benefits of smaller code against the increased time it takes to create an object. As you gain more experience with Java, you will find these types of decisions easier to make.</span></div>
<div class="calibre624"><span>There are two restrictions you need to keep in mind when using <span class="bold1">this( )</span>. First, you cannot use any instance variable of the constructor’s class in a call to <span class="bold1">this( )</span>. Second, you cannot use <span class="bold1">super( )</span> and <span class="bold1">this( )</span> in the same constructor because each must be the first statement in the constructor.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos1296605" class="calibre1"><span class="calibre10"><span><img alt="image" src="images/00059.jpg" class="calibre104"/>   <span class="bold1"><span class="italic">Chapter 15 Self Test</span></span></span></span></div><div class="calibre11"> </div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1296886" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1585400">1</a>.</span>  What method is called when an applet first begins running? What method is called when an applet is removed from the system?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1297178" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1585909">2</a>.</span>  Explain why an applet must use multithreading if it needs to run continually.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1297424" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1586506">3</a>.</span>  Enhance <a href="#filepos1253965">Try This 15-1</a> so that it displays the string passed to it as a parameter. Add a second parameter that specifies the time delay (in milliseconds) between each rotation.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1297795" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1587350">4</a>.</span>  Extra challenge: Create an applet that displays the current time, updated once per second. To accomplish this, you will need to do a little research. Here is a hint to help you get started: One way to obtain the current time is to use a <span class="bold1">Calendar</span> object, which is part of the <span class="bold1">java.util</span> package. (Remember, Oracle provides online documentation for all of Java’s standard classes.) You should now be at the point where you can examine the <span class="bold1">Calendar</span> class on your own and use its methods to solve this problem.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1298497" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1588464">5</a>.</span>  Briefly explain Java’s delegation event model.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1298719" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1589012">6</a>.</span>  Must an event listener register itself with a source?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1298941" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1589393">7</a>.</span>  Extra challenge: Another of Java’s display methods is <span class="bold1">drawLine( )</span>. It draws a line in the currently selected color between two points. It is part of the <span class="bold1">Graphics</span> class. Using <span class="bold1">drawLine( )</span>, write a program that tracks mouse movement. If the button is pressed, have the program draw a continuous line until the mouse button is released.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1299471" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1590238">8</a>.</span>  Briefly describe the <span class="bold1">assert</span> keyword.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos1299683" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1590724">9</a>.</span>  Give one reason why a native method might be useful to some types of programs.</span></div>
<div class="calibre47"><span><span class="bold1">10.</span>  Extra challenge: Try adding support for <span class="bold1">MouseWheelEvent</span> to the <span class="bold1">MouseEvents</span> applet shown in the section “Using the Delegation Event Model.” To do this, implement the <span class="bold1">MouseWheelListener</span> interface and add the applet as listener for this event by using <span class="bold1">addMouseWheelListener( )</span>. You will need to use Java’s API documentation to find the details about these items. No answer is given for this question. You must use your skills to provide your own solution.</span></div>  <div class="mbppagebreak" id="calibre_pb_22"></div>
</body></html>
