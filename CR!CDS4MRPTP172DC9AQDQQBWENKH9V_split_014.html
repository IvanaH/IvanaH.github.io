<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Java&amp;#8482;: A Beginner&amp;#8217;s Guide Sixth Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="filepos626773" class="calibre29"><span><img alt="image" src="images/00003.jpg" class="calibre30"/></span></div><div class="calibre11"> </div>
<div class="calibre31"><span class="calibre2"><span><big class="calibre3"><big class="calibre4"><big class="calibre5"><big class="calibre6"><big class="calibre32"><big class="calibre4">Chapter 7</big></big></big></big></big></big></span></span></div>
<div class="calibre9"><span class="calibre2"><span>Inheritance</span></span></div><div class="calibre33"> </div>
<div class="calibre1"><span class="calibre10"><span><span class="bold1">Key Skills &amp; Concepts</span></span></span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Understand inheritance basics</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Call superclass constructors</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Use <span class="bold1">super</span> to access superclass members</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Create a multilevel class hierarchy</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Know when constructors are called</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Understand superclass references to subclass objects</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Override methods</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Use overridden methods to achieve dynamic method dispatch</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Use abstract classes</span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Use <span class="bold1">final</span></span></div>
<div class="calibre26"><span><img alt="image" src="images/00002.jpg" class="calibre25"/>   Know the <span class="bold1">Object</span> class</span></div>
<div class="calibre1"><span><img alt="image" src="images/00004.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div class="calibre12"><span><span class="bold1"><span><span class="calibre2">I</span></span></span>nheritance is one of the three foundation principles of object-oriented programming because it allows the creation of hierarchical classifications. Using inheritance, you can create a general class that defines traits common to a set of related items. This class can then be inherited by other, more specific classes, each adding those things that are unique to it.</span></div>
<div class="calibre23"><span>In the language of Java, a class that is inherited is called a <span class="italic">superclass</span>. The class that does the inheriting is called a <span class="italic">subclass</span>. Therefore, a subclass is a specialized version of a superclass. It inherits all of the variables and methods defined by the superclass and adds its own, unique elements.</span></div>
<div id="filepos630488" class="calibre1"><span class="calibre10"><span><span class="bold1">Inheritance Basics</span></span></span></div>
<div class="calibre12"><span>Java supports inheritance by allowing one class to incorporate another class into its declaration. This is done by using the <span class="bold1">extends</span> keyword. Thus, the subclass adds to (extends) the superclass.</span></div>
<div class="calibre23"><span>Let’s begin with a short example that illustrates several of the key features of inheritance. The following program creates a superclass called <span class="bold1">TwoDShape</span>, which stores the width and height of a two-dimensional object, and a subclass called <span class="bold1">Triangle</span>. Notice how the keyword <span class="bold1">extends</span> is used to create a subclass.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00469.jpg" class="calibre488"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00470.jpg" class="calibre489"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The output from this program is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00471.jpg" class="calibre490"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Here, <span class="bold1">TwoDShape</span> defines the attributes of a “generic” two-dimensional shape, such as a square, rectangle, triangle, and so on. The <span class="bold1">Triangle</span> class creates a specific type of <span class="bold1">TwoDShape</span>, in this case, a triangle. The <span class="bold1">Triangle</span> class includes all of <span class="bold1">TwoDObject</span> and adds the field <span class="bold1">style</span>, the method <span class="bold1">area( )</span>, and the method <span class="bold1">showStyle( )</span>. The triangle’s style is stored in <span class="bold1">style</span>. This can be any string that describes the triangle, such as "filled", "outlined", "transparent", or even something like "warning symbol", "isosceles", or "rounded". The <span class="bold1">area( )</span> method computes and returns the area of the triangle, and <span class="bold1">showStyle( )</span> displays the triangle style.</span></div>
<div class="calibre23"><span>Because <span class="bold1">Triangle</span> includes all of the members of its superclass, <span class="bold1">TwoDShape</span>, it can access <span class="bold1">width</span> and <span class="bold1">height</span> inside <span class="bold1">area( )</span>. Also, inside <span class="bold1">main( )</span>, objects <span class="bold1">t1</span> and <span class="bold1">t2</span> can refer to <span class="bold1">width</span> and <span class="bold1">height</span> directly, as if they were part of <span class="bold1">Triangle</span>. <a href="#filepos633208">Figure 7-1</a> depicts conceptually how <span class="bold1">TwoDShape</span> is incorporated into <span class="bold1">Triangle</span>.</span></div>
<div class="calibre28">
<div id="filepos633208" class="calibre29"><span><img alt="image" src="images/00472.jpg" class="calibre491"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00057.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span><span class="bold1">Figure 7-1</span>   A conceptual depiction of the <span class="bold1">Triangle</span> class</span></div><div class="calibre18"> </div>
</div>
<div class="calibre23"><span>Even though <span class="bold1">TwoDShape</span> is a superclass for <span class="bold1">Triangle</span>, it is also a completely independent, stand-alone class. Being a superclass for a subclass does not mean that the superclass cannot be used by itself. For example, the following is perfectly valid:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00473.jpg" class="calibre492"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Of course, an object of <span class="bold1">TwoDShape</span> has no knowledge of or access to any subclasses of <span class="bold1">TwoDShape</span>.</span></div>
<div class="calibre23"><span>The general form of a <span class="bold1">class</span> declaration that inherits a superclass is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00474.jpg" class="calibre493"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>You can specify only one superclass for any subclass that you create. Java does not support the inheritance of multiple superclasses into a single subclass. (This differs from C++, in which you can inherit multiple base classes. Be aware of this when converting C++ code to Java.) You can, however, create a hierarchy of inheritance in which a subclass becomes a superclass of another subclass. Of course, no class can be a superclass of itself.</span></div>
<div class="calibre23"><span>A major advantage of inheritance is that once you have created a superclass that defines the attributes common to a set of objects, it can be used to create any number of more specific subclasses. Each subclass can precisely tailor its own classification. For example, here is another subclass of <span class="bold1">TwoDShape</span> that encapsulates rectangles:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00475.jpg" class="calibre494"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The <span class="bold1">Rectangle</span> class includes <span class="bold1">TwoDShape</span> and adds the methods <span class="bold1">isSquare( )</span>, which determines if the rectangle is square, and <span class="bold1">area( )</span>, which computes the area of a rectangle.</span></div>
<div id="filepos635899" class="calibre1"><span class="calibre10"><span><span class="bold1">Member Access and Inheritance</span></span></span></div>
<div class="calibre12"><span>As you learned in <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_013.html#filepos547570">Chapter 6</a>, often an instance variable of a class will be declared <span class="bold1">private</span> to prevent its unauthorized use or tampering. Inheriting a class <span class="italic">does not</span> overrule the <span class="bold1">private</span> access restriction. Thus, even though a subclass includes all of the members of its superclass, it cannot access those members of the superclass that have been declared <span class="bold1">private</span>. For example, if, as shown here, <span class="bold1">width</span> and <span class="bold1">height</span> are made private in <span class="bold1">TwoDShape</span>, then <span class="bold1">Triangle</span> will not be able to access them:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00476.jpg" class="calibre495"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The <span class="bold1">Triangle</span> class will not compile because the reference to <span class="bold1">width</span> and <span class="bold1">height</span> inside the <span class="bold1">area( )</span> method causes an access violation. Since <span class="bold1">width</span> and <span class="bold1">height</span> are declared <span class="bold1">private</span>, they are accessible only by other members of their own class. Subclasses have no access to them.</span></div>
<div class="calibre23"><span>Remember that a class member that has been declared <span class="bold1">private</span> will remain private to its class. It is not accessible by any code outside its class, including subclasses.</span></div>
<div class="calibre23"><span>At first, you might think that the fact that subclasses do not have access to the private members of superclasses is a serious restriction that would prevent the use of private members in many situations. However, this is not true. As explained in <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_013.html#filepos547570">Chapter 6</a>, Java programmers typically use accessor methods to provide access to the private members of a class. Here is a rewrite of the <span class="bold1">TwoDShape</span> and <span class="bold1">Triangle</span> classes that uses methods to access the private instance variables <span class="bold1">width</span> and <span class="bold1">height</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00477.jpg" class="calibre496"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00478.jpg" class="calibre497"/></span></div><div class="calibre11"> </div>
<div class="calibre29"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   When should I make an instance variable private?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   There are no hard and fast rules, but here are two general principles. If an instance variable is to be used only by methods defined within its class, then it should be made private. If an instance variable must be within certain bounds, then it should be private and made available only through accessor methods. This way, you can prevent invalid values from being assigned.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos639430" class="calibre9"><span class="calibre10"><span><span class="bold1">Constructors and Inheritance</span></span></span></div>
<div class="calibre12"><span>In a hierarchy, it is possible for both superclasses and subclasses to have their own constructors. This raises an important question: What constructor is responsible for building an object of the subclass—the one in the superclass, the one in the subclass, or both? The answer is this: The constructor for the superclass constructs the superclass portion of the object, and the constructor for the subclass constructs the subclass part. This makes sense because the superclass has no knowledge of or access to any element in a subclass. Thus, their construction must be separate. The preceding examples have relied upon the default constructors created automatically by Java, so this was not an issue. However, in practice, most classes will have explicit constructors. Here you will see how to handle this situation.</span></div>
<div class="calibre23"><span>When only the subclass defines a constructor, the process is straightforward: simply construct the subclass object. The superclass portion of the object is constructed automatically using its default constructor. For example, here is a reworked version of <span class="bold1">Triangle</span> that defines a constructor. It also makes <span class="bold1">style</span> private, since it is now set by the constructor.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00479.jpg" class="calibre498"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00480.jpg" class="calibre499"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, <span class="bold1">Triangle</span>’s constructor initializes the members of <span class="bold1">TwoDClass</span> that it inherits along with its own <span class="bold1">style</span> field.</span></div>
<div class="calibre23"><span>When both the superclass and the subclass define constructors, the process is a bit more complicated because both the superclass and subclass constructors must be executed. In this case, you must use another of Java’s keywords, <span class="bold1">super</span>, which has two general forms. The first calls a superclass constructor. The second is used to access a member of the superclass that has been hidden by a member of a subclass. Here, we will look at its first use.</span></div>
<div id="filepos641906" class="calibre1"><span class="calibre10"><span><span class="bold1">Using super to Call Superclass Constructors</span></span></span></div>
<div class="calibre12"><span>A subclass can call a constructor defined by its superclass by use of the following form of <span class="bold1">super</span>:</span></div>
<div class="calibre27"><span>super(<span class="italic">parameter-list</span>);</span></div>
<div class="calibre27"><span>Here, <span class="italic">parameter-list</span> specifies any parameters needed by the constructor in the superclass. <span class="bold1">super( )</span> must always be the first statement executed inside a subclass constructor. To see how <span class="bold1">super( )</span> is used, consider the version of <span class="bold1">TwoDShape</span> in the following program. It defines a constructor that initializes <span class="bold1">width</span> and <span class="bold1">height</span>.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00481.jpg" class="calibre500"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00482.jpg" class="calibre501"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, <span class="bold1">Triangle( )</span> calls <span class="bold1">super( )</span> with the parameters <span class="bold1">w</span> and <span class="bold1">h</span>. This causes the <span class="bold1">TwoDShape( )</span> constructor to be called, which initializes <span class="bold1">width</span> and <span class="bold1">height</span> using these values. <span class="bold1">Triangle</span> no longer initializes these values itself. It need only initialize the value unique to it: <span class="bold1">style</span>. This leaves <span class="bold1">TwoDShape</span> free to construct its subobject in any manner that it so chooses. Furthermore, <span class="bold1">TwoDShape</span> can add functionality about which existing subclasses have no knowledge, thus preventing existing code from breaking.</span></div>
<div class="calibre23"><span>Any form of constructor defined by the superclass can be called by <span class="bold1">super( )</span>. The constructor executed will be the one that matches the arguments. For example, here are expanded versions of both <span class="bold1">TwoDShape</span> and <span class="bold1">Triangle</span> that include default constructors and constructors that take one argument:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00483.jpg" class="calibre502"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00484.jpg" class="calibre503"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00485.jpg" class="calibre504"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Here is the output from this version:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00486.jpg" class="calibre505"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Let’s review the key concepts behind <span class="bold1">super( )</span>. When a subclass calls <span class="bold1">super( )</span>, it is calling the constructor of its immediate superclass. Thus, <span class="bold1">super( )</span> always refers to the superclass immediately above the calling class. This is true even in a multilevel hierarchy. Also, <span class="bold1">super( )</span> must always be the first statement executed inside a subclass constructor.</span></div>
<div id="filepos645156" class="calibre1"><span class="calibre10"><span><span class="bold1">Using super to Access Superclass Members</span></span></span></div>
<div class="calibre12"><span>There is a second form of <span class="bold1">super</span> that acts somewhat like <span class="bold1">this</span>, except that it always refers to the superclass of the subclass in which it is used. This usage has the following general form:</span></div>
<div class="calibre27"><span>super.<span class="italic">member</span></span></div>
<div class="calibre27"><span>Here, <span class="italic">member</span> can be either a method or an instance variable.</span></div>
<div class="calibre23"><span>This form of <span class="bold1">super</span> is most applicable to situations in which member names of a subclass hide members by the same name in the superclass. Consider this simple class hierarchy:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00487.jpg" class="calibre506"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>This program displays the following:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00488.jpg" class="calibre507"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Although the instance variable <span class="bold1">i</span> in <span class="bold1">B</span> hides the <span class="bold1">i</span> in <span class="bold1">A</span>, <span class="bold1">super</span> allows access to the <span class="bold1">i</span> defined in the superclass. <span class="bold1">super</span> can also be used to call methods that are hidden by a subclass.</span></div>
<div class="calibre18"> </div><table cellspacing="0" cellpadding="0" class="calibre37">
<colgroup class="calibre38">
<col class="calibre72"/>
<col class="calibre73"/>
</colgroup>
<tr class="calibre41">
<td valign="top" id="filepos646879" class="calibre74"><span class="calibre10"><span class="bold1">Try This 7–1</span> </span></td>
<td valign="top" class="calibre75"><span class="calibre10"><span class="bold1">Extending the Vehicle Class</span></span></td>
</tr></table><div class="calibre43"> </div>
<div class="calibre1"><span><img alt="image" src="images/00489.jpg" class="calibre508"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>To illustrate the power of inheritance, we will extend the <span class="bold1">Vehicle</span> class first developed in <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_011.html#filepos384353">Chapter 4</a>. As you should recall, <span class="bold1">Vehicle</span> encapsulates information about vehicles, including the number of passengers they can carry, their fuel capacity, and their fuel consumption rate. We can use the <span class="bold1">Vehicle</span> class as a starting point from which more specialized classes are developed. For example, one type of vehicle is a truck. An important attribute of a truck is its cargo capacity. Thus, to create a <span class="bold1">Truck</span> class, you can extend <span class="bold1">Vehicle</span>, adding an instance variable that stores the carrying capacity. Here is a version of <span class="bold1">Truck</span> that does this. In the process, the instance variables in <span class="bold1">Vehicle</span> will be made <span class="bold1">private</span>, and accessor methods are provided to get and set their values.</span></div>
<div class="calibre19"><span>  <span class="bold1">1.</span>  Create a file called <span class="bold1">TruckDemo.java</span> and copy the last implementation of <span class="bold1">Vehicle</span> from <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_011.html#filepos384353">Chapter 4</a> into the file:</span></div>
<div class="calibre47"><span>  <span class="bold1">2.</span>  Create the <span class="bold1">Truck</span> class as shown here:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00490.jpg" class="calibre118"/></span></div>
<div class="calibre47"><span>        Here, <span class="bold1">Truck</span> inherits <span class="bold1">Vehicle</span>, adding <span class="bold1">cargocap</span>, <span class="bold1">getCargo( )</span>, and <span class="bold1">putCargo( )</span>. Thus, <span class="bold1">Truck</span> includes all of the general vehicle attributes defined by <span class="bold1">Vehicle</span>. It need add only those items that are unique to its own class.</span></div>
<div class="calibre47"><span>  <span class="bold1">3.</span>  Next, make the instance variables of <span class="bold1">Vehicle</span> private, as shown here:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00491.jpg" class="calibre509"/></span></div>
<div class="calibre47"><span>  <span class="bold1">4.</span>  Here is an entire program that demonstrates the <span class="bold1">Truck</span> class:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00492.jpg" class="calibre510"/></span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00493.jpg" class="calibre511"/></span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00494.jpg" class="calibre512"/></span></div>
<div class="calibre47"><span>  <span class="bold1">5.</span>  The output from this program is shown here:</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00495.jpg" class="calibre513"/></span></div>
<div class="calibre47"><span>  <span class="bold1">6.</span>  Many other types of classes can be derived from <span class="bold1">Vehicle</span>. For example, the following skeleton creates an off-road class that stores the ground clearance of the vehicle.</span></div>
<div class="calibre47"><span>        <img alt="image" src="images/00496.jpg" class="calibre514"/></span></div>
<div class="calibre47"><span>        The key point is that once you have created a superclass that defines the general aspects of an object, that superclass can be inherited to form specialized classes. Each subclass simply adds its own, unique attributes. This is the essence of inheritance.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos651968" class="calibre9"><span class="calibre10"><span><span class="bold1">Creating a Multilevel Hierarchy</span></span></span></div>
<div class="calibre12"><span>Up to this point, we have been using simple class hierarchies that consist of only a superclass and a subclass. However, you can build hierarchies that contain as many layers of inheritance as you like. As mentioned, it is perfectly acceptable to use a subclass as a superclass of another. For example, given three classes called <span class="bold1">A</span>, <span class="bold1">B</span>, and <span class="bold1">C</span>, <span class="bold1">C</span> can be a subclass of <span class="bold1">B</span>, which is a subclass of <span class="bold1">A</span>. When this type of situation occurs, each subclass inherits all of the traits found in all of its superclasses. In this case, <span class="bold1">C</span> inherits all aspects of <span class="bold1">B</span> and <span class="bold1">A</span>.</span></div>
<div class="calibre23"><span>To see how a multilevel hierarchy can be useful, consider the following program. In it, the subclass <span class="bold1">Triangle</span> is used as a superclass to create the subclass called <span class="bold1">ColorTriangle</span>. <span class="bold1">ColorTriangle</span> inherits all of the traits of <span class="bold1">Triangle</span> and <span class="bold1">TwoDShape</span> and adds a field called <span class="bold1">color</span>, which holds the color of the triangle.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00497.jpg" class="calibre515"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00498.jpg" class="calibre516"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00499.jpg" class="calibre517"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>The output of this program is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00500.jpg" class="calibre518"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Because of inheritance, <span class="bold1">ColorTriangle</span> can make use of the previously defined classes of <span class="bold1">Triangle</span> and <span class="bold1">TwoDShape</span>, adding only the extra information it needs for its own, specific application. This is part of the value of inheritance; it allows the reuse of code.</span></div>
<div class="calibre23"><span>This example illustrates one other important point: <span class="bold1">super( )</span> always refers to the constructor in the closest superclass. The <span class="bold1">super( )</span> in <span class="bold1">ColorTriangle</span> calls the constructor in <span class="bold1">Triangle</span>. The <span class="bold1">super( )</span> in <span class="bold1">Triangle</span> calls the constructor in <span class="bold1">TwoDShape</span>. In a class hierarchy, if a superclass constructor requires parameters, then all subclasses must pass those parameters “up the line.” This is true whether or not a subclass needs parameters of its own.</span></div>
<div id="filepos654795" class="calibre1"><span class="calibre10"><span><span class="bold1">When Are Constructors Executed?</span></span></span></div>
<div class="calibre12"><span>In the foregoing discussion of inheritance and class hierarchies, an important question may have occurred to you: When a subclass object is created, whose constructor is executed first, the one in the subclass or the one defined by the superclass? For example, given a subclass called <span class="bold1">B</span> and a superclass called <span class="bold1">A</span>, is <span class="bold1">A</span>’s constructor executed before <span class="bold1">B</span>’s, or vice versa? The answer is that in a class hierarchy, constructors complete their execution in order of derivation, from superclass to subclass. Further, since <span class="bold1">super( )</span> must be the first statement executed in a subclass’ constructor, this order is the same whether or not <span class="bold1">super( )</span> is used. If <span class="bold1">super( )</span> is not used, then the default (parameterless) constructor of each superclass will be executed. The following program illustrates when constructors are executed:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00501.jpg" class="calibre519"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The output from this program is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00502.jpg" class="calibre520"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>As you can see, the constructors are executed in order of derivation.</span></div>
<div class="calibre23"><span>If you think about it, it makes sense that constructors are executed in order of derivation. Because a superclass has no knowledge of any subclass, any initialization it needs to perform is separate from and possibly prerequisite to any initialization performed by the subclass. Therefore, it must complete its execution first.</span></div>
<div id="filepos656786" class="calibre1"><span class="calibre10"><span><span class="bold1">Superclass References and Subclass Objects</span></span></span></div>
<div class="calibre12"><span>As you know, Java is a strongly typed language. Aside from the standard conversions and automatic promotions that apply to its primitive types, type compatibility is strictly enforced. Therefore, a reference variable for one class type cannot normally refer to an object of another class type. For example, consider the following program:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00503.jpg" class="calibre521"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, even though class <span class="bold1">X</span> and class <span class="bold1">Y</span> are structurally the same, it is not possible to assign an <span class="bold1">X</span> reference to a <span class="bold1">Y</span> object because they have different types. In general, an object reference variable can refer only to objects of its type.</span></div>
<div class="calibre23"><span>There is, however, an important exception to Java’s strict type enforcement. A reference variable of a superclass can be assigned a reference to an object of any subclass derived from that superclass. In other words, a superclass reference can refer to a subclass object. Here is an example:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00504.jpg" class="calibre522"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, <span class="bold1">Y</span> is now derived from <span class="bold1">X</span>; thus, it is permissible for <span class="bold1">x2</span> to be assigned a reference to a <span class="bold1">Y</span> object.</span></div>
<div class="calibre23"><span>It is important to understand that it is the type of the reference variable—not the type of the object that it refers to—that determines what members can be accessed. That is, when a reference to a subclass object is assigned to a superclass reference variable, you will have access only to those parts of the object defined by the superclass. This is why <span class="bold1">x2</span> can’t access <span class="bold1">b</span> even when it refers to a <span class="bold1">Y</span> object. If you think about it, this makes sense, because the superclass has no knowledge of what a subclass adds to it. This is why the last line of code in the program is commented out.</span></div>
<div class="calibre23"><span>Although the preceding discussion may seem a bit esoteric, it has some important practical applications. One is described here. The other is discussed later in this chapter, when method overriding is covered.</span></div>
<div class="calibre23"><span>An important place where subclass references are assigned to superclass variables is when constructors are called in a class hierarchy. As you know, it is common for a class to define a constructor that takes an object of the class as a parameter. This allows the class to construct a copy of an object. Subclasses of such a class can take advantage of this feature. For example, consider the following versions of <span class="bold1">TwoDShape</span> and <span class="bold1">Triangle</span>. Both add constructors that take an object as a parameter.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00505.jpg" class="calibre523"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00506.jpg" class="calibre524"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00507.jpg" class="calibre525"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>In this program, <span class="bold1">t2</span> is constructed from <span class="bold1">t1</span> and is, thus, identical. The output is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00508.jpg" class="calibre526"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Pay special attention to this <span class="bold1">Triangle</span> constructor:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00509.jpg" class="calibre527"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>It receives an object of type <span class="bold1">Triangle</span> and it passes that object (through <span class="bold1">super</span>) to this <span class="bold1">TwoDShape</span> constructor:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00510.jpg" class="calibre528"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>The key point is that <span class="bold1">TwoDshape( )</span> is expecting a <span class="bold1">TwoDShape</span> object. However, <span class="bold1">Triangle( )</span> passes it a <span class="bold1">Triangle</span> object. The reason this works is because, as explained, a superclass reference can refer to a subclass object. Thus, it is perfectly acceptable to pass <span class="bold1">TwoDShape( )</span> a reference to an object of a class derived from <span class="bold1">TwoDShape</span>. Because the <span class="bold1">TwoDShape( )</span> constructor is initializing only those portions of the subclass object that are members of <span class="bold1">TwoDShape</span>, it doesn’t matter that the object might also contain other members added by derived classes.</span></div>
<div id="filepos662071" class="calibre1"><span class="calibre10"><span><span class="bold1">Method Overriding</span></span></span></div>
<div class="calibre12"><span>In a class hierarchy, when a method in a subclass has the same return type and signature as a method in its superclass, then the method in the subclass is said to <span class="italic">override</span> the method in the superclass. When an overridden method is called from within a subclass, it will always refer to the version of that method defined by the subclass. The version of the method defined by the superclass will be hidden. Consider the following:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00511.jpg" class="calibre529"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>The output produced by this program is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00512.jpg" class="calibre530"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>When <span class="bold1">show( )</span> is invoked on an object of type <span class="bold1">B</span>, the version of <span class="bold1">show( )</span> defined within <span class="bold1">B</span> is used. That is, the version of <span class="bold1">show( )</span> inside <span class="bold1">B</span> overrides the version declared in <span class="bold1">A</span>.</span></div>
<div class="calibre23"><span>If you want to access the superclass version of an overridden method, you can do so by using <span class="bold1">super</span>. For example, in this version of <span class="bold1">B</span>, the superclass version of <span class="bold1">show( )</span> is invoked within the subclass’ version. This allows all instance variables to be displayed.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00513.jpg" class="calibre531"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>If you substitute this version of <span class="bold1">show( )</span> into the previous program, you will see the following output:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00514.jpg" class="calibre188"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Here, <span class="bold1">super.show( )</span> calls the superclass version of <span class="bold1">show( )</span>.</span></div>
<div class="calibre23"><span>Method overriding occurs only when the signatures of the two methods are identical. If they are not, then the two methods are simply overloaded. For example, consider this modified version of the preceding example:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00515.jpg" class="calibre532"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>The output produced by this program is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00516.jpg" class="calibre533"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>The version of <span class="bold1">show( )</span> in <span class="bold1">B</span> takes a string parameter. This makes its signature different from the one in <span class="bold1">A</span>, which takes no parameters. Therefore, no overriding (or name hiding) takes place.</span></div>
<div id="filepos665296" class="calibre1"><span class="calibre10"><span><span class="bold1">Overridden Methods Support Polymorphism</span></span></span></div>
<div class="calibre12"><span>While the examples in the preceding section demonstrate the mechanics of method overriding, they do not show its power. Indeed, if there were nothing more to method overriding than a namespace convention, then it would be, at best, an interesting curiosity but of little real value. However, this is not the case. Method overriding forms the basis for one of Java’s most powerful concepts: <span class="italic">dynamic method dispatch</span>. Dynamic method dispatch is the mechanism by which a call to an overridden method is resolved at run time rather than compile time. Dynamic method dispatch is important because this is how Java implements run-time polymorphism.</span></div>
<div class="calibre23"><span>Let’s begin by restating an important principle: a superclass reference variable can refer to a subclass object. Java uses this fact to resolve calls to overridden methods at run time. Here’s how. When an overridden method is called through a superclass reference, Java determines which version of that method to execute based upon the type of the object being referred to at the time the call occurs. Thus, this determination is made at run time. When different types of objects are referred to, different versions of an overridden method will be called. In other words, <span class="italic">it is the type of the object being referred to</span> (not the type of the reference variable) that determines which version of an overridden method will be executed. Therefore, if a superclass contains a method that is overridden by a subclass, then when different types of objects are referred to through a superclass reference variable, different versions of the method are executed.</span></div>
<div class="calibre23"><span>Here is an example that illustrates dynamic method dispatch:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00517.jpg" class="calibre534"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>The output from the program is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00518.jpg" class="calibre535"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>This program creates a superclass called <span class="bold1">Sup</span> and two subclasses of it, called <span class="bold1">Sub1</span> and <span class="bold1">Sub2</span>. <span class="bold1">Sup</span> declares a method called <span class="bold1">who( )</span>, and the subclasses override it. Inside the <span class="bold1">main( )</span> method, objects of type <span class="bold1">Sup</span>, <span class="bold1">Sub1</span>, and <span class="bold1">Sub2</span> are declared. Also, a reference of type <span class="bold1">Sup</span>, called <span class="bold1">supRef</span>, is declared. The program then assigns a reference to each type of object to <span class="bold1">supRef</span> and uses that reference to call <span class="bold1">who( )</span>. As the output shows, the version of <span class="bold1">who( )</span> executed is determined by the type of object being referred to at the time of the call, not by the class type of <span class="bold1">supRef</span>.</span></div>
<div class="calibre35"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   Overridden methods in Java look a lot like virtual functions in C++. Is there a similarity?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   Yes. Readers familiar with C++ will recognize that overridden methods in Java are equivalent in purpose and similar in operation to virtual functions in C++.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos669388" class="calibre9"><span class="calibre10"><span><span class="bold1">Why Overridden Methods?</span></span></span></div>
<div class="calibre12"><span>As stated earlier, overridden methods allow Java to support run-time polymorphism. Polymorphism is essential to object-oriented programming for one reason: it allows a general class to specify methods that will be common to all of its derivatives, while allowing subclasses to define the specific implementation of some or all of those methods. Overridden methods are another way that Java implements the “one interface, multiple methods” aspect of polymorphism. Part of the key to successfully applying polymorphism is understanding that the superclasses and subclasses form a hierarchy that moves from lesser to greater specialization. Used correctly, the superclass provides all elements that a subclass can use directly. It also defines those methods that the derived class must implement on its own. This allows the subclass the flexibility to define its own methods, yet still enforces a consistent interface. Thus, by combining inheritance with overridden methods, a superclass can define the general form of the methods that will be used by all of its subclasses.</span></div>
<div id="filepos670662" class="calibre1"><span class="calibre10"><span><span class="bold1">Applying Method Overriding to TwoDShape</span></span></span></div>
<div class="calibre12"><span>To better understand the power of method overriding, we will apply it to the <span class="bold1">TwoDShape</span> class. In the preceding examples, each class derived from <span class="bold1">TwoDShape</span> defines a method called <span class="bold1">area( )</span>. This suggests that it might be better to make <span class="bold1">area( )</span> part of the <span class="bold1">TwoDShape</span> class, allowing each subclass to override it, defining how the area is calculated for the type of shape that the class encapsulates. The following program does this. For convenience, it also adds a name field to <span class="bold1">TwoDShape</span>. (This makes it easier to write demonstration programs.)</span></div>
<div class="calibre1"><span><img alt="image" src="images/00519.jpg" class="calibre536"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00520.jpg" class="calibre537"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00521.jpg" class="calibre538"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00522.jpg" class="calibre539"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>The output from the program is shown here:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00523.jpg" class="calibre540"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>Let’s examine this program closely. First, as explained, <span class="bold1">area( )</span> is now part of the <span class="bold1">TwoDShape</span> class and is overridden by <span class="bold1">Triangle</span> and <span class="bold1">Rectangle</span>. Inside <span class="bold1">TwoDShape</span>, <span class="bold1">area( )</span> is given a placeholder implementation that simply informs the user that this method must be overridden by a subclass. Each override of <span class="bold1">area( )</span> supplies an implementation that is suitable for the type of object encapsulated by the subclass. Thus, if you were to implement an ellipse class, for example, then <span class="bold1">area( )</span> would need to compute the <span class="bold1">area( )</span> of an ellipse.</span></div>
<div class="calibre23"><span>There is one other important feature in the preceding program. Notice in <span class="bold1">main( )</span> that <span class="bold1">shapes</span> is declared as an array of <span class="bold1">TwoDShape</span> objects. However, the elements of this array are assigned <span class="bold1">Triangle</span>, <span class="bold1">Rectangle</span>, and <span class="bold1">TwoDShape</span> references. This is valid because, as explained, a superclass reference can refer to a subclass object. The program then cycles through the array, displaying information about each object. Although quite simple, this illustrates the power of both inheritance and method overriding. The type of object referred to by a superclass reference variable is determined at run time and acted on accordingly. If an object is derived from <span class="bold1">TwoDShape</span>, then its area can be obtained by calling <span class="bold1">area( )</span>. The interface to this operation is the same no matter what type of shape is being used.</span></div>
<div id="filepos673851" class="calibre1"><span class="calibre10"><span><span class="bold1">Using Abstract Classes</span></span></span></div>
<div class="calibre12"><span>Sometimes you will want to create a superclass that defines only a generalized form that will be shared by all of its subclasses, leaving it to each subclass to fill in the details. Such a class determines the nature of the methods that the subclasses must implement but does not, itself, provide an implementation of one or more of these methods. One way this situation can occur is when a superclass is unable to create a meaningful implementation for a method. This is the case with the version of <span class="bold1">TwoDShape</span> used in the preceding example. The definition of <span class="bold1">area( )</span> is simply a placeholder. It will not compute and display the area of any type of object.</span></div>
<div class="calibre23"><span>As you will see as you create your own class libraries, it is not uncommon for a method to have no meaningful definition in the context of its superclass. You can handle this situation in two ways. One way, as shown in the previous example, is to simply have it report a warning message. While this approach can be useful in certain situations—such as debugging—it is not usually appropriate. You may have methods which must be overridden by the subclass in order for the subclass to have any meaning. Consider the class <span class="bold1">Triangle</span>. It is incomplete if <span class="bold1">area( )</span> is not defined. In this case, you want some way to ensure that a subclass does, indeed, override all necessary methods. Java’s solution to this problem is the <span class="italic">abstract method</span>.</span></div>
<div class="calibre23"><span>An abstract method is created by specifying the <span class="bold1">abstract</span> type modifier. An abstract method contains no body and is, therefore, not implemented by the superclass. Thus, a subclass must override it—it cannot simply use the version defined in the superclass. To declare an abstract method, use this general form:</span></div>
<div class="calibre27"><span>abstract <span class="italic">type name</span>(<span class="italic">parameter-list</span>);</span></div>
<div class="calibre27"><span>As you can see, no method body is present. The <span class="bold1">abstract</span> modifier can be used only on instance methods. It cannot be applied to <span class="bold1">static</span> methods or to constructors.</span></div>
<div class="calibre23"><span>A class that contains one or more abstract methods must also be declared as abstract by preceding its <span class="bold1">class</span> declaration with the <span class="bold1">abstract</span> modifier. Since an abstract class does not define a complete implementation, there can be no objects of an abstract class. Thus, attempting to create an object of an abstract class by using <span class="bold1">new</span> will result in a compile-time error.</span></div>
<div class="calibre23"><span>When a subclass inherits an abstract class, it must implement all of the abstract methods in the superclass. If it doesn’t, then the subclass must also be specified as <span class="bold1">abstract</span>. Thus, the <span class="bold1">abstract</span> attribute is inherited until such time as a complete implementation is achieved.</span></div>
<div class="calibre23"><span>Using an abstract class, you can improve the <span class="bold1">TwoDShape</span> class. Since there is no meaningful concept of area for an undefined two-dimensional figure, the following version of the preceding program declares <span class="bold1">area( )</span> as <span class="bold1">abstract</span> inside <span class="bold1">TwoDShape</span>, and <span class="bold1">TwoDShape</span> as <span class="bold1">abstract</span>. This, of course, means that all classes derived from <span class="bold1">TwoDShape</span> must override <span class="bold1">area( )</span>.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00524.jpg" class="calibre541"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00525.jpg" class="calibre542"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00526.jpg" class="calibre543"/></span></div><div class="calibre11"> </div>
<div class="calibre1"><span><img alt="image" src="images/00527.jpg" class="calibre544"/></span></div><div class="calibre11"> </div>
<div class="calibre23"><span>As the program illustrates, all subclasses of <span class="bold1">TwoDShape</span>
<span class="italic">must</span> override <span class="bold1">area( )</span>. To prove this to yourself, try creating a subclass that does not override <span class="bold1">area( )</span>. You will receive a compile-time error. Of course, it is still possible to create an object reference of type <span class="bold1">TwoDShape</span>, which the program does. However, it is no longer possible to declare objects of type <span class="bold1">TwoDShape</span>. Because of this, in <span class="bold1">main( )</span> the <span class="bold1">shapes</span> array has been shortened to 4, and a <span class="bold1">TwoDShape</span> object is no longer created.</span></div>
<div class="calibre23"><span>One last point: Notice that <span class="bold1">TwoDShape</span> still includes the <span class="bold1">showDim( )</span> and <span class="bold1">getName( )</span> methods and that these are not modified by <span class="bold1">abstract</span>. It is perfectly acceptable—indeed, quite common—for an abstract class to contain concrete methods which a subclass is free to use as is. Only those methods declared as <span class="bold1">abstract</span> need be overridden by subclasses.</span></div>
<div id="filepos679261" class="calibre1"><span class="calibre10"><span><span class="bold1">Using final</span></span></span></div>
<div class="calibre12"><span>As powerful and useful as method overriding and inheritance are, sometimes you will want to prevent them. For example, you might have a class that encapsulates control of some hardware device. Further, this class might offer the user the ability to initialize the device, making use of private, proprietary information. In this case, you don’t want users of your class to be able to override the initialization method. Whatever the reason, in Java it is easy to prevent a method from being overridden or a class from being inherited by using the keyword <span class="bold1">final</span>.</span></div>
<div id="filepos680012" class="calibre1"><span class="calibre10"><span><span class="bold1">final Prevents Overriding</span></span></span></div>
<div class="calibre12"><span>To prevent a method from being overridden, specify <span class="bold1">final</span> as a modifier at the start of its declaration. Methods declared as <span class="bold1">final</span> cannot be overridden. The following fragment illustrates <span class="bold1">final</span>:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00528.jpg" class="calibre545"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Because <span class="bold1">meth( )</span> is declared as <span class="bold1">final</span>, it cannot be overridden in <span class="bold1">B</span>. If you attempt to do so, a compile-time error will result.</span></div>
<div id="filepos680762" class="calibre1"><span class="calibre10"><span><span class="bold1">final Prevents Inheritance</span></span></span></div>
<div class="calibre12"><span>You can prevent a class from being inherited by preceding its declaration with <span class="bold1">final</span>. Declaring a class as <span class="bold1">final</span> implicitly declares all of its methods as <span class="bold1">final</span>, too. As you might expect, it is illegal to declare a class as both <span class="bold1">abstract</span> and <span class="bold1">final</span> since an abstract class is incomplete by itself and relies upon its subclasses to provide complete implementations.</span></div>
<div class="calibre23"><span>Here is an example of a <span class="bold1">final</span> class:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00529.jpg" class="calibre546"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>As the comments imply, it is illegal for <span class="bold1">B</span> to inherit <span class="bold1">A</span> since <span class="bold1">A</span> is declared as <span class="bold1">final</span>.</span></div>
<div id="filepos681780" class="calibre1"><span class="calibre10"><span><span class="bold1">Using final with Data Members</span></span></span></div>
<div class="calibre12"><span>In addition to the uses of <span class="bold1">final</span> just shown, <span class="bold1">final</span> can also be applied to member variables to create what amounts to named constants. If you precede a class variable’s name with <span class="bold1">final</span>, its value cannot be changed throughout the lifetime of your program. You can, of course, give that variable an initial value. For example, in <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_013.html#filepos547570">Chapter 6</a> a simple error-management class called <span class="bold1">ErrorMsg</span> was shown. That class mapped a human-readable string to an error code. Here, that original class is improved by the addition of <span class="bold1">final</span> constants which stand for the errors. Now, instead of passing <span class="bold1">getErrorMsg( )</span> a number such as 2, you can pass the named integer constant <span class="bold1">DISKERR</span>.</span></div>
<div class="calibre1"><span><img alt="image" src="images/00530.jpg" class="calibre547"/></span></div><div class="calibre11"> </div>
<div class="calibre12"><span>Notice how the <span class="bold1">final</span> constants are used in <span class="bold1">main( )</span>. Since they are members of the <span class="bold1">ErrorMsg</span> class, they must be accessed via an object of that class. Of course, they can also be inherited by subclasses and accessed directly inside those subclasses.</span></div>
<div class="calibre23"><span>As a point of style, many Java programmers use uppercase identifiers for <span class="bold1">final</span> constants, as does the preceding example. But this is not a hard and fast rule.</span></div>
<div class="calibre35"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div>
<div class="calibre9"><span class="calibre10"><span><span class="bold1">Ask the Expert</span></span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">Q</span></span>:   Can</span> final <span class="bold1">member variables be made</span> static? <span class="bold1">Can</span> final <span class="bold1">be used on method parameters and local variables?</span></span></div>
<div class="calibre19"><span><span class="bold1"><span><span class="calibre10">A</span></span>:</span>   The answer to both is Yes. Making a <span class="bold1">final</span> member variable <span class="bold1">static</span> lets you refer to the constant through its class name rather than through an object. For example, if the constants in <span class="bold1">ErrorMsg</span> were modified by <span class="bold1">static</span>, then the <span class="bold1">println( )</span> statements in <span class="bold1">main( )</span> could look like this:</span></div>
<div class="calibre1"><span><img alt="image" src="images/00531.jpg" class="calibre548"/></span></div>
<div class="calibre1"><span>Declaring a parameter <span class="bold1">final</span> prevents it from being changed within the method. Declaring a local variable <span class="bold1">final</span> prevents it from being assigned a value more than once.</span></div>
<div class="calibre36"><span><img alt="image" src="images/00005.jpg" class="calibre34"/></span></div><div class="calibre18"> </div>
<div id="filepos684942" class="calibre9"><span class="calibre10"><span><span class="bold1">The Object Class</span></span></span></div>
<div class="calibre12"><span>Java defines one special class called <span class="bold1">Object</span> that is an implicit superclass of all other classes. In other words, all other classes are subclasses of <span class="bold1">Object</span>. This means that a reference variable of type <span class="bold1">Object</span> can refer to an object of any other class. Also, since arrays are implemented as classes, a variable of type <span class="bold1">Object</span> can also refer to any array.</span></div>
<div class="calibre23"><span><span class="bold1">Object</span> defines the following methods, which means that they are available in every object:</span></div>
<div class="calibre11"> </div><table border="1" cellpadding="3" cellspacing="0" class="calibre37">
<tr class="calibre41">
<td valign="top" class="calibre83"><span class="bold1">Method</span></td>
<td valign="top" class="calibre83"><span class="bold1">Purpose</span></td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">Object clone( )</td>
<td valign="top" class="calibre42">Creates a new object that is the same as the object being cloned.</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">boolean equals(Object <span class="italic">object</span>)</td>
<td valign="top" class="calibre42">Determines whether one object is equal to another.</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">void finalize( )</td>
<td valign="top" class="calibre42">Called before an unused object is recycled.</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">Class&lt;?&gt; getClass( )</td>
<td valign="top" class="calibre42">Obtains the class of an object at run time.</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">int hashCode( )</td>
<td valign="top" class="calibre42">Returns the hash code associated with the invoking object.</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">void notify( )</td>
<td valign="top" class="calibre42">Resumes execution of a thread waiting on the invoking object.</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">void notifyAll( )</td>
<td valign="top" class="calibre42">Resumes execution of all threads waiting on the invoking object.</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">String toString( )</td>
<td valign="top" class="calibre42">Returns a string that describes the object.</td>
</tr>
<tr class="calibre41">
<td valign="top" class="calibre42">void wait( ) <div class="calibre549"><span>void wait(long <span class="italic">milliseconds</span>)</span></div>
<div class="calibre549"><span>void wait(long <span class="italic">milliseconds</span>, int <span class="italic">nanoseconds</span>)</span></div></td>
<td valign="top" class="calibre42">Waits on another thread of execution.</td>
</tr>
</table><div class="calibre43"> </div>
<div class="calibre23"><span>The methods <span class="bold1">getClass( )</span>, <span class="bold1">notify( )</span>, <span class="bold1">notifyAll( )</span>, and <span class="bold1">wait( )</span> are declared as <span class="bold1">final</span>. You can override the others. Several of these methods are described later in this book. However, notice two methods now: <span class="bold1">equals( )</span> and <span class="bold1">toString( )</span>. The <span class="bold1">equals( )</span> method compares two objects. It returns <span class="bold1">true</span> if the objects are equivalent, and <span class="bold1">false</span> otherwise. The <span class="bold1">toString( )</span> method returns a string that contains a description of the object on which it is called. Also, this method is automatically called when an object is output using <span class="bold1">println( )</span>. Many classes override this method. Doing so allows them to tailor a description specifically for the types of objects that they create.</span></div>
<div class="calibre23"><span>One last point: Notice the unusual syntax in the return type for <span class="bold1">getClass( )</span>. This relates to Java’s <span class="italic">generics</span> feature. Generics allow the type of data used by a class or method to be specified as a parameter. Generics are discussed in <a href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_020.html#filepos1060750">Chapter 13</a>.</span></div>
<div id="filepos689469" class="calibre44"><span class="calibre10"><span><img alt="image" src="images/00059.jpg" class="calibre104"/>   <span class="bold1"><span class="italic">Chapter 7 Self Test</span></span></span></span></div><div class="calibre11"> </div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos689749" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1525820">1</a>.</span>  Does a superclass have access to the members of a subclass? Does a subclass have access to the members of a superclass?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos690036" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1526328">2</a>.</span>  Create a subclass of <span class="bold1">TwoDShape</span> called <span class="bold1">Circle</span>. Include an <span class="bold1">area( )</span> method that computes the area of the circle and a constructor that uses <span class="bold1">super</span> to initialize the <span class="bold1">TwoDShape</span> portion.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos690418" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1526867">3</a>.</span>  How do you prevent a subclass from having access to a member of a superclass?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos690663" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1527312">4</a>.</span>  Describe the purpose and use of the two versions of <span class="bold1">super</span> described in this chapter.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos690922" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1528292">5</a>.</span>  Given the following hierarchy:</span></div>
<div class="calibre31"><blockquote class="calibre66"><span><img alt="image" src="images/00532.jpg" class="calibre550"/></span></blockquote></div>
<div class="calibre21"><span>        In what order do the constructors for these classes complete their execution when a <span class="bold1">Gamma</span> object is instantiated?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos691550" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1529026">6</a>.</span>  A superclass reference can refer to a subclass object. Explain why this is important as it relates to method overriding.</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos691838" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1529583">7</a>.</span>  What is an abstract class?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos692032" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1529930">8</a>.</span>  How do you prevent a method from being overridden? How do you prevent a class from being inherited?</span></div>
<div class="calibre47"><span>  <span class="bold1"><a id="filepos692299" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1530433">9</a>.</span>  Explain how inheritance, method overriding, and abstract classes are used to support polymorphism.</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos692549" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1531136">10</a>.</span>  What class is a superclass of every other class?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos692751" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1531459">11</a>.</span>  A class that contains at least one abstract method must, itself, be declared abstract. True or False?</span></div>
<div class="calibre47"><span><span class="bold1"><a id="filepos693006" href="CR%21CDS4MRPTP172DC9AQDQQBWENKH9V_split_025.html#filepos1531816">12</a>.</span>  What keyword is used to create a named constant?</span></div>  <div class="mbppagebreak" id="calibre_pb_14"></div>
</body></html>
